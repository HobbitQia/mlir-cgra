// -----// IR Dump After SodaKernelOutlining //----- //
#map0 = affine_map<(d0, d1, d2, d3) -> (d0 * 1225 + d1 * 35 + d2 + d3 + 36)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d3, d0, d1, d2)>
#map2 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map3 = affine_map<(d0, d1, d2, d3) -> (d3)>
#map4 = affine_map<(d0, d1) -> (d0, d1)>
#map5 = affine_map<(d0, d1) -> (d1)>
#map6 = affine_map<(d0, d1) -> (d0)>
module attributes {soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  memref.global "private" constant @__constant_2xf32 : memref<2xf32> = dense<0.000000e+00>
  memref.global "private" constant @__constant_4xf32 : memref<4xf32> = dense<0.000000e+00>
  memref.global "private" constant @__constant_8xf32 : memref<8xf32> = dense<0.000000e+00>
  memref.global "private" constant @__constant_1xf32 : memref<1xf32> = dense<0.000000e+00>
  memref.global "private" constant @__constant_1x5x5x1xf32 : memref<1x5x5x1xf32> = dense<[[[[-0.144123852], [-0.203296721], [0.0245194137], [0.0424404144], [-5.772960e-02]], [[0.213269472], [-0.00469377637], [0.345114052], [0.136302114], [-0.259548783]], [[0.145365268], [0.112524837], [0.0500608087], [-0.0937015414], [-0.0550665557]], [[0.0901061296], [0.286698043], [0.111992478], [0.231037259], [-0.28824234]], [[-0.15258716], [-0.335655361], [0.156836212], [0.183970571], [0.124615282]]]]>
  memref.global "private" constant @__constant_1x256x8xf32 : memref<1x256x8xf32> = dense<"0x28DF883CAB19ACBDE456E13DA638AB3DBC37333D00FD153C49EA15BEE0A3E63DC09215BC86E30BBDC072EE3DF0EE283D5CCB19BED4EADC3DF221F2BDFA0A0E3E9138B2BD7CB5483D5209EABDAA9FD8BDE465163EB4CED43DCC0707BEFCFC413DF01A3EBCE451153E74D2F03DB644A43D7CF99A3D04CD7BBD50874ABC64BC5C3D294196BDF4B1433D666CAF3D80D8163E8F47AFBDBAF214BE00B68DB95562F8BD70BA103E3442DC3DCC01DD3DD07A09BC603AF03B08BD673D18DAD13CC69C8A3D39200ABE0178A4BDD2C2163E05F2DBBDD816F03D84D2A53DCEC495BD0EC215BE4A58B63D0065FEBA9C647E3D80F409BC04A3953D7C3A57BD503D97BCDAA5ACBDB060103D5E5AD7BD12A32FBDFC49163EE095D73DC2260CBE9785E5BD645572BD48FCA13C96EA01BEEC816ABD3085AA3D101AAF3C84899C3DF2D79C3D8F2A89BDB84B06BE4C6BEBBD68FAE5BD0A110CBEF77799BDD0D2DBBDEA4E4EBD347D6F3D7028153C3640893DDA2FB63D80BEADBD3C37D1BDA8D0003EB65EC6BDF6F6873D428A61BD084C833D48E2BCBD573E11BEB421423DE0E3FE3C8C91B33D4A0A003E80F6433C7AE8033EB8DFEDBDEC45EF3D883C213D84357D3D081318BE2A24A3BD28D6E93D756DC3BDD2B3F1BDAC000D3D90C8FE3DDA97DEBD6D2BA7BD14CDEC3D26203EBD9F77B4BDDC41EDBD74AE1D3D42A2B9BD66F2AC3DCCD0F9BD4079A33C706EDD3DEB25F0BD5EA1ACBD4421E43D58A2123D909905BD2410773DA8C56E3DB0DE99BDEA648FBDFF1AE1BDBA9A08BEF0F9C83D4B5D8CBDA2D393BD1CFEEC3D5CFC2C3D78D908BDDC5CF43D68B2B8BC549B30BDC5D4FFBDAA84143E169316BE14A7E53D105C223DA586DCBD2896DEBD7622143EC76B08BEA2770A3E8E8B4EBD668F00BD2E1DC43D2B919DBD02D0903D2060093CA8D18BBD6878803CC4FDE6BCD655133ED881A3BC003D853D6C0DA4BDF0B195BC84FC023E0005AB3B7CBF093ED0AF783D302216BEFD7286BD70E8873C76025FBD484494BCD2A45FBD00AFBCBB0018D43C88DA293D80CBDABBF609BC3D200E7EBCE8102F3D2A65AFBDEA6708BD524915BD4406133DE096ADBB5F7D18BEF19A14BEC4EA063EDABB153E7C5BD23D90B9CB3DB84AC43C34D5013E700C76BDE2F0F4BD3A6A79BD8A6AFDBD7037953CD04EFD3D16729B3D4429FE3D1857F4BD809625BDCE83A53D4621ECBD30E91B3CC0F535BBBE7E973DC4ADA2BD2C9F153D8A7BB13D72340F3ECAD7DBBD42CC67BD0EEE02BE7279053EAA1E10BE8C1715BE0CAFF5BC6A940BBD6225C5BD3BC50DBEC28003BEE89AEA3DD1FF15BEB070863CD4E00DBEE4FED43D9CFE2DBDF85B883D67E5D6BD4EF02CBDCC15123E0208A93D1069CFBCE073C93D347E6C3D003D79BA7067043E3670B33D6710DFBD1C00043E4206BE3D88B7A63C5C790C3ED0B8213CFB26E0BD627C25BD50096C3CA033BCBCB4B0C73D28A3EC3D009CE63D68979DBD811507BEB063853D724200BEA0F6143D83A3C7BD88510BBE083E17BEAF79FABDB8A7113DE401A5BD8B689EBD9246F7BDE2ECB0BDD8E0AB3C9A3C2CBDE07000BE10BBA73C804EBA3AB0AE043E5098D43D8972C7BDE09ABD3CA034143EA435D83D655996BDD98DFABDA49B08BEC646B03D04C3BA3DD0858ABCDCB815BE15F414BEE8F5313D3055073C24C008BD82F8A43D7046023DC45B193E83D290BD705B2F3C64EF14BE40E6E63C805EB53A685C573DC0A6073BF07578BC9C2A22BD004D5C3A90E944BC6434D73DDC54293D2C7B133EE8210CBEE4D26EBDC825183EA22505BEB0BE113C1C58263D20CE063EB8722F3DF20DD1BD6C3E0C3D72CCACBD4001C03DF047073D74F7943D562351BDDA1432BDB62536BD58A347BDA0C6963B9E9DA43D8887A13D40FE27BBD46CADBD3CD8813D765148BD0418163E00046D3C18992CBD48169EBC96628B3DD0833A3C5CCD0B3EA8D215BE9BE386BD4081DA3BEC620DBEB0CB0E3EDC5AD9BCD31E03BEEAC7023E3856E83DD01B90BC085BEABDE225A53D502B3A3C2098873BC060403D820A9D3D105333BC9ADC153E1405E13D7DE6ACBD7067F93C20F546BCC04445BB480AA4BC20614DBC20D61EBCD2DA043E6666BCBD2F5388BD3606D7BDC87C95BD4C70193D70EA103C64DF803DE4CF2ABDC893CBBCE49FFC3D269161BD5E05BE3D7098803D34F44D3DD06DA43D361FC1BDF9F0E9BDE835F13CF02A123C746E7B3DC01205BD5433173E0037FBBA475ACEBDAE7F55BD904A0B3E807300BB1879BFBD04349ABD80A0C33CACB4413D0AB365BD20F0063D3096763D50321D3D2EFC42BD4B8EF7BDD1BAA7BDF48B5F3D7EDF2ABD006C7CBA9C8F51BD701C6EBD2853F33DCC7459BD2069BABBA01004BC68729B3DB85281BDDC33FF3D5871193DB06250BC388C703DB0E882BC4016243C266471BDE08BFF3BED0001BE50FF3E3C4EDE843DF42AD63DA08736BD9A33163EA0F915BE2C93E43DA063B33D1CD9ACBDF059103E524AAA3D12B9D1BD9E02043E4C1D8D3D6894DF3D20749ABC0058C7BD20CD073D18E6E6BC485639BD64AF4E3DC2338BBD15FE06BEA0DBBEBC5214003E1AB9023E08F1F33CF4BD00BEF2C2A03DEC29E73D8D84D1BDE3A3B3BD40412BBCAC46FA3D1018ECBCC0619ABBC568D8BD448382BDD24A44BDA471943D14CC01BEA04B61BCB080AB3D483FB0BC4E704CBDB652E5BD882B1F3D6BE3C0BD94E02D3DA8B9D2BD50B1CD3CAC275EBDB88F963D5BF30EBEB3FDD9BD50FFAE3C50D0C7BCF039DD3C206FCF3DB2120FBE52E3083E692B02BECCB741BD9CD006BDBA72EEBDD56885BD486CE73D9848D23C346F06BEC20816BECE4E8DBD0C5ADF3D47FF8ABD7A879A3D3A2E48BD80C7ACBC9C3C0CBE7AAB803D692C11BE466B8ABD2E0522BDA4F60A3DA81691BD5E66873DECBB393D5B7CD2BDA82E17BE5069FA3D80CA2BBBF81BCDBC3C9B763D6DF30BBE10AB0DBD368A003E26FBB03D30483FBC56AFBA3DEC390DBD48AA163D4EF119BDF896923DF916F8BD20A9F23D2CA6493DAA90F4BDD4F55CBD5C95023DEC83E1BDC56816BEEAA3053EA2771EBDDCB1783D24C6E03D53CEAABD48A633BD3C7567BD00F34E3A0091D13DBC8226BDC0460FBBFE73073E207DC03C4C6EAD3DB626CABD4EC6063E6854AB3C840BF7BCCC16063DEF5C9EBDD8B616BE18DFCF3D282EC23D04ACE83DAC3EEF3DFC1EDE3DD1F695BDD431B73D2A30843D124AF3BDB23D59BD605E073EE619133EB497913D30F767BDA2A9083EF2EEE3BDA48A463D88D842BD8424F93D68820BBE228D9B3D998087BD221BC73D20EB8E3C1C65B9BD2029483C706F85BC6F4883BDF4C1153E2CEA03BD2069D43D20BDD13D5B5895BD004F0C3B2E230F3EFC0314BD6EA5023E869FFBBD08B9FCBC96C8FBBD90B3333CE0BB883C00611FBA06268DBD68F7533D309F453C8CA7A43DAAD7003E54D5E13DCC340E3E6439CDBD8690CCBD00C7143EFEBDB53D54F224BD2607DFBD9477E83D98F7CABCC0694E3B2CFE6B3DA6A98ABDCA22A23D401C0BBCBC36C4BD20AE003EC59DD3BD247831BD00BC55BA77DA06BED0F1353DFCA0FCBC94A09A3DD444AE3DE8602C3D409FC4BBAE4F30BD2B8FAEBD5E006BBD4E8413BE74FF0DBEC4E4DF3DF09356BDA825A33D806A8ABBE8CBF03D28DEDC3D40B29DBC3B64D0BDFCCF1B3D6C89203DB83B003D78DDF63D1CBF92BD2021373C3088783C894819BE68989D3D689F703D47E28CBD50B0E33C401AA93C70DE5B3C01BDBBBD061D5DBD009BA43DA8A200BD393AF4BD9BFBCFBD46DABFBD44DF953DD529ABBD00B620BCBC38A93D38AB353D9CB88ABDD8E1E2BDE831323D904010BE32D3133ECAB5C83DA099523DE03A9EBBE039DC3C662016BE5E3D0B3EF2C5F0BDAC93D4BD503D7FBDCAFBBB3DF3F68BBDEE9022BD3435693D803EE03A36DC74BD9601913D186D033E2F1AB0BD30F0473D414BF2BDE008FF3C002B83BDE39312BEDFFDAABD74A4F93D719A9EBDE2026EBD0855BBBC8828D93DC832073E970A0EBE06950F3E559E06BE6C72E0BC10F95F3C7538EEBD60DDE4BB0053C03B1552B2BDF2A2A1BDC887D1BC14F3CA3D74EB3D3DC0240D3E309C6F3D84B571BD819D0CBEA8126DBDD0E4FB3D38DBC43C6685D2BDEC73E13DD822F7BDC08866BB9748C9BDEFF0FCBDF62E04BD60A3493C20A55CBC34950FBEC422993DEC8F0F3E6878133ED831973CC8088FBD0044A63BC006993BEB1B0EBEA897693D10A59EBC88C398BCA872FF3C8840D23DDA2985BDD818923D9C9BC33D24B1E43D9C5AA5BDC034F63D2CE0BDBD68F9A63C7CF0433DD566A1BDC0AF02BB1B3989BDA8F0173DA6C4C13D2EDD06BE2827BC3D9C1A843D8278C8BD8E2D12BD50CC06BE4F4C9DBD965D78BD6287083ECEEDB9BD6E1FC6BD923450BD27FBA9BD601AF33B8894C8BD50743F3CA0D887BC00AC323C1068F23D8765A8BD523C0EBDE0D400BE8AEF923D40F3923D0C05313D80690E3E8872ED3D92E4163EA8A7D0BD0CB6DF3D6056F73CB000B83D7827CABC30BCE7BDBC84E53D8A9BC53DC48FF5BC6C82EFBD895BFBBDE0C792BB315FDFBD7081CC3C11E20ABEA0EA5D3DA4D8F23D1C8037BD046EB43D307CC8BDECE0ED3D2461FE3D4BF783BDFAFF8D3D547F133D3FE9AFBDE84EFD3D52EE043E4CAADD3D67A186BD6291093E947290BD985EEE3CA45F5EBD98E0093E16DCD3BDE040FA3B7C85793DE09AC73C08F24C3D3F7319BEC0CF6F3D206EDABDF8D2243DA807253D849F103DC03A9B3CD46E093D28E4EA3C04F7FA3DBAAD01BEB0F1F33D0DF806BE3A51D6BD40D656BC0293F9BDCA09A7BD0A9C093E6E0D153EF4ADFA3D009F703D488A8DBC9F848BBD4099C23D5A73F1BDC9A9E3BD14470EBE9197EEBDFFC60EBE59319FBD5A9D983D1C33EE3DA4F974BD56B414BD46B3F2BD202A7D3D38A5A73D4C4014BE685EA4BC78CA013EB4881E3D7A50B1BDF047C7BC765423BD04E1D63DA06101BD543AAF3D3ACE023EA0272B3D0A61BABD1443E33D64E5773D8A817ABD08D1F53CA06C23BD780C10BE2055CDBBA64C5EBDD7D3B0BD00EDEC3C004C05BC80600F3EC0CCE53B7B5A93BD90EDD93C9C03DD3DCEE986BD2029D03BF9980CBE7C97EBBDBE38BFBD8C50913D0EC6903D0035013AE4B804BEDCA5383D303B2DBC260DFFBDFC710C3DFFE1EBBD80DDCF3DB0D7E33DBA2F29BD33D7BCBDD2D7A73D1044EDBD749CE53D36C913BEC2974ABD584C72BDA88CB53DA6CFC9BD3CB3FBBCA4D212BE7E9911BEA0EB6ABC42D7033EB064FB3CA89B6B3D58ADA8BD00AE673D00773FBB638085BD686C153E5E1345BDCCD6943D07C606BEC8E3103D554B8BBDD0D6F9BD76F318BE4469ED3DEE1012BEB417D73DCEF8A43DA833AF3DA839983C308BB5BD6236B53D1EB4C9BDACC6D8BD40A5C2BBE87609BEFC1ED33DA063B4BC60A2303D3011C93DFEB213BD4C5C183DB04C00BEC4702E3D8F1F8CBDB08E83BDC0D701BE6834C93D22C4133E28378F3D60DAFABDB814B0BD4C6CECBD2C239D3DF83559BDE01885BB3E8F9C3D63EA14BEE346EBBD30DF0CBEB667A63DAB2DB0BD4893E93CF250FBBD7693183E827E4CBD4AD42FBD14B7E9BC5C83103E3AA0E0BD009C0DBB449C6A3D606B353D0FB5F8BD59FF03BEA79795BD00BF053ED84802BD8056113C50736E3D36CA0F3E6058203C80B6883B3CE64E3DD099C2BDE6A807BE1C41F7BC1A98F1BDFE7BD8BD8A8AECBDB081953C625F19BE3B9BA6BDD49A3EBD40E1DF3C5059AFBC8C83113E589D0CBEB46DF9BC580774BD88B15A3DEBCBA3BD0A1A09BE206B9B3C4D87F6BD7B1987BD80E7613D70B7E73DF0065FBCC039A53CAC4F333DA05ED93CD4EA43BDDEC6DCBDECC0A7BD98DF093E70EE12BE004764BB347F083EEA6AD6BD90AB64BD5878D53D60378C3DC011E73D286DD13CBC952ABD6057933CBEAD11BE24204C3DBC3555BD2C4C253DF02BF33DC69CC03D4CDC1ABD78A1E23DC00D06BE2057EEBC60CA02BCAB3019BE4F8D07BE0A3260BDA05D3A3C42DA073E58E0F13C600DF03C894AE7BD00748C3AF491143EBA121FBDA0CFE2BD6887283DB2A517BE67CBBCBD28C20ABE5C2C1F3DC50298BD2C14C13D56A2103E76EBB63DF459AFBDD4160ABE002460BC809664BBEC42703DE08F403C6167A2BD68AE653DA6208A3DD65A4BBD6860763D340E943DC08F03BCFCD9113E0014733C41BCABBDEC4C09BEE34CF8BD40ABB8BCC06F18BD600EE93CA839BABDF024FA3C045E583DBC768D3DCE93B13DAC6D023DFABEA63D5E4F11BECCB1D53D68ED88BD14B0A9BD3A2217BE2084E43C213789BD6084EBBB5E05BE3D64F39E3D419AF4BD42A80B3E2442E3BDD24B813D002531BB782181BC3B6FA8BDDC47FE3DE0A4433D42C100BE202A0A3C6496013E9001703D32CE09BE2E769BBD880889BC02BB9F3D8E970E3EF4B94E3D969F03BD32BBAA3D782D033D909315BE9C3FC4BDB9A981BD4AB5A4BDD009933C9676963D61F302BE8AF64FBD7849E13D7C71E7BD9CAD84BDD8CAE5BDDE8CF2BD7034F83D09CAC0BD0072F9BB58E7A6BD00C283BCD4EE06BEF0600F3CB7D0D8BDB847A23D7432A53D2009A6BC43489EBDD44D473D40AEEDBB1CE6193E18D02B3DE459A53D350099BD9003BF3D521500BEF0F94DBCC442003EDE56EBBD00600EBB52B68FBD1C89523DCF3413BE5457E33D30EA0ABE48C208BEE82B1A3D0C3A643D4856D83D10F329BCC679E6BD087BC43DB6C1933DF170B8BDE63F043E9771C6BD90D1CCBCECCD4CBD17BD91BDAE4E72BDC0B5EE3D682C9E3D285ADD3D7463B03DE8EFFC3DAD0E03BE18BCF03DBC460B3EC639133E5867173E28D6C43D86E11FBD98A88C3C53CFE3BD244BE23D44550EBD6E939D3D48290B3E20F964BD68A019BEA004113C92C101BE93B3AFBDCE9343BDC4C01F3D2815D8BDF81CF03D42CCAB3D10DC113C322619BD769E0CBD50F3B43C3E4E19BEA01F78BDA8F6E83D686C3F3D30A8FA3D9C7AE6BCEAF68D3D28C7EA3D801A473BBF0E13BE80AF853C9C11E1BC80A60D3ED086673CC0AB83BB260DE2BDBAA2903D94D9A2BD169E85BDD446273D9024F1BC00AD75BCFA7BA93D00359F3ABCAE13BDA418113E5913CFBDF8D896BCD24F153E4C103DBD06407BBD52F477BD209816BEF83AD0BC8072133E568E143EF79297BDF4AA163D70DF813CB0E83FBC60F811BE3455D43D748B493D0C5C3B3D686F98BC2BE197BD9E7AC7BDF8DCEF3D6DAAB3BDF00BBA3CC403783D7CB7CEBDEC85F5BD10D588BD005F073AEAB962BD44DCFD3D18BEDD3D22C8153E9279AD3DF7D391BD7CF2123EDCBE0F3D047858BD7A2C5BBDB8196C3D109CA3BC5491123E302626BC72060FBE084D173EA424163E10B568BDD075023D9C8D27BD58D1B1BC60857FBDE0F4B3BBF00A68BDF404733DF023493C137CF9BD4A100C3ED862F43C287C80BDC840FDBD3CDB97BDA951FCBDF0ACCA3D085077BD30A03F3C40632EBC8ED0C83D207674BCB87811BD95F817BE0852963C9CDCE4BDDFFE01BE0664843D809B97BADCA997BD6E5E01BED0610F3E005D003D0DABBEBDC045E5BBED908BBD388D833DDCF9B6BDBD10CABDC6DD9D3DFD4BAFBDD7E10ABE22E00C3E5839E73DA45B633DE86D97BC9EB0913DA8D2073E5BF213BE6805063E08C3913C3CD60A3DCA8461BD64288A3D4087BCBBC07E303B16C092BD58F30B3EC8248F3D86E376BD50213C3C4C4A73BD7494B53D8E66AC3D1BC1CBBDA098883BC757EEBD30F3B63C88CCBFBC6223A83D625FD8BDD005B3BCB4623C3D40E3133C028100BE56B603BEBAC89F3DBA2D0F3E48D18E3C2231C0BD622B863D167305BD0801BB3D081F123E4050283C6E6270BD34274B3D4472163D0CA6D5BD78D2D83D2E56C9BDF29ED6BD30ED013DA60BC93DB05A7F3CD87BB33C0A16FDBD6043F13BF81DAEBD5070A23D202A073DDF5B0DBE7814B1BC4C98723DCCE8B2BD33318EBD3C4607BE04EAE1BC85F709BE92FB47BDB09EE73D7EDB8A3D7A3B0FBD0E1EA0BD78FF843D6B8D01BEA227033E6098FE3DD44A22BD26310FBE450809BE808A8A3BFC39ECBC907339BD2424983DE07D283DC2B324BD8053E23DF021E13DA06585BC3EAAD1BD684AB93D4EAEBABDAA4D9CBD59EC00BEBA14C73D0C84383DCF1C84BD6360A1BD448718BD08CB623DDD3BE2BD80A8673D18C6903D00BAEA3B0BB1D1BD088D183D260D943D5863083EB3F113BEE1FD17BEC624943D4AA2ACBD7884A8BDECF1B53D8030F1BAC22AA2BD80F0C1BD9A9004BEB763D6BD644E083DC045EB3C6C5F7F3D624B163E665E55BD4CA4443D188A8F3C9570E7BDA6214EBD3442C93D3C6DDA3D57AC92BD7246093E8FBA12BEAC1DF3BDB8C4B43D98FBFB3C8E5CDFBD51EA02BE20AFF53C44481E3DD4D4783D4827403D5874CCBC70FDE33C74E1FE3D582B7F3D848652BD70535A3C61EB02BECBDC10BE581B023EE6AD003EAA78A33D3AF402BEDEBB053E5EB208BE1F920ABE407AF33B6EB608BEB00A223D572A16BE40FD3EBCCD3208BE9265C63DEAE9DBBDD02B3FBD48DD91BCA47EF03D9AE752BDA825193E14FC513DC86CBB3DB230BF3D3A2F0B3E406D5A3C54F20D3E8095C8BC3EFD19BE2801F43C88DD6BBD30F76BBC4C4509BD9484FD3DB8FE753D0E05883DD875CD3D603ABDBD90660E3E4B091ABEA86EB6BDF01C3B3C4C82583DFECAA23D9AAD923D4C1C02BEDC8A163E5BB705BEE4E7163D781DECBD0275AB3D9C59363D8FA2D5BDC8B4143E0DFBFABD5FC382BDF8E0B0BC16A4003E80DF133CF664193EB803F83C983C7D3D9043023D84B2703D822C123E4083A13D408E84BB3896F23D6E85943D0894E0BD9479043ECCB0123E767AC33DD61226BD6C52043D498EA7BD8A06193E0296F1BD7EE075BD948C573DD0AD983CA438B43DCC10A63D7C68B03D4824C7BC952D84BDA0DEAABBF20155BD2624A63DEE1A0E3E3468CB3D68FD743D4EAB0B3E1C55F93D85DA01BE124BE2BDA0A3B6BBF03E02BCCCB918BE508C4F3CFA55C2BD1080403D007C7F3CB658133E54DD053D0FEEA1BD5897E13D6072DC3DE0CDEF3BA26B74BD748232BD867BBD3DE2FB80BD0393D5BD20EF31BCAA3011BD00F493BA6ECE92BD121C153EF471053DA8C2643D246DF23D62024BBD54E27E3D201FE33DA8EB283DC63AB43DC8789CBD4865C5BD5C3ECBBDFC95E83DE8C2B33DFA32B5BD10450F3CB064343CFA4A083EC030283C049D563DE843BBBDB0A84EBD4CE63DBD8CE743BD64B616BE18834D3D5CB3183D34EFE73D447DE53D6884C33D2822F93C846F07BE313DCABD0078C3BB00739C3B90FB6CBC3E2AA83D82BA113E1F048CBDB85E7C3D36B99CBDD4E63FBD1A9F053E034CFEBDC60CEEBDC0682BBB38E2BA3D5C7B023EA4CFF53D4E62053E007E953AFBCC00BEA4AEB03D00F8B538C0A9A33D33C4D6BD004E6C3BE049C13DF03F273D14BBC23DBB9DC0BD742615BDE8A994BC4293923D38011E3D5814123D6C85913D46F7AA3D8614033EACB0FBBC2099B3BBB83EF53CD189C2BD9B5BE6BDAAE0A2BDA0DD053C8C03FB3D206C263D4A7103BE3B5C0DBE3EADA63D100B90BC6E4B063ED29E8FBD5188AABDF4CCDBBC0A81D6BD4AA617BE464112BEA8F71A3DB08B653DA59891BD9A12133E34AC663D48528A3D1040C53CC05DA7BC005694BC4078B73B3DDEAFBDAE7E923D6F4AB4BDDABE8B3DC3E58BBD80D1FD3C382CC63C5F579CBDABE7EBBD7077FD3CB07863BCDCEE17BEA64A163E7474BC3D307FC13D323DBA3D00AD163EFC5ECCBD0D12F6BD2E43AB3D2EFCDDBD03EEE8BDCAEB033EEA5AF1BD2836083E0078D7BC94E9993D209AD03DE837D8BCB7090BBEDAF6143E4AAACEBD1E650A3E98DC86BDF6DD14BE3884A1BC55E9A1BD4890613D9CAF583D5C60FE3D9CE4263D889DC3BD08A95BBD106D04BC1E54CFBDD2845DBD4D1810BE78791D3D20C217BE0CE3953D84680E3E79CDD7BDF4121ABEDC55E6BD48AA083EC0D065BBF70F03BE3C0DF3BCC851D1BD5E475CBD58149D3D60D4893CF1A4F5BDAE3DC93D52B1BD3D60D19CBBBE420E3EB4FF41BD104A03BEF0B0383DB43331BDCAF2AABD9D8F85BD48AEC33D28F526BD783FD3BDE89F0F3E88B9F93C8461D13D7671AC3DAA3D2EBDA489F73D804109BC568FB7BDE87B5EBD7D6BACBD5179E2BD761D873D47A40ABEA0B5E5BBA4ACD43D80EDA63C30EA333DB513F5BDD0B4A1BD9003223DB895C73D94BD233D26599E3DE8A1F53D3203953D484D363DAEA38E3D0E3BAABDAC20FE3DC0519DBBE6520ABE2859B9BCEC568B3DA285183E4F9516BEF055B73CF8C3BDBC86BD023E3CB7B9BD000C66B9B8EC023D0C84F23D1844023E577302BEF59708BE38FB103E60E636BD422FE4BD24CC133EC2AC9C3D1CEF753DA4AFCF3DB6270C3EC619BDBD986522BD74B0213D6871B6BDCC810E3E7CEEF2BCFEE381BDACFCDEBD483E9A3D322D023EA978A2BDD052793C182BDD3D181BD53CE093CC3B38608F3DBECE13BE8887B7BC7886FF3CDA779A3D867984BDB1E408BE2033DC3B80700DBC9EAA18BEF39C0BBEF8FE563D00607E3D72E9EDBD5032043E65C514BE44EA0BBD64AAAC3D00DCF6395841E0BC1B258FBD6E03C7BD84CD233DCA8273BD5EE1F1BD4858FF3D504BF53D1029F23C20B09B3D22370C3EC8E9163E1C36003D9812FD3DE8DDE0BCD0376EBC1B1297BD54D660BDC3F5CEBDC36406BE3C1A233D5CBC1B3D3F7E9BBD14EEC73D4ADFA43DF0E1743C286815BE907A68BCB48E01BD9829BCBCAD4D8FBD082FED3D44BFF43D045A303DD61F933D0821DA3C0000AAB67C0FE53D484D343D70DA0E3EBC59213DD2CF923D18E1FE3CF4A7753D4047F23B48CFC33DE08C9DBB47F58EBDB64926BDF858E33DB40BF9BD183B85BD46AAA13DBE382DBD7B0E89BDD83C923CC4BB313DE421CD3DF62C063E8C46D73D08FAD23C5CE9C23DCC04663DBA235BBDF8CDFDBCA072F5BB744A98BD42E597BDD64705BE00994B3B2D1E12BE6C91973D1EE9F3BD603C30BC56659C3D6428A5BD22ED4EBDA034463D2646013E20DBAE3CA028DA3D33D8A1BD128510BE10D52E3DB079BFBC09239BBDC0F3E23B4BB191BD7023133D685804BED4D0D23D5ADFBA3D18E5F63D28714FBD18A63A3DDA88C83DF57593BDA681EEBD4039F9BB6137FEBD8071473CC4E7DBBDA89FAA3C90C03A3C2415FC3D7096A63CFCA0963D70B4143EA86746BD4EF9F5BDCEFE0BBDA0DB203D54AD83BD801EF7BBB7AC0DBE60C486BCC880843DD8B1193EA07EB7BC8A945FBD90B9CF3C683BAE3D5A1ABABD60B6A13D6041923C904B163EACC7DBBC60D2A2BC0409123EB0E0413DE94A16BEB40F103D3A2E0C3E45E303BE429007BEFC28753DCCA1B33D783A08BEF712E8BD46B827BD96AFB13D746C533D2C8A063D78D6093E643CDC3DE03C46BC4014843C1D9CB8BD797600BE9C02C33D7EF757BD6828D6BCC47A01BDA441E53DD0118EBC640A1DBDD4B2163DA07AE13D3CF37D3D3AE490BD0E44BABD60DC2C3CC66E03BEAAD079BD8DF983BDB65F103E88F4B3BC4082743B34900C3E08EED2BC1AD2DDBD04E8E83D208EDD3CC0B129BB">
  memref.global "private" constant @__constant_1x8x4xf32 : memref<1x8x4xf32> = dense<[[[-0.431032777, 0.339656174, -0.0172508955, 0.530783117], [-0.131361604, -0.686532557, 0.29633683, -0.190197289], [0.114347279, 0.56687206, -0.5206815, 0.0635936856], [0.278496087, -0.701272607, -0.192214727, 0.0925094485], [-0.263988972, 0.210848868, 0.702368438, -0.632420897], [0.552770555, -0.32865116, -0.0839602351, 0.335239589], [-0.466998219, -0.367347717, 0.669422566, 0.683026611], [-0.653910696, -0.016515851, 0.00850236415, 0.640155136]]]>
  memref.global "private" constant @__constant_1x4x2xf32 : memref<1x4x2xf32> = dense<[[[-0.649729251, -0.36405158], [0.711094856, -0.165482044], [-0.528160095, -0.548771381], [0.198056698, 0.657765388]]]>
  func @main(%arg0: memref<4x32x32x1xf32>, %arg1: memref<4x2xf32>) attributes {tf.entry_function = {control_outputs = "", inputs = "x1", outputs = "Identity"}} {
    %cst = arith.constant 0.000000e+00 : f32
    %cst_0 = arith.constant 3.40282347E+38 : f32
    %cst_1 = arith.constant 1.000000e+00 : f32
    %0 = memref.alloc() {alignment = 128 : i64} : memref<4x35x35x1xf32>
    %1 = memref.get_global @__constant_2xf32 : memref<2xf32>
    %2 = memref.get_global @__constant_4xf32 : memref<4xf32>
    %3 = memref.get_global @__constant_8xf32 : memref<8xf32>
    %4 = memref.get_global @__constant_1xf32 : memref<1xf32>
    %5 = memref.get_global @__constant_1x5x5x1xf32 : memref<1x5x5x1xf32>
    %6 = memref.get_global @__constant_1x256x8xf32 : memref<1x256x8xf32>
    %7 = memref.get_global @__constant_1x8x4xf32 : memref<1x8x4xf32>
    %8 = memref.get_global @__constant_1x4x2xf32 : memref<1x4x2xf32>
    %9 = memref.alloc() : memref<4x35x35x1xf32>
    linalg.fill(%cst, %9) : f32, memref<4x35x35x1xf32> 
    memref.copy %9, %0 : memref<4x35x35x1xf32> to memref<4x35x35x1xf32>
    memref.dealloc %9 : memref<4x35x35x1xf32>
    %10 = memref.subview %0[0, 1, 1, 0] [4, 32, 32, 1] [1, 1, 1, 1] : memref<4x35x35x1xf32> to memref<4x32x32x1xf32, #map0>
    memref.copy %arg0, %10 : memref<4x32x32x1xf32> to memref<4x32x32x1xf32, #map0>
    %11 = memref.alloc() : memref<5x5x1x1xf32>
    linalg.generic {indexing_maps = [#map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%5 : memref<1x5x5x1xf32>) outs(%11 : memref<5x5x1x1xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      linalg.yield %arg2 : f32
    }
    %12 = memref.alloc() : memref<4x16x16x1xf32>
    linalg.fill(%cst, %12) : f32, memref<4x16x16x1xf32> 
    %13 = memref.alloc() : memref<4x16x16x1xf32>
    memref.copy %12, %13 : memref<4x16x16x1xf32> to memref<4x16x16x1xf32>
    memref.dealloc %12 : memref<4x16x16x1xf32>
    linalg.conv_2d_nhwc_hwcf {dilations = dense<1> : tensor<2xi64>, strides = dense<2> : tensor<2xi64>} ins(%0, %11 : memref<4x35x35x1xf32>, memref<5x5x1x1xf32>) outs(%13 : memref<4x16x16x1xf32>)
    memref.dealloc %11 : memref<5x5x1x1xf32>
    memref.dealloc %0 : memref<4x35x35x1xf32>
    %14 = memref.alloc() : memref<4x16x16x1xf32>
    linalg.generic {indexing_maps = [#map3, #map2, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%4, %13 : memref<1xf32>, memref<4x16x16x1xf32>) outs(%14 : memref<4x16x16x1xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %13 : memref<4x16x16x1xf32>
    %15 = memref.alloc() : memref<4x16x16x1xf32>
    linalg.generic {indexing_maps = [#map2, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%14 : memref<4x16x16x1xf32>) outs(%15 : memref<4x16x16x1xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.cmpf olt, %arg2, %cst : f32
      %42 = arith.select %41, %cst, %arg2 : f32
      %43 = arith.cmpf olt, %cst_0, %arg2 : f32
      %44 = arith.select %43, %cst_0, %42 : f32
      linalg.yield %44 : f32
    }
    memref.dealloc %14 : memref<4x16x16x1xf32>
    %16 = memref.collapse_shape %15 [[0], [1, 2, 3]] : memref<4x16x16x1xf32> into memref<4x256xf32>
    %17 = memref.expand_shape %16 [[0, 1], [2]] : memref<4x256xf32> into memref<1x4x256xf32>
    %18 = memref.alloc() : memref<1x4x8xf32>
    linalg.fill(%cst, %18) : f32, memref<1x4x8xf32> 
    %19 = memref.alloc() : memref<1x4x8xf32>
    memref.copy %18, %19 : memref<1x4x8xf32> to memref<1x4x8xf32>
    memref.dealloc %18 : memref<1x4x8xf32>
    linalg.batch_matmul ins(%17, %6 : memref<1x4x256xf32>, memref<1x256x8xf32>) outs(%19 : memref<1x4x8xf32>)
    memref.dealloc %15 : memref<4x16x16x1xf32>
    %20 = memref.collapse_shape %19 [[0, 1], [2]] : memref<1x4x8xf32> into memref<4x8xf32>
    %21 = memref.alloc() : memref<4x8xf32>
    linalg.generic {indexing_maps = [#map4, #map5, #map4], iterator_types = ["parallel", "parallel"]} ins(%20, %3 : memref<4x8xf32>, memref<8xf32>) outs(%21 : memref<4x8xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %19 : memref<1x4x8xf32>
    %22 = memref.alloc() : memref<4x8xf32>
    linalg.generic {indexing_maps = [#map4, #map4], iterator_types = ["parallel", "parallel"]} ins(%21 : memref<4x8xf32>) outs(%22 : memref<4x8xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.cmpf olt, %arg2, %cst : f32
      %42 = arith.select %41, %cst, %arg2 : f32
      %43 = arith.cmpf olt, %cst_0, %arg2 : f32
      %44 = arith.select %43, %cst_0, %42 : f32
      linalg.yield %44 : f32
    }
    memref.dealloc %21 : memref<4x8xf32>
    %23 = memref.expand_shape %22 [[0, 1], [2]] : memref<4x8xf32> into memref<1x4x8xf32>
    %24 = memref.alloc() : memref<1x4x4xf32>
    linalg.fill(%cst, %24) : f32, memref<1x4x4xf32> 
    %25 = memref.alloc() : memref<1x4x4xf32>
    memref.copy %24, %25 : memref<1x4x4xf32> to memref<1x4x4xf32>
    memref.dealloc %24 : memref<1x4x4xf32>
    soda.launch_func  @main_kernel::@main_kernel args(%23 : memref<1x4x8xf32>, %7 : memref<1x8x4xf32>, %25 : memref<1x4x4xf32>)
    memref.dealloc %22 : memref<4x8xf32>
    %26 = memref.collapse_shape %25 [[0, 1], [2]] : memref<1x4x4xf32> into memref<4x4xf32>
    %27 = memref.alloc() : memref<4x4xf32>
    linalg.generic {indexing_maps = [#map4, #map5, #map4], iterator_types = ["parallel", "parallel"]} ins(%26, %2 : memref<4x4xf32>, memref<4xf32>) outs(%27 : memref<4x4xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %25 : memref<1x4x4xf32>
    %28 = memref.alloc() : memref<4x4xf32>
    linalg.generic {indexing_maps = [#map4, #map4], iterator_types = ["parallel", "parallel"]} ins(%27 : memref<4x4xf32>) outs(%28 : memref<4x4xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.cmpf olt, %arg2, %cst : f32
      %42 = arith.select %41, %cst, %arg2 : f32
      %43 = arith.cmpf olt, %cst_0, %arg2 : f32
      %44 = arith.select %43, %cst_0, %42 : f32
      linalg.yield %44 : f32
    }
    memref.dealloc %27 : memref<4x4xf32>
    %29 = memref.expand_shape %28 [[0, 1], [2]] : memref<4x4xf32> into memref<1x4x4xf32>
    %30 = memref.alloc() : memref<1x4x2xf32>
    linalg.fill(%cst, %30) : f32, memref<1x4x2xf32> 
    %31 = memref.alloc() : memref<1x4x2xf32>
    memref.copy %30, %31 : memref<1x4x2xf32> to memref<1x4x2xf32>
    memref.dealloc %30 : memref<1x4x2xf32>
    linalg.batch_matmul ins(%29, %8 : memref<1x4x4xf32>, memref<1x4x2xf32>) outs(%31 : memref<1x4x2xf32>)
    memref.dealloc %28 : memref<4x4xf32>
    %32 = memref.collapse_shape %31 [[0, 1], [2]] : memref<1x4x2xf32> into memref<4x2xf32>
    %33 = memref.alloc() : memref<4x2xf32>
    linalg.generic {indexing_maps = [#map4, #map5, #map4], iterator_types = ["parallel", "parallel"]} ins(%32, %1 : memref<4x2xf32>, memref<2xf32>) outs(%33 : memref<4x2xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %31 : memref<1x4x2xf32>
    %34 = memref.alloc() : memref<4x2xf32>
    linalg.generic {indexing_maps = [#map4, #map4], iterator_types = ["parallel", "parallel"]} ins(%33 : memref<4x2xf32>) outs(%34 : memref<4x2xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = math.exp %arg2 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %33 : memref<4x2xf32>
    %35 = memref.alloc() : memref<4xf32>
    linalg.fill(%cst, %35) : f32, memref<4xf32> 
    %36 = memref.alloc() : memref<4xf32>
    memref.copy %35, %36 : memref<4xf32> to memref<4xf32>
    memref.dealloc %35 : memref<4xf32>
    linalg.generic {indexing_maps = [#map4, #map6], iterator_types = ["parallel", "reduction"]} ins(%34 : memref<4x2xf32>) outs(%36 : memref<4xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    %37 = memref.expand_shape %36 [[0, 1]] : memref<4xf32> into memref<4x1xf32>
    %38 = memref.alloc() : memref<4x1xf32>
    linalg.generic {indexing_maps = [#map4, #map4], iterator_types = ["parallel", "parallel"]} ins(%37 : memref<4x1xf32>) outs(%38 : memref<4x1xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.divf %cst_1, %arg2 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %36 : memref<4xf32>
    %39 = memref.collapse_shape %38 [[0, 1]] : memref<4x1xf32> into memref<4xf32>
    %40 = memref.alloc() : memref<4x2xf32>
    linalg.generic {indexing_maps = [#map4, #map6, #map4], iterator_types = ["parallel", "parallel"]} ins(%34, %39 : memref<4x2xf32>, memref<4xf32>) outs(%40 : memref<4x2xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.mulf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %38 : memref<4x1xf32>
    memref.dealloc %34 : memref<4x2xf32>
    memref.copy %40, %arg1 : memref<4x2xf32> to memref<4x2xf32>
    return
  }
  soda.module @main_kernel {
    soda.func @main_kernel(%arg0: memref<1x4x8xf32>, %arg1: memref<1x8x4xf32>, %arg2: memref<1x4x4xf32>) kernel{
      cf.br ^bb1
    ^bb1:  // pred: ^bb0
      linalg.batch_matmul ins(%arg0, %arg1 : memref<1x4x8xf32>, memref<1x8x4xf32>) outs(%arg2 : memref<1x4x4xf32>)
      soda.return
    }
  }
}


// -----// IR Dump After TestArgumentsToXML //----- //
#map0 = affine_map<(d0, d1, d2, d3) -> (d0 * 1225 + d1 * 35 + d2 + d3 + 36)>
#map1 = affine_map<(d0, d1, d2, d3) -> (d3, d0, d1, d2)>
#map2 = affine_map<(d0, d1, d2, d3) -> (d0, d1, d2, d3)>
#map3 = affine_map<(d0, d1, d2, d3) -> (d3)>
#map4 = affine_map<(d0, d1) -> (d0, d1)>
#map5 = affine_map<(d0, d1) -> (d1)>
#map6 = affine_map<(d0, d1) -> (d0)>
module attributes {soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  memref.global "private" constant @__constant_2xf32 : memref<2xf32> = dense<0.000000e+00>
  memref.global "private" constant @__constant_4xf32 : memref<4xf32> = dense<0.000000e+00>
  memref.global "private" constant @__constant_8xf32 : memref<8xf32> = dense<0.000000e+00>
  memref.global "private" constant @__constant_1xf32 : memref<1xf32> = dense<0.000000e+00>
  memref.global "private" constant @__constant_1x5x5x1xf32 : memref<1x5x5x1xf32> = dense<[[[[-0.144123852], [-0.203296721], [0.0245194137], [0.0424404144], [-5.772960e-02]], [[0.213269472], [-0.00469377637], [0.345114052], [0.136302114], [-0.259548783]], [[0.145365268], [0.112524837], [0.0500608087], [-0.0937015414], [-0.0550665557]], [[0.0901061296], [0.286698043], [0.111992478], [0.231037259], [-0.28824234]], [[-0.15258716], [-0.335655361], [0.156836212], [0.183970571], [0.124615282]]]]>
  memref.global "private" constant @__constant_1x256x8xf32 : memref<1x256x8xf32> = dense<"0x28DF883CAB19ACBDE456E13DA638AB3DBC37333D00FD153C49EA15BEE0A3E63DC09215BC86E30BBDC072EE3DF0EE283D5CCB19BED4EADC3DF221F2BDFA0A0E3E9138B2BD7CB5483D5209EABDAA9FD8BDE465163EB4CED43DCC0707BEFCFC413DF01A3EBCE451153E74D2F03DB644A43D7CF99A3D04CD7BBD50874ABC64BC5C3D294196BDF4B1433D666CAF3D80D8163E8F47AFBDBAF214BE00B68DB95562F8BD70BA103E3442DC3DCC01DD3DD07A09BC603AF03B08BD673D18DAD13CC69C8A3D39200ABE0178A4BDD2C2163E05F2DBBDD816F03D84D2A53DCEC495BD0EC215BE4A58B63D0065FEBA9C647E3D80F409BC04A3953D7C3A57BD503D97BCDAA5ACBDB060103D5E5AD7BD12A32FBDFC49163EE095D73DC2260CBE9785E5BD645572BD48FCA13C96EA01BEEC816ABD3085AA3D101AAF3C84899C3DF2D79C3D8F2A89BDB84B06BE4C6BEBBD68FAE5BD0A110CBEF77799BDD0D2DBBDEA4E4EBD347D6F3D7028153C3640893DDA2FB63D80BEADBD3C37D1BDA8D0003EB65EC6BDF6F6873D428A61BD084C833D48E2BCBD573E11BEB421423DE0E3FE3C8C91B33D4A0A003E80F6433C7AE8033EB8DFEDBDEC45EF3D883C213D84357D3D081318BE2A24A3BD28D6E93D756DC3BDD2B3F1BDAC000D3D90C8FE3DDA97DEBD6D2BA7BD14CDEC3D26203EBD9F77B4BDDC41EDBD74AE1D3D42A2B9BD66F2AC3DCCD0F9BD4079A33C706EDD3DEB25F0BD5EA1ACBD4421E43D58A2123D909905BD2410773DA8C56E3DB0DE99BDEA648FBDFF1AE1BDBA9A08BEF0F9C83D4B5D8CBDA2D393BD1CFEEC3D5CFC2C3D78D908BDDC5CF43D68B2B8BC549B30BDC5D4FFBDAA84143E169316BE14A7E53D105C223DA586DCBD2896DEBD7622143EC76B08BEA2770A3E8E8B4EBD668F00BD2E1DC43D2B919DBD02D0903D2060093CA8D18BBD6878803CC4FDE6BCD655133ED881A3BC003D853D6C0DA4BDF0B195BC84FC023E0005AB3B7CBF093ED0AF783D302216BEFD7286BD70E8873C76025FBD484494BCD2A45FBD00AFBCBB0018D43C88DA293D80CBDABBF609BC3D200E7EBCE8102F3D2A65AFBDEA6708BD524915BD4406133DE096ADBB5F7D18BEF19A14BEC4EA063EDABB153E7C5BD23D90B9CB3DB84AC43C34D5013E700C76BDE2F0F4BD3A6A79BD8A6AFDBD7037953CD04EFD3D16729B3D4429FE3D1857F4BD809625BDCE83A53D4621ECBD30E91B3CC0F535BBBE7E973DC4ADA2BD2C9F153D8A7BB13D72340F3ECAD7DBBD42CC67BD0EEE02BE7279053EAA1E10BE8C1715BE0CAFF5BC6A940BBD6225C5BD3BC50DBEC28003BEE89AEA3DD1FF15BEB070863CD4E00DBEE4FED43D9CFE2DBDF85B883D67E5D6BD4EF02CBDCC15123E0208A93D1069CFBCE073C93D347E6C3D003D79BA7067043E3670B33D6710DFBD1C00043E4206BE3D88B7A63C5C790C3ED0B8213CFB26E0BD627C25BD50096C3CA033BCBCB4B0C73D28A3EC3D009CE63D68979DBD811507BEB063853D724200BEA0F6143D83A3C7BD88510BBE083E17BEAF79FABDB8A7113DE401A5BD8B689EBD9246F7BDE2ECB0BDD8E0AB3C9A3C2CBDE07000BE10BBA73C804EBA3AB0AE043E5098D43D8972C7BDE09ABD3CA034143EA435D83D655996BDD98DFABDA49B08BEC646B03D04C3BA3DD0858ABCDCB815BE15F414BEE8F5313D3055073C24C008BD82F8A43D7046023DC45B193E83D290BD705B2F3C64EF14BE40E6E63C805EB53A685C573DC0A6073BF07578BC9C2A22BD004D5C3A90E944BC6434D73DDC54293D2C7B133EE8210CBEE4D26EBDC825183EA22505BEB0BE113C1C58263D20CE063EB8722F3DF20DD1BD6C3E0C3D72CCACBD4001C03DF047073D74F7943D562351BDDA1432BDB62536BD58A347BDA0C6963B9E9DA43D8887A13D40FE27BBD46CADBD3CD8813D765148BD0418163E00046D3C18992CBD48169EBC96628B3DD0833A3C5CCD0B3EA8D215BE9BE386BD4081DA3BEC620DBEB0CB0E3EDC5AD9BCD31E03BEEAC7023E3856E83DD01B90BC085BEABDE225A53D502B3A3C2098873BC060403D820A9D3D105333BC9ADC153E1405E13D7DE6ACBD7067F93C20F546BCC04445BB480AA4BC20614DBC20D61EBCD2DA043E6666BCBD2F5388BD3606D7BDC87C95BD4C70193D70EA103C64DF803DE4CF2ABDC893CBBCE49FFC3D269161BD5E05BE3D7098803D34F44D3DD06DA43D361FC1BDF9F0E9BDE835F13CF02A123C746E7B3DC01205BD5433173E0037FBBA475ACEBDAE7F55BD904A0B3E807300BB1879BFBD04349ABD80A0C33CACB4413D0AB365BD20F0063D3096763D50321D3D2EFC42BD4B8EF7BDD1BAA7BDF48B5F3D7EDF2ABD006C7CBA9C8F51BD701C6EBD2853F33DCC7459BD2069BABBA01004BC68729B3DB85281BDDC33FF3D5871193DB06250BC388C703DB0E882BC4016243C266471BDE08BFF3BED0001BE50FF3E3C4EDE843DF42AD63DA08736BD9A33163EA0F915BE2C93E43DA063B33D1CD9ACBDF059103E524AAA3D12B9D1BD9E02043E4C1D8D3D6894DF3D20749ABC0058C7BD20CD073D18E6E6BC485639BD64AF4E3DC2338BBD15FE06BEA0DBBEBC5214003E1AB9023E08F1F33CF4BD00BEF2C2A03DEC29E73D8D84D1BDE3A3B3BD40412BBCAC46FA3D1018ECBCC0619ABBC568D8BD448382BDD24A44BDA471943D14CC01BEA04B61BCB080AB3D483FB0BC4E704CBDB652E5BD882B1F3D6BE3C0BD94E02D3DA8B9D2BD50B1CD3CAC275EBDB88F963D5BF30EBEB3FDD9BD50FFAE3C50D0C7BCF039DD3C206FCF3DB2120FBE52E3083E692B02BECCB741BD9CD006BDBA72EEBDD56885BD486CE73D9848D23C346F06BEC20816BECE4E8DBD0C5ADF3D47FF8ABD7A879A3D3A2E48BD80C7ACBC9C3C0CBE7AAB803D692C11BE466B8ABD2E0522BDA4F60A3DA81691BD5E66873DECBB393D5B7CD2BDA82E17BE5069FA3D80CA2BBBF81BCDBC3C9B763D6DF30BBE10AB0DBD368A003E26FBB03D30483FBC56AFBA3DEC390DBD48AA163D4EF119BDF896923DF916F8BD20A9F23D2CA6493DAA90F4BDD4F55CBD5C95023DEC83E1BDC56816BEEAA3053EA2771EBDDCB1783D24C6E03D53CEAABD48A633BD3C7567BD00F34E3A0091D13DBC8226BDC0460FBBFE73073E207DC03C4C6EAD3DB626CABD4EC6063E6854AB3C840BF7BCCC16063DEF5C9EBDD8B616BE18DFCF3D282EC23D04ACE83DAC3EEF3DFC1EDE3DD1F695BDD431B73D2A30843D124AF3BDB23D59BD605E073EE619133EB497913D30F767BDA2A9083EF2EEE3BDA48A463D88D842BD8424F93D68820BBE228D9B3D998087BD221BC73D20EB8E3C1C65B9BD2029483C706F85BC6F4883BDF4C1153E2CEA03BD2069D43D20BDD13D5B5895BD004F0C3B2E230F3EFC0314BD6EA5023E869FFBBD08B9FCBC96C8FBBD90B3333CE0BB883C00611FBA06268DBD68F7533D309F453C8CA7A43DAAD7003E54D5E13DCC340E3E6439CDBD8690CCBD00C7143EFEBDB53D54F224BD2607DFBD9477E83D98F7CABCC0694E3B2CFE6B3DA6A98ABDCA22A23D401C0BBCBC36C4BD20AE003EC59DD3BD247831BD00BC55BA77DA06BED0F1353DFCA0FCBC94A09A3DD444AE3DE8602C3D409FC4BBAE4F30BD2B8FAEBD5E006BBD4E8413BE74FF0DBEC4E4DF3DF09356BDA825A33D806A8ABBE8CBF03D28DEDC3D40B29DBC3B64D0BDFCCF1B3D6C89203DB83B003D78DDF63D1CBF92BD2021373C3088783C894819BE68989D3D689F703D47E28CBD50B0E33C401AA93C70DE5B3C01BDBBBD061D5DBD009BA43DA8A200BD393AF4BD9BFBCFBD46DABFBD44DF953DD529ABBD00B620BCBC38A93D38AB353D9CB88ABDD8E1E2BDE831323D904010BE32D3133ECAB5C83DA099523DE03A9EBBE039DC3C662016BE5E3D0B3EF2C5F0BDAC93D4BD503D7FBDCAFBBB3DF3F68BBDEE9022BD3435693D803EE03A36DC74BD9601913D186D033E2F1AB0BD30F0473D414BF2BDE008FF3C002B83BDE39312BEDFFDAABD74A4F93D719A9EBDE2026EBD0855BBBC8828D93DC832073E970A0EBE06950F3E559E06BE6C72E0BC10F95F3C7538EEBD60DDE4BB0053C03B1552B2BDF2A2A1BDC887D1BC14F3CA3D74EB3D3DC0240D3E309C6F3D84B571BD819D0CBEA8126DBDD0E4FB3D38DBC43C6685D2BDEC73E13DD822F7BDC08866BB9748C9BDEFF0FCBDF62E04BD60A3493C20A55CBC34950FBEC422993DEC8F0F3E6878133ED831973CC8088FBD0044A63BC006993BEB1B0EBEA897693D10A59EBC88C398BCA872FF3C8840D23DDA2985BDD818923D9C9BC33D24B1E43D9C5AA5BDC034F63D2CE0BDBD68F9A63C7CF0433DD566A1BDC0AF02BB1B3989BDA8F0173DA6C4C13D2EDD06BE2827BC3D9C1A843D8278C8BD8E2D12BD50CC06BE4F4C9DBD965D78BD6287083ECEEDB9BD6E1FC6BD923450BD27FBA9BD601AF33B8894C8BD50743F3CA0D887BC00AC323C1068F23D8765A8BD523C0EBDE0D400BE8AEF923D40F3923D0C05313D80690E3E8872ED3D92E4163EA8A7D0BD0CB6DF3D6056F73CB000B83D7827CABC30BCE7BDBC84E53D8A9BC53DC48FF5BC6C82EFBD895BFBBDE0C792BB315FDFBD7081CC3C11E20ABEA0EA5D3DA4D8F23D1C8037BD046EB43D307CC8BDECE0ED3D2461FE3D4BF783BDFAFF8D3D547F133D3FE9AFBDE84EFD3D52EE043E4CAADD3D67A186BD6291093E947290BD985EEE3CA45F5EBD98E0093E16DCD3BDE040FA3B7C85793DE09AC73C08F24C3D3F7319BEC0CF6F3D206EDABDF8D2243DA807253D849F103DC03A9B3CD46E093D28E4EA3C04F7FA3DBAAD01BEB0F1F33D0DF806BE3A51D6BD40D656BC0293F9BDCA09A7BD0A9C093E6E0D153EF4ADFA3D009F703D488A8DBC9F848BBD4099C23D5A73F1BDC9A9E3BD14470EBE9197EEBDFFC60EBE59319FBD5A9D983D1C33EE3DA4F974BD56B414BD46B3F2BD202A7D3D38A5A73D4C4014BE685EA4BC78CA013EB4881E3D7A50B1BDF047C7BC765423BD04E1D63DA06101BD543AAF3D3ACE023EA0272B3D0A61BABD1443E33D64E5773D8A817ABD08D1F53CA06C23BD780C10BE2055CDBBA64C5EBDD7D3B0BD00EDEC3C004C05BC80600F3EC0CCE53B7B5A93BD90EDD93C9C03DD3DCEE986BD2029D03BF9980CBE7C97EBBDBE38BFBD8C50913D0EC6903D0035013AE4B804BEDCA5383D303B2DBC260DFFBDFC710C3DFFE1EBBD80DDCF3DB0D7E33DBA2F29BD33D7BCBDD2D7A73D1044EDBD749CE53D36C913BEC2974ABD584C72BDA88CB53DA6CFC9BD3CB3FBBCA4D212BE7E9911BEA0EB6ABC42D7033EB064FB3CA89B6B3D58ADA8BD00AE673D00773FBB638085BD686C153E5E1345BDCCD6943D07C606BEC8E3103D554B8BBDD0D6F9BD76F318BE4469ED3DEE1012BEB417D73DCEF8A43DA833AF3DA839983C308BB5BD6236B53D1EB4C9BDACC6D8BD40A5C2BBE87609BEFC1ED33DA063B4BC60A2303D3011C93DFEB213BD4C5C183DB04C00BEC4702E3D8F1F8CBDB08E83BDC0D701BE6834C93D22C4133E28378F3D60DAFABDB814B0BD4C6CECBD2C239D3DF83559BDE01885BB3E8F9C3D63EA14BEE346EBBD30DF0CBEB667A63DAB2DB0BD4893E93CF250FBBD7693183E827E4CBD4AD42FBD14B7E9BC5C83103E3AA0E0BD009C0DBB449C6A3D606B353D0FB5F8BD59FF03BEA79795BD00BF053ED84802BD8056113C50736E3D36CA0F3E6058203C80B6883B3CE64E3DD099C2BDE6A807BE1C41F7BC1A98F1BDFE7BD8BD8A8AECBDB081953C625F19BE3B9BA6BDD49A3EBD40E1DF3C5059AFBC8C83113E589D0CBEB46DF9BC580774BD88B15A3DEBCBA3BD0A1A09BE206B9B3C4D87F6BD7B1987BD80E7613D70B7E73DF0065FBCC039A53CAC4F333DA05ED93CD4EA43BDDEC6DCBDECC0A7BD98DF093E70EE12BE004764BB347F083EEA6AD6BD90AB64BD5878D53D60378C3DC011E73D286DD13CBC952ABD6057933CBEAD11BE24204C3DBC3555BD2C4C253DF02BF33DC69CC03D4CDC1ABD78A1E23DC00D06BE2057EEBC60CA02BCAB3019BE4F8D07BE0A3260BDA05D3A3C42DA073E58E0F13C600DF03C894AE7BD00748C3AF491143EBA121FBDA0CFE2BD6887283DB2A517BE67CBBCBD28C20ABE5C2C1F3DC50298BD2C14C13D56A2103E76EBB63DF459AFBDD4160ABE002460BC809664BBEC42703DE08F403C6167A2BD68AE653DA6208A3DD65A4BBD6860763D340E943DC08F03BCFCD9113E0014733C41BCABBDEC4C09BEE34CF8BD40ABB8BCC06F18BD600EE93CA839BABDF024FA3C045E583DBC768D3DCE93B13DAC6D023DFABEA63D5E4F11BECCB1D53D68ED88BD14B0A9BD3A2217BE2084E43C213789BD6084EBBB5E05BE3D64F39E3D419AF4BD42A80B3E2442E3BDD24B813D002531BB782181BC3B6FA8BDDC47FE3DE0A4433D42C100BE202A0A3C6496013E9001703D32CE09BE2E769BBD880889BC02BB9F3D8E970E3EF4B94E3D969F03BD32BBAA3D782D033D909315BE9C3FC4BDB9A981BD4AB5A4BDD009933C9676963D61F302BE8AF64FBD7849E13D7C71E7BD9CAD84BDD8CAE5BDDE8CF2BD7034F83D09CAC0BD0072F9BB58E7A6BD00C283BCD4EE06BEF0600F3CB7D0D8BDB847A23D7432A53D2009A6BC43489EBDD44D473D40AEEDBB1CE6193E18D02B3DE459A53D350099BD9003BF3D521500BEF0F94DBCC442003EDE56EBBD00600EBB52B68FBD1C89523DCF3413BE5457E33D30EA0ABE48C208BEE82B1A3D0C3A643D4856D83D10F329BCC679E6BD087BC43DB6C1933DF170B8BDE63F043E9771C6BD90D1CCBCECCD4CBD17BD91BDAE4E72BDC0B5EE3D682C9E3D285ADD3D7463B03DE8EFFC3DAD0E03BE18BCF03DBC460B3EC639133E5867173E28D6C43D86E11FBD98A88C3C53CFE3BD244BE23D44550EBD6E939D3D48290B3E20F964BD68A019BEA004113C92C101BE93B3AFBDCE9343BDC4C01F3D2815D8BDF81CF03D42CCAB3D10DC113C322619BD769E0CBD50F3B43C3E4E19BEA01F78BDA8F6E83D686C3F3D30A8FA3D9C7AE6BCEAF68D3D28C7EA3D801A473BBF0E13BE80AF853C9C11E1BC80A60D3ED086673CC0AB83BB260DE2BDBAA2903D94D9A2BD169E85BDD446273D9024F1BC00AD75BCFA7BA93D00359F3ABCAE13BDA418113E5913CFBDF8D896BCD24F153E4C103DBD06407BBD52F477BD209816BEF83AD0BC8072133E568E143EF79297BDF4AA163D70DF813CB0E83FBC60F811BE3455D43D748B493D0C5C3B3D686F98BC2BE197BD9E7AC7BDF8DCEF3D6DAAB3BDF00BBA3CC403783D7CB7CEBDEC85F5BD10D588BD005F073AEAB962BD44DCFD3D18BEDD3D22C8153E9279AD3DF7D391BD7CF2123EDCBE0F3D047858BD7A2C5BBDB8196C3D109CA3BC5491123E302626BC72060FBE084D173EA424163E10B568BDD075023D9C8D27BD58D1B1BC60857FBDE0F4B3BBF00A68BDF404733DF023493C137CF9BD4A100C3ED862F43C287C80BDC840FDBD3CDB97BDA951FCBDF0ACCA3D085077BD30A03F3C40632EBC8ED0C83D207674BCB87811BD95F817BE0852963C9CDCE4BDDFFE01BE0664843D809B97BADCA997BD6E5E01BED0610F3E005D003D0DABBEBDC045E5BBED908BBD388D833DDCF9B6BDBD10CABDC6DD9D3DFD4BAFBDD7E10ABE22E00C3E5839E73DA45B633DE86D97BC9EB0913DA8D2073E5BF213BE6805063E08C3913C3CD60A3DCA8461BD64288A3D4087BCBBC07E303B16C092BD58F30B3EC8248F3D86E376BD50213C3C4C4A73BD7494B53D8E66AC3D1BC1CBBDA098883BC757EEBD30F3B63C88CCBFBC6223A83D625FD8BDD005B3BCB4623C3D40E3133C028100BE56B603BEBAC89F3DBA2D0F3E48D18E3C2231C0BD622B863D167305BD0801BB3D081F123E4050283C6E6270BD34274B3D4472163D0CA6D5BD78D2D83D2E56C9BDF29ED6BD30ED013DA60BC93DB05A7F3CD87BB33C0A16FDBD6043F13BF81DAEBD5070A23D202A073DDF5B0DBE7814B1BC4C98723DCCE8B2BD33318EBD3C4607BE04EAE1BC85F709BE92FB47BDB09EE73D7EDB8A3D7A3B0FBD0E1EA0BD78FF843D6B8D01BEA227033E6098FE3DD44A22BD26310FBE450809BE808A8A3BFC39ECBC907339BD2424983DE07D283DC2B324BD8053E23DF021E13DA06585BC3EAAD1BD684AB93D4EAEBABDAA4D9CBD59EC00BEBA14C73D0C84383DCF1C84BD6360A1BD448718BD08CB623DDD3BE2BD80A8673D18C6903D00BAEA3B0BB1D1BD088D183D260D943D5863083EB3F113BEE1FD17BEC624943D4AA2ACBD7884A8BDECF1B53D8030F1BAC22AA2BD80F0C1BD9A9004BEB763D6BD644E083DC045EB3C6C5F7F3D624B163E665E55BD4CA4443D188A8F3C9570E7BDA6214EBD3442C93D3C6DDA3D57AC92BD7246093E8FBA12BEAC1DF3BDB8C4B43D98FBFB3C8E5CDFBD51EA02BE20AFF53C44481E3DD4D4783D4827403D5874CCBC70FDE33C74E1FE3D582B7F3D848652BD70535A3C61EB02BECBDC10BE581B023EE6AD003EAA78A33D3AF402BEDEBB053E5EB208BE1F920ABE407AF33B6EB608BEB00A223D572A16BE40FD3EBCCD3208BE9265C63DEAE9DBBDD02B3FBD48DD91BCA47EF03D9AE752BDA825193E14FC513DC86CBB3DB230BF3D3A2F0B3E406D5A3C54F20D3E8095C8BC3EFD19BE2801F43C88DD6BBD30F76BBC4C4509BD9484FD3DB8FE753D0E05883DD875CD3D603ABDBD90660E3E4B091ABEA86EB6BDF01C3B3C4C82583DFECAA23D9AAD923D4C1C02BEDC8A163E5BB705BEE4E7163D781DECBD0275AB3D9C59363D8FA2D5BDC8B4143E0DFBFABD5FC382BDF8E0B0BC16A4003E80DF133CF664193EB803F83C983C7D3D9043023D84B2703D822C123E4083A13D408E84BB3896F23D6E85943D0894E0BD9479043ECCB0123E767AC33DD61226BD6C52043D498EA7BD8A06193E0296F1BD7EE075BD948C573DD0AD983CA438B43DCC10A63D7C68B03D4824C7BC952D84BDA0DEAABBF20155BD2624A63DEE1A0E3E3468CB3D68FD743D4EAB0B3E1C55F93D85DA01BE124BE2BDA0A3B6BBF03E02BCCCB918BE508C4F3CFA55C2BD1080403D007C7F3CB658133E54DD053D0FEEA1BD5897E13D6072DC3DE0CDEF3BA26B74BD748232BD867BBD3DE2FB80BD0393D5BD20EF31BCAA3011BD00F493BA6ECE92BD121C153EF471053DA8C2643D246DF23D62024BBD54E27E3D201FE33DA8EB283DC63AB43DC8789CBD4865C5BD5C3ECBBDFC95E83DE8C2B33DFA32B5BD10450F3CB064343CFA4A083EC030283C049D563DE843BBBDB0A84EBD4CE63DBD8CE743BD64B616BE18834D3D5CB3183D34EFE73D447DE53D6884C33D2822F93C846F07BE313DCABD0078C3BB00739C3B90FB6CBC3E2AA83D82BA113E1F048CBDB85E7C3D36B99CBDD4E63FBD1A9F053E034CFEBDC60CEEBDC0682BBB38E2BA3D5C7B023EA4CFF53D4E62053E007E953AFBCC00BEA4AEB03D00F8B538C0A9A33D33C4D6BD004E6C3BE049C13DF03F273D14BBC23DBB9DC0BD742615BDE8A994BC4293923D38011E3D5814123D6C85913D46F7AA3D8614033EACB0FBBC2099B3BBB83EF53CD189C2BD9B5BE6BDAAE0A2BDA0DD053C8C03FB3D206C263D4A7103BE3B5C0DBE3EADA63D100B90BC6E4B063ED29E8FBD5188AABDF4CCDBBC0A81D6BD4AA617BE464112BEA8F71A3DB08B653DA59891BD9A12133E34AC663D48528A3D1040C53CC05DA7BC005694BC4078B73B3DDEAFBDAE7E923D6F4AB4BDDABE8B3DC3E58BBD80D1FD3C382CC63C5F579CBDABE7EBBD7077FD3CB07863BCDCEE17BEA64A163E7474BC3D307FC13D323DBA3D00AD163EFC5ECCBD0D12F6BD2E43AB3D2EFCDDBD03EEE8BDCAEB033EEA5AF1BD2836083E0078D7BC94E9993D209AD03DE837D8BCB7090BBEDAF6143E4AAACEBD1E650A3E98DC86BDF6DD14BE3884A1BC55E9A1BD4890613D9CAF583D5C60FE3D9CE4263D889DC3BD08A95BBD106D04BC1E54CFBDD2845DBD4D1810BE78791D3D20C217BE0CE3953D84680E3E79CDD7BDF4121ABEDC55E6BD48AA083EC0D065BBF70F03BE3C0DF3BCC851D1BD5E475CBD58149D3D60D4893CF1A4F5BDAE3DC93D52B1BD3D60D19CBBBE420E3EB4FF41BD104A03BEF0B0383DB43331BDCAF2AABD9D8F85BD48AEC33D28F526BD783FD3BDE89F0F3E88B9F93C8461D13D7671AC3DAA3D2EBDA489F73D804109BC568FB7BDE87B5EBD7D6BACBD5179E2BD761D873D47A40ABEA0B5E5BBA4ACD43D80EDA63C30EA333DB513F5BDD0B4A1BD9003223DB895C73D94BD233D26599E3DE8A1F53D3203953D484D363DAEA38E3D0E3BAABDAC20FE3DC0519DBBE6520ABE2859B9BCEC568B3DA285183E4F9516BEF055B73CF8C3BDBC86BD023E3CB7B9BD000C66B9B8EC023D0C84F23D1844023E577302BEF59708BE38FB103E60E636BD422FE4BD24CC133EC2AC9C3D1CEF753DA4AFCF3DB6270C3EC619BDBD986522BD74B0213D6871B6BDCC810E3E7CEEF2BCFEE381BDACFCDEBD483E9A3D322D023EA978A2BDD052793C182BDD3D181BD53CE093CC3B38608F3DBECE13BE8887B7BC7886FF3CDA779A3D867984BDB1E408BE2033DC3B80700DBC9EAA18BEF39C0BBEF8FE563D00607E3D72E9EDBD5032043E65C514BE44EA0BBD64AAAC3D00DCF6395841E0BC1B258FBD6E03C7BD84CD233DCA8273BD5EE1F1BD4858FF3D504BF53D1029F23C20B09B3D22370C3EC8E9163E1C36003D9812FD3DE8DDE0BCD0376EBC1B1297BD54D660BDC3F5CEBDC36406BE3C1A233D5CBC1B3D3F7E9BBD14EEC73D4ADFA43DF0E1743C286815BE907A68BCB48E01BD9829BCBCAD4D8FBD082FED3D44BFF43D045A303DD61F933D0821DA3C0000AAB67C0FE53D484D343D70DA0E3EBC59213DD2CF923D18E1FE3CF4A7753D4047F23B48CFC33DE08C9DBB47F58EBDB64926BDF858E33DB40BF9BD183B85BD46AAA13DBE382DBD7B0E89BDD83C923CC4BB313DE421CD3DF62C063E8C46D73D08FAD23C5CE9C23DCC04663DBA235BBDF8CDFDBCA072F5BB744A98BD42E597BDD64705BE00994B3B2D1E12BE6C91973D1EE9F3BD603C30BC56659C3D6428A5BD22ED4EBDA034463D2646013E20DBAE3CA028DA3D33D8A1BD128510BE10D52E3DB079BFBC09239BBDC0F3E23B4BB191BD7023133D685804BED4D0D23D5ADFBA3D18E5F63D28714FBD18A63A3DDA88C83DF57593BDA681EEBD4039F9BB6137FEBD8071473CC4E7DBBDA89FAA3C90C03A3C2415FC3D7096A63CFCA0963D70B4143EA86746BD4EF9F5BDCEFE0BBDA0DB203D54AD83BD801EF7BBB7AC0DBE60C486BCC880843DD8B1193EA07EB7BC8A945FBD90B9CF3C683BAE3D5A1ABABD60B6A13D6041923C904B163EACC7DBBC60D2A2BC0409123EB0E0413DE94A16BEB40F103D3A2E0C3E45E303BE429007BEFC28753DCCA1B33D783A08BEF712E8BD46B827BD96AFB13D746C533D2C8A063D78D6093E643CDC3DE03C46BC4014843C1D9CB8BD797600BE9C02C33D7EF757BD6828D6BCC47A01BDA441E53DD0118EBC640A1DBDD4B2163DA07AE13D3CF37D3D3AE490BD0E44BABD60DC2C3CC66E03BEAAD079BD8DF983BDB65F103E88F4B3BC4082743B34900C3E08EED2BC1AD2DDBD04E8E83D208EDD3CC0B129BB">
  memref.global "private" constant @__constant_1x8x4xf32 : memref<1x8x4xf32> = dense<[[[-0.431032777, 0.339656174, -0.0172508955, 0.530783117], [-0.131361604, -0.686532557, 0.29633683, -0.190197289], [0.114347279, 0.56687206, -0.5206815, 0.0635936856], [0.278496087, -0.701272607, -0.192214727, 0.0925094485], [-0.263988972, 0.210848868, 0.702368438, -0.632420897], [0.552770555, -0.32865116, -0.0839602351, 0.335239589], [-0.466998219, -0.367347717, 0.669422566, 0.683026611], [-0.653910696, -0.016515851, 0.00850236415, 0.640155136]]]>
  memref.global "private" constant @__constant_1x4x2xf32 : memref<1x4x2xf32> = dense<[[[-0.649729251, -0.36405158], [0.711094856, -0.165482044], [-0.528160095, -0.548771381], [0.198056698, 0.657765388]]]>
  func @main(%arg0: memref<4x32x32x1xf32>, %arg1: memref<4x2xf32>) attributes {tf.entry_function = {control_outputs = "", inputs = "x1", outputs = "Identity"}} {
    %cst = arith.constant 0.000000e+00 : f32
    %cst_0 = arith.constant 3.40282347E+38 : f32
    %cst_1 = arith.constant 1.000000e+00 : f32
    %0 = memref.alloc() {alignment = 128 : i64} : memref<4x35x35x1xf32>
    %1 = memref.get_global @__constant_2xf32 : memref<2xf32>
    %2 = memref.get_global @__constant_4xf32 : memref<4xf32>
    %3 = memref.get_global @__constant_8xf32 : memref<8xf32>
    %4 = memref.get_global @__constant_1xf32 : memref<1xf32>
    %5 = memref.get_global @__constant_1x5x5x1xf32 : memref<1x5x5x1xf32>
    %6 = memref.get_global @__constant_1x256x8xf32 : memref<1x256x8xf32>
    %7 = memref.get_global @__constant_1x8x4xf32 : memref<1x8x4xf32>
    %8 = memref.get_global @__constant_1x4x2xf32 : memref<1x4x2xf32>
    %9 = memref.alloc() : memref<4x35x35x1xf32>
    linalg.fill(%cst, %9) : f32, memref<4x35x35x1xf32> 
    memref.copy %9, %0 : memref<4x35x35x1xf32> to memref<4x35x35x1xf32>
    memref.dealloc %9 : memref<4x35x35x1xf32>
    %10 = memref.subview %0[0, 1, 1, 0] [4, 32, 32, 1] [1, 1, 1, 1] : memref<4x35x35x1xf32> to memref<4x32x32x1xf32, #map0>
    memref.copy %arg0, %10 : memref<4x32x32x1xf32> to memref<4x32x32x1xf32, #map0>
    %11 = memref.alloc() : memref<5x5x1x1xf32>
    linalg.generic {indexing_maps = [#map1, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%5 : memref<1x5x5x1xf32>) outs(%11 : memref<5x5x1x1xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      linalg.yield %arg2 : f32
    }
    %12 = memref.alloc() : memref<4x16x16x1xf32>
    linalg.fill(%cst, %12) : f32, memref<4x16x16x1xf32> 
    %13 = memref.alloc() : memref<4x16x16x1xf32>
    memref.copy %12, %13 : memref<4x16x16x1xf32> to memref<4x16x16x1xf32>
    memref.dealloc %12 : memref<4x16x16x1xf32>
    linalg.conv_2d_nhwc_hwcf {dilations = dense<1> : tensor<2xi64>, strides = dense<2> : tensor<2xi64>} ins(%0, %11 : memref<4x35x35x1xf32>, memref<5x5x1x1xf32>) outs(%13 : memref<4x16x16x1xf32>)
    memref.dealloc %11 : memref<5x5x1x1xf32>
    memref.dealloc %0 : memref<4x35x35x1xf32>
    %14 = memref.alloc() : memref<4x16x16x1xf32>
    linalg.generic {indexing_maps = [#map3, #map2, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%4, %13 : memref<1xf32>, memref<4x16x16x1xf32>) outs(%14 : memref<4x16x16x1xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %13 : memref<4x16x16x1xf32>
    %15 = memref.alloc() : memref<4x16x16x1xf32>
    linalg.generic {indexing_maps = [#map2, #map2], iterator_types = ["parallel", "parallel", "parallel", "parallel"]} ins(%14 : memref<4x16x16x1xf32>) outs(%15 : memref<4x16x16x1xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.cmpf olt, %arg2, %cst : f32
      %42 = arith.select %41, %cst, %arg2 : f32
      %43 = arith.cmpf olt, %cst_0, %arg2 : f32
      %44 = arith.select %43, %cst_0, %42 : f32
      linalg.yield %44 : f32
    }
    memref.dealloc %14 : memref<4x16x16x1xf32>
    %16 = memref.collapse_shape %15 [[0], [1, 2, 3]] : memref<4x16x16x1xf32> into memref<4x256xf32>
    %17 = memref.expand_shape %16 [[0, 1], [2]] : memref<4x256xf32> into memref<1x4x256xf32>
    %18 = memref.alloc() : memref<1x4x8xf32>
    linalg.fill(%cst, %18) : f32, memref<1x4x8xf32> 
    %19 = memref.alloc() : memref<1x4x8xf32>
    memref.copy %18, %19 : memref<1x4x8xf32> to memref<1x4x8xf32>
    memref.dealloc %18 : memref<1x4x8xf32>
    linalg.batch_matmul ins(%17, %6 : memref<1x4x256xf32>, memref<1x256x8xf32>) outs(%19 : memref<1x4x8xf32>)
    memref.dealloc %15 : memref<4x16x16x1xf32>
    %20 = memref.collapse_shape %19 [[0, 1], [2]] : memref<1x4x8xf32> into memref<4x8xf32>
    %21 = memref.alloc() : memref<4x8xf32>
    linalg.generic {indexing_maps = [#map4, #map5, #map4], iterator_types = ["parallel", "parallel"]} ins(%20, %3 : memref<4x8xf32>, memref<8xf32>) outs(%21 : memref<4x8xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %19 : memref<1x4x8xf32>
    %22 = memref.alloc() : memref<4x8xf32>
    linalg.generic {indexing_maps = [#map4, #map4], iterator_types = ["parallel", "parallel"]} ins(%21 : memref<4x8xf32>) outs(%22 : memref<4x8xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.cmpf olt, %arg2, %cst : f32
      %42 = arith.select %41, %cst, %arg2 : f32
      %43 = arith.cmpf olt, %cst_0, %arg2 : f32
      %44 = arith.select %43, %cst_0, %42 : f32
      linalg.yield %44 : f32
    }
    memref.dealloc %21 : memref<4x8xf32>
    %23 = memref.expand_shape %22 [[0, 1], [2]] : memref<4x8xf32> into memref<1x4x8xf32>
    %24 = memref.alloc() : memref<1x4x4xf32>
    linalg.fill(%cst, %24) : f32, memref<1x4x4xf32> 
    %25 = memref.alloc() : memref<1x4x4xf32>
    memref.copy %24, %25 : memref<1x4x4xf32> to memref<1x4x4xf32>
    memref.dealloc %24 : memref<1x4x4xf32>
    soda.launch_func  @main_kernel::@main_kernel args(%23 : memref<1x4x8xf32>, %7 : memref<1x8x4xf32>, %25 : memref<1x4x4xf32>)
    memref.dealloc %22 : memref<4x8xf32>
    %26 = memref.collapse_shape %25 [[0, 1], [2]] : memref<1x4x4xf32> into memref<4x4xf32>
    %27 = memref.alloc() : memref<4x4xf32>
    linalg.generic {indexing_maps = [#map4, #map5, #map4], iterator_types = ["parallel", "parallel"]} ins(%26, %2 : memref<4x4xf32>, memref<4xf32>) outs(%27 : memref<4x4xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %25 : memref<1x4x4xf32>
    %28 = memref.alloc() : memref<4x4xf32>
    linalg.generic {indexing_maps = [#map4, #map4], iterator_types = ["parallel", "parallel"]} ins(%27 : memref<4x4xf32>) outs(%28 : memref<4x4xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.cmpf olt, %arg2, %cst : f32
      %42 = arith.select %41, %cst, %arg2 : f32
      %43 = arith.cmpf olt, %cst_0, %arg2 : f32
      %44 = arith.select %43, %cst_0, %42 : f32
      linalg.yield %44 : f32
    }
    memref.dealloc %27 : memref<4x4xf32>
    %29 = memref.expand_shape %28 [[0, 1], [2]] : memref<4x4xf32> into memref<1x4x4xf32>
    %30 = memref.alloc() : memref<1x4x2xf32>
    linalg.fill(%cst, %30) : f32, memref<1x4x2xf32> 
    %31 = memref.alloc() : memref<1x4x2xf32>
    memref.copy %30, %31 : memref<1x4x2xf32> to memref<1x4x2xf32>
    memref.dealloc %30 : memref<1x4x2xf32>
    linalg.batch_matmul ins(%29, %8 : memref<1x4x4xf32>, memref<1x4x2xf32>) outs(%31 : memref<1x4x2xf32>)
    memref.dealloc %28 : memref<4x4xf32>
    %32 = memref.collapse_shape %31 [[0, 1], [2]] : memref<1x4x2xf32> into memref<4x2xf32>
    %33 = memref.alloc() : memref<4x2xf32>
    linalg.generic {indexing_maps = [#map4, #map5, #map4], iterator_types = ["parallel", "parallel"]} ins(%32, %1 : memref<4x2xf32>, memref<2xf32>) outs(%33 : memref<4x2xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %31 : memref<1x4x2xf32>
    %34 = memref.alloc() : memref<4x2xf32>
    linalg.generic {indexing_maps = [#map4, #map4], iterator_types = ["parallel", "parallel"]} ins(%33 : memref<4x2xf32>) outs(%34 : memref<4x2xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = math.exp %arg2 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %33 : memref<4x2xf32>
    %35 = memref.alloc() : memref<4xf32>
    linalg.fill(%cst, %35) : f32, memref<4xf32> 
    %36 = memref.alloc() : memref<4xf32>
    memref.copy %35, %36 : memref<4xf32> to memref<4xf32>
    memref.dealloc %35 : memref<4xf32>
    linalg.generic {indexing_maps = [#map4, #map6], iterator_types = ["parallel", "reduction"]} ins(%34 : memref<4x2xf32>) outs(%36 : memref<4xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.addf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    %37 = memref.expand_shape %36 [[0, 1]] : memref<4xf32> into memref<4x1xf32>
    %38 = memref.alloc() : memref<4x1xf32>
    linalg.generic {indexing_maps = [#map4, #map4], iterator_types = ["parallel", "parallel"]} ins(%37 : memref<4x1xf32>) outs(%38 : memref<4x1xf32>) {
    ^bb0(%arg2: f32, %arg3: f32):
      %41 = arith.divf %cst_1, %arg2 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %36 : memref<4xf32>
    %39 = memref.collapse_shape %38 [[0, 1]] : memref<4x1xf32> into memref<4xf32>
    %40 = memref.alloc() : memref<4x2xf32>
    linalg.generic {indexing_maps = [#map4, #map6, #map4], iterator_types = ["parallel", "parallel"]} ins(%34, %39 : memref<4x2xf32>, memref<4xf32>) outs(%40 : memref<4x2xf32>) {
    ^bb0(%arg2: f32, %arg3: f32, %arg4: f32):
      %41 = arith.mulf %arg2, %arg3 : f32
      linalg.yield %41 : f32
    }
    memref.dealloc %38 : memref<4x1xf32>
    memref.dealloc %34 : memref<4x2xf32>
    memref.copy %40, %arg1 : memref<4x2xf32> to memref<4x2xf32>
    return
  }
  soda.module @main_kernel {
    soda.func @main_kernel(%arg0: memref<1x4x8xf32>, %arg1: memref<1x8x4xf32>, %arg2: memref<1x4x4xf32>) kernel{
      cf.br ^bb1
    ^bb1:  // pred: ^bb0
      linalg.batch_matmul ins(%arg0, %arg1 : memref<1x4x8xf32>, memref<1x8x4xf32>) outs(%arg2 : memref<1x4x4xf32>)
      soda.return
    }
  }
}


// -----// IR Dump After SodaKernelGeneration //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    cf.br ^bb1
  ^bb1:  // pred: ^bb0
    linalg.batch_matmul ins(%arg0, %arg1 : memref<1x4x8xf32>, memref<1x8x4xf32>) outs(%arg2 : memref<1x4x4xf32>)
    return
  }
}


// -----// IR Dump After LinalgLowerToAffineLoops //----- //
func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
  cf.br ^bb1
^bb1:  // pred: ^bb0
  affine.for %arg3 = 0 to 1 {
    affine.for %arg4 = 0 to 4 {
      affine.for %arg5 = 0 to 4 {
        affine.for %arg6 = 0 to 8 {
          %0 = affine.load %arg0[%arg3, %arg4, %arg6] : memref<1x4x8xf32>
          %1 = affine.load %arg1[%arg3, %arg6, %arg5] : memref<1x8x4xf32>
          %2 = affine.load %arg2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %3 = arith.mulf %0, %1 : f32
          %4 = arith.addf %2, %3 : f32
          affine.store %4, %arg2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        }
      }
    }
  }
  return
}

// -----// IR Dump After AffineDataCopyGeneration //----- //
func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
  %c16 = arith.constant 16 : index
  %c0 = arith.constant 0 : index
  %c16_0 = arith.constant 16 : index
  %c0_1 = arith.constant 0 : index
  %c32 = arith.constant 32 : index
  %c0_2 = arith.constant 0 : index
  %c32_3 = arith.constant 32 : index
  %c0_4 = arith.constant 0 : index
  %c0_5 = arith.constant 0 : index
  cf.br ^bb1
^bb1:  // pred: ^bb0
  %0 = memref.alloc() : memref<1x4x8xf32>
  affine.for %arg3 = 0 to 4 {
    affine.for %arg4 = 0 to 8 {
      %3 = affine.load %arg0[0, %arg3, %arg4] : memref<1x4x8xf32>
      affine.store %3, %0[0, %arg3, %arg4] : memref<1x4x8xf32>
    }
  }
  %1 = memref.alloc() : memref<1x8x4xf32>
  affine.for %arg3 = 0 to 8 {
    affine.for %arg4 = 0 to 4 {
      %3 = affine.load %arg1[0, %arg3, %arg4] : memref<1x8x4xf32>
      affine.store %3, %1[0, %arg3, %arg4] : memref<1x8x4xf32>
    }
  }
  %2 = memref.alloc() : memref<1x4x4xf32>
  affine.for %arg3 = 0 to 4 {
    affine.for %arg4 = 0 to 4 {
      %3 = affine.load %arg2[0, %arg3, %arg4] : memref<1x4x4xf32>
      affine.store %3, %2[0, %arg3, %arg4] : memref<1x4x4xf32>
    }
  }
  affine.for %arg3 = 0 to 1 {
    affine.for %arg4 = 0 to 4 {
      affine.for %arg5 = 0 to 4 {
        affine.for %arg6 = 0 to 8 {
          %3 = affine.load %0[%arg3, %arg4, %arg6] : memref<1x4x8xf32>
          %4 = affine.load %1[%arg3, %arg6, %arg5] : memref<1x8x4xf32>
          %5 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %6 = arith.mulf %3, %4 : f32
          %7 = arith.addf %5, %6 : f32
          affine.store %7, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        }
      }
    }
  }
  affine.for %arg3 = 0 to 4 {
    affine.for %arg4 = 0 to 4 {
      %3 = affine.load %2[0, %arg3, %arg4] : memref<1x4x4xf32>
      affine.store %3, %arg2[0, %arg3, %arg4] : memref<1x4x4xf32>
    }
  }
  memref.dealloc %2 : memref<1x4x4xf32>
  memref.dealloc %1 : memref<1x8x4xf32>
  memref.dealloc %0 : memref<1x4x8xf32>
  return
}

// -----// IR Dump After EraseMemrefDealloc //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    cf.br ^bb1
  ^bb1:  // pred: ^bb0
    %0 = memref.alloc() : memref<1x4x8xf32>
    affine.for %arg3 = 0 to 4 {
      affine.for %arg4 = 0 to 8 {
        %3 = affine.load %arg0[0, %arg3, %arg4] : memref<1x4x8xf32>
        affine.store %3, %0[0, %arg3, %arg4] : memref<1x4x8xf32>
      }
    }
    %1 = memref.alloc() : memref<1x8x4xf32>
    affine.for %arg3 = 0 to 8 {
      affine.for %arg4 = 0 to 4 {
        %3 = affine.load %arg1[0, %arg3, %arg4] : memref<1x8x4xf32>
        affine.store %3, %1[0, %arg3, %arg4] : memref<1x8x4xf32>
      }
    }
    %2 = memref.alloc() : memref<1x4x4xf32>
    affine.for %arg3 = 0 to 4 {
      affine.for %arg4 = 0 to 4 {
        %3 = affine.load %arg2[0, %arg3, %arg4] : memref<1x4x4xf32>
        affine.store %3, %2[0, %arg3, %arg4] : memref<1x4x4xf32>
      }
    }
    affine.for %arg3 = 0 to 1 {
      affine.for %arg4 = 0 to 4 {
        affine.for %arg5 = 0 to 4 {
          affine.for %arg6 = 0 to 8 {
            %3 = affine.load %0[%arg3, %arg4, %arg6] : memref<1x4x8xf32>
            %4 = affine.load %1[%arg3, %arg6, %arg5] : memref<1x8x4xf32>
            %5 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
            %6 = arith.mulf %3, %4 : f32
            %7 = arith.addf %5, %6 : f32
            affine.store %7, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          }
        }
      }
    }
    affine.for %arg3 = 0 to 4 {
      affine.for %arg4 = 0 to 4 {
        %3 = affine.load %2[0, %arg3, %arg4] : memref<1x4x4xf32>
        affine.store %3, %arg2[0, %arg3, %arg4] : memref<1x4x4xf32>
      }
    }
    return
  }
}


// -----// IR Dump After PromoteBuffersToStack //----- //
func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
  cf.br ^bb1
^bb1:  // pred: ^bb0
  %0 = memref.alloca() : memref<1x4x8xf32>
  affine.for %arg3 = 0 to 4 {
    affine.for %arg4 = 0 to 8 {
      %3 = affine.load %arg0[0, %arg3, %arg4] : memref<1x4x8xf32>
      affine.store %3, %0[0, %arg3, %arg4] : memref<1x4x8xf32>
    }
  }
  %1 = memref.alloca() : memref<1x8x4xf32>
  affine.for %arg3 = 0 to 8 {
    affine.for %arg4 = 0 to 4 {
      %3 = affine.load %arg1[0, %arg3, %arg4] : memref<1x8x4xf32>
      affine.store %3, %1[0, %arg3, %arg4] : memref<1x8x4xf32>
    }
  }
  %2 = memref.alloca() : memref<1x4x4xf32>
  affine.for %arg3 = 0 to 4 {
    affine.for %arg4 = 0 to 4 {
      %3 = affine.load %arg2[0, %arg3, %arg4] : memref<1x4x4xf32>
      affine.store %3, %2[0, %arg3, %arg4] : memref<1x4x4xf32>
    }
  }
  affine.for %arg3 = 0 to 1 {
    affine.for %arg4 = 0 to 4 {
      affine.for %arg5 = 0 to 4 {
        affine.for %arg6 = 0 to 8 {
          %3 = affine.load %0[%arg3, %arg4, %arg6] : memref<1x4x8xf32>
          %4 = affine.load %1[%arg3, %arg6, %arg5] : memref<1x8x4xf32>
          %5 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %6 = arith.mulf %3, %4 : f32
          %7 = arith.addf %5, %6 : f32
          affine.store %7, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        }
      }
    }
  }
  affine.for %arg3 = 0 to 4 {
    affine.for %arg4 = 0 to 4 {
      %3 = affine.load %2[0, %arg3, %arg4] : memref<1x4x4xf32>
      affine.store %3, %arg2[0, %arg3, %arg4] : memref<1x4x4xf32>
    }
  }
  return
}

// -----// IR Dump After AffineLoopUnroll //----- //
func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
  %c0 = arith.constant 0 : index
  %c0_0 = arith.constant 0 : index
  %c0_1 = arith.constant 0 : index
  %c0_2 = arith.constant 0 : index
  %c0_3 = arith.constant 0 : index
  cf.br ^bb1
^bb1:  // pred: ^bb0
  %0 = memref.alloca() : memref<1x4x8xf32>
  affine.for %arg3 = 0 to 4 {
    %3 = affine.load %arg0[0, %arg3, %c0_3] : memref<1x4x8xf32>
    affine.store %3, %0[0, %arg3, %c0_3] : memref<1x4x8xf32>
    %4 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0_3)
    %5 = affine.load %arg0[0, %arg3, %4] : memref<1x4x8xf32>
    affine.store %5, %0[0, %arg3, %4] : memref<1x4x8xf32>
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0_3)
    %7 = affine.load %arg0[0, %arg3, %6] : memref<1x4x8xf32>
    affine.store %7, %0[0, %arg3, %6] : memref<1x4x8xf32>
    %8 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0_3)
    %9 = affine.load %arg0[0, %arg3, %8] : memref<1x4x8xf32>
    affine.store %9, %0[0, %arg3, %8] : memref<1x4x8xf32>
    %10 = affine.apply affine_map<(d0) -> (d0 + 4)>(%c0_3)
    %11 = affine.load %arg0[0, %arg3, %10] : memref<1x4x8xf32>
    affine.store %11, %0[0, %arg3, %10] : memref<1x4x8xf32>
    %12 = affine.apply affine_map<(d0) -> (d0 + 5)>(%c0_3)
    %13 = affine.load %arg0[0, %arg3, %12] : memref<1x4x8xf32>
    affine.store %13, %0[0, %arg3, %12] : memref<1x4x8xf32>
    %14 = affine.apply affine_map<(d0) -> (d0 + 6)>(%c0_3)
    %15 = affine.load %arg0[0, %arg3, %14] : memref<1x4x8xf32>
    affine.store %15, %0[0, %arg3, %14] : memref<1x4x8xf32>
    %16 = affine.apply affine_map<(d0) -> (d0 + 7)>(%c0_3)
    %17 = affine.load %arg0[0, %arg3, %16] : memref<1x4x8xf32>
    affine.store %17, %0[0, %arg3, %16] : memref<1x4x8xf32>
  }
  %1 = memref.alloca() : memref<1x8x4xf32>
  affine.for %arg3 = 0 to 8 {
    %3 = affine.load %arg1[0, %arg3, %c0_2] : memref<1x8x4xf32>
    affine.store %3, %1[0, %arg3, %c0_2] : memref<1x8x4xf32>
    %4 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0_2)
    %5 = affine.load %arg1[0, %arg3, %4] : memref<1x8x4xf32>
    affine.store %5, %1[0, %arg3, %4] : memref<1x8x4xf32>
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0_2)
    %7 = affine.load %arg1[0, %arg3, %6] : memref<1x8x4xf32>
    affine.store %7, %1[0, %arg3, %6] : memref<1x8x4xf32>
    %8 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0_2)
    %9 = affine.load %arg1[0, %arg3, %8] : memref<1x8x4xf32>
    affine.store %9, %1[0, %arg3, %8] : memref<1x8x4xf32>
  }
  %2 = memref.alloca() : memref<1x4x4xf32>
  affine.for %arg3 = 0 to 4 {
    %3 = affine.load %arg2[0, %arg3, %c0_1] : memref<1x4x4xf32>
    affine.store %3, %2[0, %arg3, %c0_1] : memref<1x4x4xf32>
    %4 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0_1)
    %5 = affine.load %arg2[0, %arg3, %4] : memref<1x4x4xf32>
    affine.store %5, %2[0, %arg3, %4] : memref<1x4x4xf32>
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0_1)
    %7 = affine.load %arg2[0, %arg3, %6] : memref<1x4x4xf32>
    affine.store %7, %2[0, %arg3, %6] : memref<1x4x4xf32>
    %8 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0_1)
    %9 = affine.load %arg2[0, %arg3, %8] : memref<1x4x4xf32>
    affine.store %9, %2[0, %arg3, %8] : memref<1x4x4xf32>
  }
  affine.for %arg3 = 0 to 1 {
    affine.for %arg4 = 0 to 4 {
      affine.for %arg5 = 0 to 4 {
        %3 = affine.load %0[%arg3, %arg4, %c0_0] : memref<1x4x8xf32>
        %4 = affine.load %1[%arg3, %c0_0, %arg5] : memref<1x8x4xf32>
        %5 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %6 = arith.mulf %3, %4 : f32
        %7 = arith.addf %5, %6 : f32
        affine.store %7, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %8 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0_0)
        %9 = affine.load %0[%arg3, %arg4, %8] : memref<1x4x8xf32>
        %10 = affine.load %1[%arg3, %8, %arg5] : memref<1x8x4xf32>
        %11 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %12 = arith.mulf %9, %10 : f32
        %13 = arith.addf %11, %12 : f32
        affine.store %13, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %14 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0_0)
        %15 = affine.load %0[%arg3, %arg4, %14] : memref<1x4x8xf32>
        %16 = affine.load %1[%arg3, %14, %arg5] : memref<1x8x4xf32>
        %17 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %18 = arith.mulf %15, %16 : f32
        %19 = arith.addf %17, %18 : f32
        affine.store %19, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %20 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0_0)
        %21 = affine.load %0[%arg3, %arg4, %20] : memref<1x4x8xf32>
        %22 = affine.load %1[%arg3, %20, %arg5] : memref<1x8x4xf32>
        %23 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %24 = arith.mulf %21, %22 : f32
        %25 = arith.addf %23, %24 : f32
        affine.store %25, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %26 = affine.apply affine_map<(d0) -> (d0 + 4)>(%c0_0)
        %27 = affine.load %0[%arg3, %arg4, %26] : memref<1x4x8xf32>
        %28 = affine.load %1[%arg3, %26, %arg5] : memref<1x8x4xf32>
        %29 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %30 = arith.mulf %27, %28 : f32
        %31 = arith.addf %29, %30 : f32
        affine.store %31, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %32 = affine.apply affine_map<(d0) -> (d0 + 5)>(%c0_0)
        %33 = affine.load %0[%arg3, %arg4, %32] : memref<1x4x8xf32>
        %34 = affine.load %1[%arg3, %32, %arg5] : memref<1x8x4xf32>
        %35 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %36 = arith.mulf %33, %34 : f32
        %37 = arith.addf %35, %36 : f32
        affine.store %37, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %38 = affine.apply affine_map<(d0) -> (d0 + 6)>(%c0_0)
        %39 = affine.load %0[%arg3, %arg4, %38] : memref<1x4x8xf32>
        %40 = affine.load %1[%arg3, %38, %arg5] : memref<1x8x4xf32>
        %41 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %42 = arith.mulf %39, %40 : f32
        %43 = arith.addf %41, %42 : f32
        affine.store %43, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %44 = affine.apply affine_map<(d0) -> (d0 + 7)>(%c0_0)
        %45 = affine.load %0[%arg3, %arg4, %44] : memref<1x4x8xf32>
        %46 = affine.load %1[%arg3, %44, %arg5] : memref<1x8x4xf32>
        %47 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %48 = arith.mulf %45, %46 : f32
        %49 = arith.addf %47, %48 : f32
        affine.store %49, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
      }
    }
  }
  affine.for %arg3 = 0 to 4 {
    %3 = affine.load %2[0, %arg3, %c0] : memref<1x4x4xf32>
    affine.store %3, %arg2[0, %arg3, %c0] : memref<1x4x4xf32>
    %4 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0)
    %5 = affine.load %2[0, %arg3, %4] : memref<1x4x4xf32>
    affine.store %5, %arg2[0, %arg3, %4] : memref<1x4x4xf32>
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0)
    %7 = affine.load %2[0, %arg3, %6] : memref<1x4x4xf32>
    affine.store %7, %arg2[0, %arg3, %6] : memref<1x4x4xf32>
    %8 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0)
    %9 = affine.load %2[0, %arg3, %8] : memref<1x4x4xf32>
    affine.store %9, %arg2[0, %arg3, %8] : memref<1x4x4xf32>
  }
  return
}

// -----// IR Dump After CSE //----- //
#map0 = affine_map<(d0) -> (d0 + 1)>
#map1 = affine_map<(d0) -> (d0 + 2)>
#map2 = affine_map<(d0) -> (d0 + 3)>
#map3 = affine_map<(d0) -> (d0 + 4)>
#map4 = affine_map<(d0) -> (d0 + 5)>
#map5 = affine_map<(d0) -> (d0 + 6)>
#map6 = affine_map<(d0) -> (d0 + 7)>
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %c0 = arith.constant 0 : index
    cf.br ^bb1
  ^bb1:  // pred: ^bb0
    %0 = memref.alloca() : memref<1x4x8xf32>
    affine.for %arg3 = 0 to 4 {
      %3 = affine.load %arg0[0, %arg3, %c0] : memref<1x4x8xf32>
      affine.store %3, %0[0, %arg3, %c0] : memref<1x4x8xf32>
      %4 = affine.apply #map0(%c0)
      %5 = affine.load %arg0[0, %arg3, %4] : memref<1x4x8xf32>
      affine.store %5, %0[0, %arg3, %4] : memref<1x4x8xf32>
      %6 = affine.apply #map1(%c0)
      %7 = affine.load %arg0[0, %arg3, %6] : memref<1x4x8xf32>
      affine.store %7, %0[0, %arg3, %6] : memref<1x4x8xf32>
      %8 = affine.apply #map2(%c0)
      %9 = affine.load %arg0[0, %arg3, %8] : memref<1x4x8xf32>
      affine.store %9, %0[0, %arg3, %8] : memref<1x4x8xf32>
      %10 = affine.apply #map3(%c0)
      %11 = affine.load %arg0[0, %arg3, %10] : memref<1x4x8xf32>
      affine.store %11, %0[0, %arg3, %10] : memref<1x4x8xf32>
      %12 = affine.apply #map4(%c0)
      %13 = affine.load %arg0[0, %arg3, %12] : memref<1x4x8xf32>
      affine.store %13, %0[0, %arg3, %12] : memref<1x4x8xf32>
      %14 = affine.apply #map5(%c0)
      %15 = affine.load %arg0[0, %arg3, %14] : memref<1x4x8xf32>
      affine.store %15, %0[0, %arg3, %14] : memref<1x4x8xf32>
      %16 = affine.apply #map6(%c0)
      %17 = affine.load %arg0[0, %arg3, %16] : memref<1x4x8xf32>
      affine.store %17, %0[0, %arg3, %16] : memref<1x4x8xf32>
    }
    %1 = memref.alloca() : memref<1x8x4xf32>
    affine.for %arg3 = 0 to 8 {
      %3 = affine.load %arg1[0, %arg3, %c0] : memref<1x8x4xf32>
      affine.store %3, %1[0, %arg3, %c0] : memref<1x8x4xf32>
      %4 = affine.apply #map0(%c0)
      %5 = affine.load %arg1[0, %arg3, %4] : memref<1x8x4xf32>
      affine.store %5, %1[0, %arg3, %4] : memref<1x8x4xf32>
      %6 = affine.apply #map1(%c0)
      %7 = affine.load %arg1[0, %arg3, %6] : memref<1x8x4xf32>
      affine.store %7, %1[0, %arg3, %6] : memref<1x8x4xf32>
      %8 = affine.apply #map2(%c0)
      %9 = affine.load %arg1[0, %arg3, %8] : memref<1x8x4xf32>
      affine.store %9, %1[0, %arg3, %8] : memref<1x8x4xf32>
    }
    %2 = memref.alloca() : memref<1x4x4xf32>
    affine.for %arg3 = 0 to 4 {
      %3 = affine.load %arg2[0, %arg3, %c0] : memref<1x4x4xf32>
      affine.store %3, %2[0, %arg3, %c0] : memref<1x4x4xf32>
      %4 = affine.apply #map0(%c0)
      %5 = affine.load %arg2[0, %arg3, %4] : memref<1x4x4xf32>
      affine.store %5, %2[0, %arg3, %4] : memref<1x4x4xf32>
      %6 = affine.apply #map1(%c0)
      %7 = affine.load %arg2[0, %arg3, %6] : memref<1x4x4xf32>
      affine.store %7, %2[0, %arg3, %6] : memref<1x4x4xf32>
      %8 = affine.apply #map2(%c0)
      %9 = affine.load %arg2[0, %arg3, %8] : memref<1x4x4xf32>
      affine.store %9, %2[0, %arg3, %8] : memref<1x4x4xf32>
    }
    affine.for %arg3 = 0 to 1 {
      affine.for %arg4 = 0 to 4 {
        affine.for %arg5 = 0 to 4 {
          %3 = affine.load %0[%arg3, %arg4, %c0] : memref<1x4x8xf32>
          %4 = affine.load %1[%arg3, %c0, %arg5] : memref<1x8x4xf32>
          %5 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %6 = arith.mulf %3, %4 : f32
          %7 = arith.addf %5, %6 : f32
          affine.store %7, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %8 = affine.apply #map0(%c0)
          %9 = affine.load %0[%arg3, %arg4, %8] : memref<1x4x8xf32>
          %10 = affine.load %1[%arg3, %8, %arg5] : memref<1x8x4xf32>
          %11 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %12 = arith.mulf %9, %10 : f32
          %13 = arith.addf %11, %12 : f32
          affine.store %13, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %14 = affine.apply #map1(%c0)
          %15 = affine.load %0[%arg3, %arg4, %14] : memref<1x4x8xf32>
          %16 = affine.load %1[%arg3, %14, %arg5] : memref<1x8x4xf32>
          %17 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %18 = arith.mulf %15, %16 : f32
          %19 = arith.addf %17, %18 : f32
          affine.store %19, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %20 = affine.apply #map2(%c0)
          %21 = affine.load %0[%arg3, %arg4, %20] : memref<1x4x8xf32>
          %22 = affine.load %1[%arg3, %20, %arg5] : memref<1x8x4xf32>
          %23 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %24 = arith.mulf %21, %22 : f32
          %25 = arith.addf %23, %24 : f32
          affine.store %25, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %26 = affine.apply #map3(%c0)
          %27 = affine.load %0[%arg3, %arg4, %26] : memref<1x4x8xf32>
          %28 = affine.load %1[%arg3, %26, %arg5] : memref<1x8x4xf32>
          %29 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %30 = arith.mulf %27, %28 : f32
          %31 = arith.addf %29, %30 : f32
          affine.store %31, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %32 = affine.apply #map4(%c0)
          %33 = affine.load %0[%arg3, %arg4, %32] : memref<1x4x8xf32>
          %34 = affine.load %1[%arg3, %32, %arg5] : memref<1x8x4xf32>
          %35 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %36 = arith.mulf %33, %34 : f32
          %37 = arith.addf %35, %36 : f32
          affine.store %37, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %38 = affine.apply #map5(%c0)
          %39 = affine.load %0[%arg3, %arg4, %38] : memref<1x4x8xf32>
          %40 = affine.load %1[%arg3, %38, %arg5] : memref<1x8x4xf32>
          %41 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %42 = arith.mulf %39, %40 : f32
          %43 = arith.addf %41, %42 : f32
          affine.store %43, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %44 = affine.apply #map6(%c0)
          %45 = affine.load %0[%arg3, %arg4, %44] : memref<1x4x8xf32>
          %46 = affine.load %1[%arg3, %44, %arg5] : memref<1x8x4xf32>
          %47 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %48 = arith.mulf %45, %46 : f32
          %49 = arith.addf %47, %48 : f32
          affine.store %49, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        }
      }
    }
    affine.for %arg3 = 0 to 4 {
      %3 = affine.load %2[0, %arg3, %c0] : memref<1x4x4xf32>
      affine.store %3, %arg2[0, %arg3, %c0] : memref<1x4x4xf32>
      %4 = affine.apply #map0(%c0)
      %5 = affine.load %2[0, %arg3, %4] : memref<1x4x4xf32>
      affine.store %5, %arg2[0, %arg3, %4] : memref<1x4x4xf32>
      %6 = affine.apply #map1(%c0)
      %7 = affine.load %2[0, %arg3, %6] : memref<1x4x4xf32>
      affine.store %7, %arg2[0, %arg3, %6] : memref<1x4x4xf32>
      %8 = affine.apply #map2(%c0)
      %9 = affine.load %2[0, %arg3, %8] : memref<1x4x4xf32>
      affine.store %9, %arg2[0, %arg3, %8] : memref<1x4x4xf32>
    }
    return
  }
}


// -----// IR Dump After AffineScalarReplacement //----- //
func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
  %c0 = arith.constant 0 : index
  cf.br ^bb1
^bb1:  // pred: ^bb0
  %0 = memref.alloca() : memref<1x4x8xf32>
  affine.for %arg3 = 0 to 4 {
    %3 = affine.load %arg0[0, %arg3, %c0] : memref<1x4x8xf32>
    affine.store %3, %0[0, %arg3, %c0] : memref<1x4x8xf32>
    %4 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0)
    %5 = affine.load %arg0[0, %arg3, %4] : memref<1x4x8xf32>
    affine.store %5, %0[0, %arg3, %4] : memref<1x4x8xf32>
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0)
    %7 = affine.load %arg0[0, %arg3, %6] : memref<1x4x8xf32>
    affine.store %7, %0[0, %arg3, %6] : memref<1x4x8xf32>
    %8 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0)
    %9 = affine.load %arg0[0, %arg3, %8] : memref<1x4x8xf32>
    affine.store %9, %0[0, %arg3, %8] : memref<1x4x8xf32>
    %10 = affine.apply affine_map<(d0) -> (d0 + 4)>(%c0)
    %11 = affine.load %arg0[0, %arg3, %10] : memref<1x4x8xf32>
    affine.store %11, %0[0, %arg3, %10] : memref<1x4x8xf32>
    %12 = affine.apply affine_map<(d0) -> (d0 + 5)>(%c0)
    %13 = affine.load %arg0[0, %arg3, %12] : memref<1x4x8xf32>
    affine.store %13, %0[0, %arg3, %12] : memref<1x4x8xf32>
    %14 = affine.apply affine_map<(d0) -> (d0 + 6)>(%c0)
    %15 = affine.load %arg0[0, %arg3, %14] : memref<1x4x8xf32>
    affine.store %15, %0[0, %arg3, %14] : memref<1x4x8xf32>
    %16 = affine.apply affine_map<(d0) -> (d0 + 7)>(%c0)
    %17 = affine.load %arg0[0, %arg3, %16] : memref<1x4x8xf32>
    affine.store %17, %0[0, %arg3, %16] : memref<1x4x8xf32>
  }
  %1 = memref.alloca() : memref<1x8x4xf32>
  affine.for %arg3 = 0 to 8 {
    %3 = affine.load %arg1[0, %arg3, %c0] : memref<1x8x4xf32>
    affine.store %3, %1[0, %arg3, %c0] : memref<1x8x4xf32>
    %4 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0)
    %5 = affine.load %arg1[0, %arg3, %4] : memref<1x8x4xf32>
    affine.store %5, %1[0, %arg3, %4] : memref<1x8x4xf32>
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0)
    %7 = affine.load %arg1[0, %arg3, %6] : memref<1x8x4xf32>
    affine.store %7, %1[0, %arg3, %6] : memref<1x8x4xf32>
    %8 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0)
    %9 = affine.load %arg1[0, %arg3, %8] : memref<1x8x4xf32>
    affine.store %9, %1[0, %arg3, %8] : memref<1x8x4xf32>
  }
  %2 = memref.alloca() : memref<1x4x4xf32>
  affine.for %arg3 = 0 to 4 {
    %3 = affine.load %arg2[0, %arg3, %c0] : memref<1x4x4xf32>
    affine.store %3, %2[0, %arg3, %c0] : memref<1x4x4xf32>
    %4 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0)
    %5 = affine.load %arg2[0, %arg3, %4] : memref<1x4x4xf32>
    affine.store %5, %2[0, %arg3, %4] : memref<1x4x4xf32>
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0)
    %7 = affine.load %arg2[0, %arg3, %6] : memref<1x4x4xf32>
    affine.store %7, %2[0, %arg3, %6] : memref<1x4x4xf32>
    %8 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0)
    %9 = affine.load %arg2[0, %arg3, %8] : memref<1x4x4xf32>
    affine.store %9, %2[0, %arg3, %8] : memref<1x4x4xf32>
  }
  affine.for %arg3 = 0 to 1 {
    affine.for %arg4 = 0 to 4 {
      affine.for %arg5 = 0 to 4 {
        %3 = affine.load %0[%arg3, %arg4, %c0] : memref<1x4x8xf32>
        %4 = affine.load %1[%arg3, %c0, %arg5] : memref<1x8x4xf32>
        %5 = affine.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        %6 = arith.mulf %3, %4 : f32
        %7 = arith.addf %5, %6 : f32
        %8 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0)
        %9 = affine.load %0[%arg3, %arg4, %8] : memref<1x4x8xf32>
        %10 = affine.load %1[%arg3, %8, %arg5] : memref<1x8x4xf32>
        %11 = arith.mulf %9, %10 : f32
        %12 = arith.addf %7, %11 : f32
        %13 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0)
        %14 = affine.load %0[%arg3, %arg4, %13] : memref<1x4x8xf32>
        %15 = affine.load %1[%arg3, %13, %arg5] : memref<1x8x4xf32>
        %16 = arith.mulf %14, %15 : f32
        %17 = arith.addf %12, %16 : f32
        %18 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0)
        %19 = affine.load %0[%arg3, %arg4, %18] : memref<1x4x8xf32>
        %20 = affine.load %1[%arg3, %18, %arg5] : memref<1x8x4xf32>
        %21 = arith.mulf %19, %20 : f32
        %22 = arith.addf %17, %21 : f32
        %23 = affine.apply affine_map<(d0) -> (d0 + 4)>(%c0)
        %24 = affine.load %0[%arg3, %arg4, %23] : memref<1x4x8xf32>
        %25 = affine.load %1[%arg3, %23, %arg5] : memref<1x8x4xf32>
        %26 = arith.mulf %24, %25 : f32
        %27 = arith.addf %22, %26 : f32
        %28 = affine.apply affine_map<(d0) -> (d0 + 5)>(%c0)
        %29 = affine.load %0[%arg3, %arg4, %28] : memref<1x4x8xf32>
        %30 = affine.load %1[%arg3, %28, %arg5] : memref<1x8x4xf32>
        %31 = arith.mulf %29, %30 : f32
        %32 = arith.addf %27, %31 : f32
        %33 = affine.apply affine_map<(d0) -> (d0 + 6)>(%c0)
        %34 = affine.load %0[%arg3, %arg4, %33] : memref<1x4x8xf32>
        %35 = affine.load %1[%arg3, %33, %arg5] : memref<1x8x4xf32>
        %36 = arith.mulf %34, %35 : f32
        %37 = arith.addf %32, %36 : f32
        %38 = affine.apply affine_map<(d0) -> (d0 + 7)>(%c0)
        %39 = affine.load %0[%arg3, %arg4, %38] : memref<1x4x8xf32>
        %40 = affine.load %1[%arg3, %38, %arg5] : memref<1x8x4xf32>
        %41 = arith.mulf %39, %40 : f32
        %42 = arith.addf %37, %41 : f32
        affine.store %42, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
      }
    }
  }
  affine.for %arg3 = 0 to 4 {
    %3 = affine.load %2[0, %arg3, %c0] : memref<1x4x4xf32>
    affine.store %3, %arg2[0, %arg3, %c0] : memref<1x4x4xf32>
    %4 = affine.apply affine_map<(d0) -> (d0 + 1)>(%c0)
    %5 = affine.load %2[0, %arg3, %4] : memref<1x4x4xf32>
    affine.store %5, %arg2[0, %arg3, %4] : memref<1x4x4xf32>
    %6 = affine.apply affine_map<(d0) -> (d0 + 2)>(%c0)
    %7 = affine.load %2[0, %arg3, %6] : memref<1x4x4xf32>
    affine.store %7, %arg2[0, %arg3, %6] : memref<1x4x4xf32>
    %8 = affine.apply affine_map<(d0) -> (d0 + 3)>(%c0)
    %9 = affine.load %2[0, %arg3, %8] : memref<1x4x4xf32>
    affine.store %9, %arg2[0, %arg3, %8] : memref<1x4x4xf32>
  }
  return
}

// -----// IR Dump After ConvertAffineToStandard //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %c0 = arith.constant 0 : index
    cf.br ^bb1
  ^bb1:  // pred: ^bb0
    %0 = memref.alloca() : memref<1x4x8xf32>
    %c0_0 = arith.constant 0 : index
    %c4 = arith.constant 4 : index
    %c1 = arith.constant 1 : index
    scf.for %arg3 = %c0_0 to %c4 step %c1 {
      %c0_12 = arith.constant 0 : index
      %3 = memref.load %arg0[%c0_12, %arg3, %c0] : memref<1x4x8xf32>
      %c0_13 = arith.constant 0 : index
      memref.store %3, %0[%c0_13, %arg3, %c0] : memref<1x4x8xf32>
      %c1_14 = arith.constant 1 : index
      %c0_15 = arith.constant 0 : index
      %4 = memref.load %arg0[%c0_15, %arg3, %c1_14] : memref<1x4x8xf32>
      %c0_16 = arith.constant 0 : index
      memref.store %4, %0[%c0_16, %arg3, %c1_14] : memref<1x4x8xf32>
      %c2 = arith.constant 2 : index
      %c0_17 = arith.constant 0 : index
      %5 = memref.load %arg0[%c0_17, %arg3, %c2] : memref<1x4x8xf32>
      %c0_18 = arith.constant 0 : index
      memref.store %5, %0[%c0_18, %arg3, %c2] : memref<1x4x8xf32>
      %c3 = arith.constant 3 : index
      %c0_19 = arith.constant 0 : index
      %6 = memref.load %arg0[%c0_19, %arg3, %c3] : memref<1x4x8xf32>
      %c0_20 = arith.constant 0 : index
      memref.store %6, %0[%c0_20, %arg3, %c3] : memref<1x4x8xf32>
      %c4_21 = arith.constant 4 : index
      %c0_22 = arith.constant 0 : index
      %7 = memref.load %arg0[%c0_22, %arg3, %c4_21] : memref<1x4x8xf32>
      %c0_23 = arith.constant 0 : index
      memref.store %7, %0[%c0_23, %arg3, %c4_21] : memref<1x4x8xf32>
      %c5 = arith.constant 5 : index
      %c0_24 = arith.constant 0 : index
      %8 = memref.load %arg0[%c0_24, %arg3, %c5] : memref<1x4x8xf32>
      %c0_25 = arith.constant 0 : index
      memref.store %8, %0[%c0_25, %arg3, %c5] : memref<1x4x8xf32>
      %c6 = arith.constant 6 : index
      %c0_26 = arith.constant 0 : index
      %9 = memref.load %arg0[%c0_26, %arg3, %c6] : memref<1x4x8xf32>
      %c0_27 = arith.constant 0 : index
      memref.store %9, %0[%c0_27, %arg3, %c6] : memref<1x4x8xf32>
      %c7 = arith.constant 7 : index
      %c0_28 = arith.constant 0 : index
      %10 = memref.load %arg0[%c0_28, %arg3, %c7] : memref<1x4x8xf32>
      %c0_29 = arith.constant 0 : index
      memref.store %10, %0[%c0_29, %arg3, %c7] : memref<1x4x8xf32>
    }
    %1 = memref.alloca() : memref<1x8x4xf32>
    %c0_1 = arith.constant 0 : index
    %c8 = arith.constant 8 : index
    %c1_2 = arith.constant 1 : index
    scf.for %arg3 = %c0_1 to %c8 step %c1_2 {
      %c0_12 = arith.constant 0 : index
      %3 = memref.load %arg1[%c0_12, %arg3, %c0] : memref<1x8x4xf32>
      %c0_13 = arith.constant 0 : index
      memref.store %3, %1[%c0_13, %arg3, %c0] : memref<1x8x4xf32>
      %c1_14 = arith.constant 1 : index
      %c0_15 = arith.constant 0 : index
      %4 = memref.load %arg1[%c0_15, %arg3, %c1_14] : memref<1x8x4xf32>
      %c0_16 = arith.constant 0 : index
      memref.store %4, %1[%c0_16, %arg3, %c1_14] : memref<1x8x4xf32>
      %c2 = arith.constant 2 : index
      %c0_17 = arith.constant 0 : index
      %5 = memref.load %arg1[%c0_17, %arg3, %c2] : memref<1x8x4xf32>
      %c0_18 = arith.constant 0 : index
      memref.store %5, %1[%c0_18, %arg3, %c2] : memref<1x8x4xf32>
      %c3 = arith.constant 3 : index
      %c0_19 = arith.constant 0 : index
      %6 = memref.load %arg1[%c0_19, %arg3, %c3] : memref<1x8x4xf32>
      %c0_20 = arith.constant 0 : index
      memref.store %6, %1[%c0_20, %arg3, %c3] : memref<1x8x4xf32>
    }
    %2 = memref.alloca() : memref<1x4x4xf32>
    %c0_3 = arith.constant 0 : index
    %c4_4 = arith.constant 4 : index
    %c1_5 = arith.constant 1 : index
    scf.for %arg3 = %c0_3 to %c4_4 step %c1_5 {
      %c0_12 = arith.constant 0 : index
      %3 = memref.load %arg2[%c0_12, %arg3, %c0] : memref<1x4x4xf32>
      %c0_13 = arith.constant 0 : index
      memref.store %3, %2[%c0_13, %arg3, %c0] : memref<1x4x4xf32>
      %c1_14 = arith.constant 1 : index
      %c0_15 = arith.constant 0 : index
      %4 = memref.load %arg2[%c0_15, %arg3, %c1_14] : memref<1x4x4xf32>
      %c0_16 = arith.constant 0 : index
      memref.store %4, %2[%c0_16, %arg3, %c1_14] : memref<1x4x4xf32>
      %c2 = arith.constant 2 : index
      %c0_17 = arith.constant 0 : index
      %5 = memref.load %arg2[%c0_17, %arg3, %c2] : memref<1x4x4xf32>
      %c0_18 = arith.constant 0 : index
      memref.store %5, %2[%c0_18, %arg3, %c2] : memref<1x4x4xf32>
      %c3 = arith.constant 3 : index
      %c0_19 = arith.constant 0 : index
      %6 = memref.load %arg2[%c0_19, %arg3, %c3] : memref<1x4x4xf32>
      %c0_20 = arith.constant 0 : index
      memref.store %6, %2[%c0_20, %arg3, %c3] : memref<1x4x4xf32>
    }
    %c0_6 = arith.constant 0 : index
    %c1_7 = arith.constant 1 : index
    %c1_8 = arith.constant 1 : index
    scf.for %arg3 = %c0_6 to %c1_7 step %c1_8 {
      %c0_12 = arith.constant 0 : index
      %c4_13 = arith.constant 4 : index
      %c1_14 = arith.constant 1 : index
      scf.for %arg4 = %c0_12 to %c4_13 step %c1_14 {
        %c0_15 = arith.constant 0 : index
        %c4_16 = arith.constant 4 : index
        %c1_17 = arith.constant 1 : index
        scf.for %arg5 = %c0_15 to %c4_16 step %c1_17 {
          %3 = memref.load %0[%arg3, %arg4, %c0] : memref<1x4x8xf32>
          %4 = memref.load %1[%arg3, %c0, %arg5] : memref<1x8x4xf32>
          %5 = memref.load %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
          %6 = arith.mulf %3, %4 : f32
          %7 = arith.addf %5, %6 : f32
          %c1_18 = arith.constant 1 : index
          %8 = memref.load %0[%arg3, %arg4, %c1_18] : memref<1x4x8xf32>
          %9 = memref.load %1[%arg3, %c1_18, %arg5] : memref<1x8x4xf32>
          %10 = arith.mulf %8, %9 : f32
          %11 = arith.addf %7, %10 : f32
          %c2 = arith.constant 2 : index
          %12 = memref.load %0[%arg3, %arg4, %c2] : memref<1x4x8xf32>
          %13 = memref.load %1[%arg3, %c2, %arg5] : memref<1x8x4xf32>
          %14 = arith.mulf %12, %13 : f32
          %15 = arith.addf %11, %14 : f32
          %c3 = arith.constant 3 : index
          %16 = memref.load %0[%arg3, %arg4, %c3] : memref<1x4x8xf32>
          %17 = memref.load %1[%arg3, %c3, %arg5] : memref<1x8x4xf32>
          %18 = arith.mulf %16, %17 : f32
          %19 = arith.addf %15, %18 : f32
          %c4_19 = arith.constant 4 : index
          %20 = memref.load %0[%arg3, %arg4, %c4_19] : memref<1x4x8xf32>
          %21 = memref.load %1[%arg3, %c4_19, %arg5] : memref<1x8x4xf32>
          %22 = arith.mulf %20, %21 : f32
          %23 = arith.addf %19, %22 : f32
          %c5 = arith.constant 5 : index
          %24 = memref.load %0[%arg3, %arg4, %c5] : memref<1x4x8xf32>
          %25 = memref.load %1[%arg3, %c5, %arg5] : memref<1x8x4xf32>
          %26 = arith.mulf %24, %25 : f32
          %27 = arith.addf %23, %26 : f32
          %c6 = arith.constant 6 : index
          %28 = memref.load %0[%arg3, %arg4, %c6] : memref<1x4x8xf32>
          %29 = memref.load %1[%arg3, %c6, %arg5] : memref<1x8x4xf32>
          %30 = arith.mulf %28, %29 : f32
          %31 = arith.addf %27, %30 : f32
          %c7 = arith.constant 7 : index
          %32 = memref.load %0[%arg3, %arg4, %c7] : memref<1x4x8xf32>
          %33 = memref.load %1[%arg3, %c7, %arg5] : memref<1x8x4xf32>
          %34 = arith.mulf %32, %33 : f32
          %35 = arith.addf %31, %34 : f32
          memref.store %35, %2[%arg3, %arg4, %arg5] : memref<1x4x4xf32>
        }
      }
    }
    %c0_9 = arith.constant 0 : index
    %c4_10 = arith.constant 4 : index
    %c1_11 = arith.constant 1 : index
    scf.for %arg3 = %c0_9 to %c4_10 step %c1_11 {
      %c0_12 = arith.constant 0 : index
      %3 = memref.load %2[%c0_12, %arg3, %c0] : memref<1x4x4xf32>
      %c0_13 = arith.constant 0 : index
      memref.store %3, %arg2[%c0_13, %arg3, %c0] : memref<1x4x4xf32>
      %c1_14 = arith.constant 1 : index
      %c0_15 = arith.constant 0 : index
      %4 = memref.load %2[%c0_15, %arg3, %c1_14] : memref<1x4x4xf32>
      %c0_16 = arith.constant 0 : index
      memref.store %4, %arg2[%c0_16, %arg3, %c1_14] : memref<1x4x4xf32>
      %c2 = arith.constant 2 : index
      %c0_17 = arith.constant 0 : index
      %5 = memref.load %2[%c0_17, %arg3, %c2] : memref<1x4x4xf32>
      %c0_18 = arith.constant 0 : index
      memref.store %5, %arg2[%c0_18, %arg3, %c2] : memref<1x4x4xf32>
      %c3 = arith.constant 3 : index
      %c0_19 = arith.constant 0 : index
      %6 = memref.load %2[%c0_19, %arg3, %c3] : memref<1x4x4xf32>
      %c0_20 = arith.constant 0 : index
      memref.store %6, %arg2[%c0_20, %arg3, %c3] : memref<1x4x4xf32>
    }
    return
  }
}


// -----// IR Dump After Canonicalizer //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %c1 = arith.constant 1 : index
    %c4 = arith.constant 4 : index
    %c0 = arith.constant 0 : index
    %c8 = arith.constant 8 : index
    %c7 = arith.constant 7 : index
    %c6 = arith.constant 6 : index
    %c5 = arith.constant 5 : index
    %c3 = arith.constant 3 : index
    %c2 = arith.constant 2 : index
    %0 = memref.alloca() : memref<1x4x8xf32>
    scf.for %arg3 = %c0 to %c4 step %c1 {
      %3 = memref.load %arg0[%c0, %arg3, %c0] : memref<1x4x8xf32>
      memref.store %3, %0[%c0, %arg3, %c0] : memref<1x4x8xf32>
      %4 = memref.load %arg0[%c0, %arg3, %c1] : memref<1x4x8xf32>
      memref.store %4, %0[%c0, %arg3, %c1] : memref<1x4x8xf32>
      %5 = memref.load %arg0[%c0, %arg3, %c2] : memref<1x4x8xf32>
      memref.store %5, %0[%c0, %arg3, %c2] : memref<1x4x8xf32>
      %6 = memref.load %arg0[%c0, %arg3, %c3] : memref<1x4x8xf32>
      memref.store %6, %0[%c0, %arg3, %c3] : memref<1x4x8xf32>
      %7 = memref.load %arg0[%c0, %arg3, %c4] : memref<1x4x8xf32>
      memref.store %7, %0[%c0, %arg3, %c4] : memref<1x4x8xf32>
      %8 = memref.load %arg0[%c0, %arg3, %c5] : memref<1x4x8xf32>
      memref.store %8, %0[%c0, %arg3, %c5] : memref<1x4x8xf32>
      %9 = memref.load %arg0[%c0, %arg3, %c6] : memref<1x4x8xf32>
      memref.store %9, %0[%c0, %arg3, %c6] : memref<1x4x8xf32>
      %10 = memref.load %arg0[%c0, %arg3, %c7] : memref<1x4x8xf32>
      memref.store %10, %0[%c0, %arg3, %c7] : memref<1x4x8xf32>
    }
    %1 = memref.alloca() : memref<1x8x4xf32>
    scf.for %arg3 = %c0 to %c8 step %c1 {
      %3 = memref.load %arg1[%c0, %arg3, %c0] : memref<1x8x4xf32>
      memref.store %3, %1[%c0, %arg3, %c0] : memref<1x8x4xf32>
      %4 = memref.load %arg1[%c0, %arg3, %c1] : memref<1x8x4xf32>
      memref.store %4, %1[%c0, %arg3, %c1] : memref<1x8x4xf32>
      %5 = memref.load %arg1[%c0, %arg3, %c2] : memref<1x8x4xf32>
      memref.store %5, %1[%c0, %arg3, %c2] : memref<1x8x4xf32>
      %6 = memref.load %arg1[%c0, %arg3, %c3] : memref<1x8x4xf32>
      memref.store %6, %1[%c0, %arg3, %c3] : memref<1x8x4xf32>
    }
    %2 = memref.alloca() : memref<1x4x4xf32>
    scf.for %arg3 = %c0 to %c4 step %c1 {
      %3 = memref.load %arg2[%c0, %arg3, %c0] : memref<1x4x4xf32>
      memref.store %3, %2[%c0, %arg3, %c0] : memref<1x4x4xf32>
      %4 = memref.load %arg2[%c0, %arg3, %c1] : memref<1x4x4xf32>
      memref.store %4, %2[%c0, %arg3, %c1] : memref<1x4x4xf32>
      %5 = memref.load %arg2[%c0, %arg3, %c2] : memref<1x4x4xf32>
      memref.store %5, %2[%c0, %arg3, %c2] : memref<1x4x4xf32>
      %6 = memref.load %arg2[%c0, %arg3, %c3] : memref<1x4x4xf32>
      memref.store %6, %2[%c0, %arg3, %c3] : memref<1x4x4xf32>
    }
    scf.for %arg3 = %c0 to %c4 step %c1 {
      scf.for %arg4 = %c0 to %c4 step %c1 {
        %3 = memref.load %0[%c0, %arg3, %c0] : memref<1x4x8xf32>
        %4 = memref.load %1[%c0, %c0, %arg4] : memref<1x8x4xf32>
        %5 = memref.load %2[%c0, %arg3, %arg4] : memref<1x4x4xf32>
        %6 = arith.mulf %3, %4 : f32
        %7 = arith.addf %5, %6 : f32
        %8 = memref.load %0[%c0, %arg3, %c1] : memref<1x4x8xf32>
        %9 = memref.load %1[%c0, %c1, %arg4] : memref<1x8x4xf32>
        %10 = arith.mulf %8, %9 : f32
        %11 = arith.addf %7, %10 : f32
        %12 = memref.load %0[%c0, %arg3, %c2] : memref<1x4x8xf32>
        %13 = memref.load %1[%c0, %c2, %arg4] : memref<1x8x4xf32>
        %14 = arith.mulf %12, %13 : f32
        %15 = arith.addf %11, %14 : f32
        %16 = memref.load %0[%c0, %arg3, %c3] : memref<1x4x8xf32>
        %17 = memref.load %1[%c0, %c3, %arg4] : memref<1x8x4xf32>
        %18 = arith.mulf %16, %17 : f32
        %19 = arith.addf %15, %18 : f32
        %20 = memref.load %0[%c0, %arg3, %c4] : memref<1x4x8xf32>
        %21 = memref.load %1[%c0, %c4, %arg4] : memref<1x8x4xf32>
        %22 = arith.mulf %20, %21 : f32
        %23 = arith.addf %19, %22 : f32
        %24 = memref.load %0[%c0, %arg3, %c5] : memref<1x4x8xf32>
        %25 = memref.load %1[%c0, %c5, %arg4] : memref<1x8x4xf32>
        %26 = arith.mulf %24, %25 : f32
        %27 = arith.addf %23, %26 : f32
        %28 = memref.load %0[%c0, %arg3, %c6] : memref<1x4x8xf32>
        %29 = memref.load %1[%c0, %c6, %arg4] : memref<1x8x4xf32>
        %30 = arith.mulf %28, %29 : f32
        %31 = arith.addf %27, %30 : f32
        %32 = memref.load %0[%c0, %arg3, %c7] : memref<1x4x8xf32>
        %33 = memref.load %1[%c0, %c7, %arg4] : memref<1x8x4xf32>
        %34 = arith.mulf %32, %33 : f32
        %35 = arith.addf %31, %34 : f32
        memref.store %35, %2[%c0, %arg3, %arg4] : memref<1x4x4xf32>
      }
    }
    scf.for %arg3 = %c0 to %c4 step %c1 {
      %3 = memref.load %2[%c0, %arg3, %c0] : memref<1x4x4xf32>
      memref.store %3, %arg2[%c0, %arg3, %c0] : memref<1x4x4xf32>
      %4 = memref.load %2[%c0, %arg3, %c1] : memref<1x4x4xf32>
      memref.store %4, %arg2[%c0, %arg3, %c1] : memref<1x4x4xf32>
      %5 = memref.load %2[%c0, %arg3, %c2] : memref<1x4x4xf32>
      memref.store %5, %arg2[%c0, %arg3, %c2] : memref<1x4x4xf32>
      %6 = memref.load %2[%c0, %arg3, %c3] : memref<1x4x4xf32>
      memref.store %6, %arg2[%c0, %arg3, %c3] : memref<1x4x4xf32>
    }
    return
  }
}


// -----// IR Dump After CSE //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %c1 = arith.constant 1 : index
    %c4 = arith.constant 4 : index
    %c0 = arith.constant 0 : index
    %c8 = arith.constant 8 : index
    %c7 = arith.constant 7 : index
    %c6 = arith.constant 6 : index
    %c5 = arith.constant 5 : index
    %c3 = arith.constant 3 : index
    %c2 = arith.constant 2 : index
    %0 = memref.alloca() : memref<1x4x8xf32>
    scf.for %arg3 = %c0 to %c4 step %c1 {
      %3 = memref.load %arg0[%c0, %arg3, %c0] : memref<1x4x8xf32>
      memref.store %3, %0[%c0, %arg3, %c0] : memref<1x4x8xf32>
      %4 = memref.load %arg0[%c0, %arg3, %c1] : memref<1x4x8xf32>
      memref.store %4, %0[%c0, %arg3, %c1] : memref<1x4x8xf32>
      %5 = memref.load %arg0[%c0, %arg3, %c2] : memref<1x4x8xf32>
      memref.store %5, %0[%c0, %arg3, %c2] : memref<1x4x8xf32>
      %6 = memref.load %arg0[%c0, %arg3, %c3] : memref<1x4x8xf32>
      memref.store %6, %0[%c0, %arg3, %c3] : memref<1x4x8xf32>
      %7 = memref.load %arg0[%c0, %arg3, %c4] : memref<1x4x8xf32>
      memref.store %7, %0[%c0, %arg3, %c4] : memref<1x4x8xf32>
      %8 = memref.load %arg0[%c0, %arg3, %c5] : memref<1x4x8xf32>
      memref.store %8, %0[%c0, %arg3, %c5] : memref<1x4x8xf32>
      %9 = memref.load %arg0[%c0, %arg3, %c6] : memref<1x4x8xf32>
      memref.store %9, %0[%c0, %arg3, %c6] : memref<1x4x8xf32>
      %10 = memref.load %arg0[%c0, %arg3, %c7] : memref<1x4x8xf32>
      memref.store %10, %0[%c0, %arg3, %c7] : memref<1x4x8xf32>
    }
    %1 = memref.alloca() : memref<1x8x4xf32>
    scf.for %arg3 = %c0 to %c8 step %c1 {
      %3 = memref.load %arg1[%c0, %arg3, %c0] : memref<1x8x4xf32>
      memref.store %3, %1[%c0, %arg3, %c0] : memref<1x8x4xf32>
      %4 = memref.load %arg1[%c0, %arg3, %c1] : memref<1x8x4xf32>
      memref.store %4, %1[%c0, %arg3, %c1] : memref<1x8x4xf32>
      %5 = memref.load %arg1[%c0, %arg3, %c2] : memref<1x8x4xf32>
      memref.store %5, %1[%c0, %arg3, %c2] : memref<1x8x4xf32>
      %6 = memref.load %arg1[%c0, %arg3, %c3] : memref<1x8x4xf32>
      memref.store %6, %1[%c0, %arg3, %c3] : memref<1x8x4xf32>
    }
    %2 = memref.alloca() : memref<1x4x4xf32>
    scf.for %arg3 = %c0 to %c4 step %c1 {
      %3 = memref.load %arg2[%c0, %arg3, %c0] : memref<1x4x4xf32>
      memref.store %3, %2[%c0, %arg3, %c0] : memref<1x4x4xf32>
      %4 = memref.load %arg2[%c0, %arg3, %c1] : memref<1x4x4xf32>
      memref.store %4, %2[%c0, %arg3, %c1] : memref<1x4x4xf32>
      %5 = memref.load %arg2[%c0, %arg3, %c2] : memref<1x4x4xf32>
      memref.store %5, %2[%c0, %arg3, %c2] : memref<1x4x4xf32>
      %6 = memref.load %arg2[%c0, %arg3, %c3] : memref<1x4x4xf32>
      memref.store %6, %2[%c0, %arg3, %c3] : memref<1x4x4xf32>
    }
    scf.for %arg3 = %c0 to %c4 step %c1 {
      scf.for %arg4 = %c0 to %c4 step %c1 {
        %3 = memref.load %0[%c0, %arg3, %c0] : memref<1x4x8xf32>
        %4 = memref.load %1[%c0, %c0, %arg4] : memref<1x8x4xf32>
        %5 = memref.load %2[%c0, %arg3, %arg4] : memref<1x4x4xf32>
        %6 = arith.mulf %3, %4 : f32
        %7 = arith.addf %5, %6 : f32
        %8 = memref.load %0[%c0, %arg3, %c1] : memref<1x4x8xf32>
        %9 = memref.load %1[%c0, %c1, %arg4] : memref<1x8x4xf32>
        %10 = arith.mulf %8, %9 : f32
        %11 = arith.addf %7, %10 : f32
        %12 = memref.load %0[%c0, %arg3, %c2] : memref<1x4x8xf32>
        %13 = memref.load %1[%c0, %c2, %arg4] : memref<1x8x4xf32>
        %14 = arith.mulf %12, %13 : f32
        %15 = arith.addf %11, %14 : f32
        %16 = memref.load %0[%c0, %arg3, %c3] : memref<1x4x8xf32>
        %17 = memref.load %1[%c0, %c3, %arg4] : memref<1x8x4xf32>
        %18 = arith.mulf %16, %17 : f32
        %19 = arith.addf %15, %18 : f32
        %20 = memref.load %0[%c0, %arg3, %c4] : memref<1x4x8xf32>
        %21 = memref.load %1[%c0, %c4, %arg4] : memref<1x8x4xf32>
        %22 = arith.mulf %20, %21 : f32
        %23 = arith.addf %19, %22 : f32
        %24 = memref.load %0[%c0, %arg3, %c5] : memref<1x4x8xf32>
        %25 = memref.load %1[%c0, %c5, %arg4] : memref<1x8x4xf32>
        %26 = arith.mulf %24, %25 : f32
        %27 = arith.addf %23, %26 : f32
        %28 = memref.load %0[%c0, %arg3, %c6] : memref<1x4x8xf32>
        %29 = memref.load %1[%c0, %c6, %arg4] : memref<1x8x4xf32>
        %30 = arith.mulf %28, %29 : f32
        %31 = arith.addf %27, %30 : f32
        %32 = memref.load %0[%c0, %arg3, %c7] : memref<1x4x8xf32>
        %33 = memref.load %1[%c0, %c7, %arg4] : memref<1x8x4xf32>
        %34 = arith.mulf %32, %33 : f32
        %35 = arith.addf %31, %34 : f32
        memref.store %35, %2[%c0, %arg3, %arg4] : memref<1x4x4xf32>
      }
    }
    scf.for %arg3 = %c0 to %c4 step %c1 {
      %3 = memref.load %2[%c0, %arg3, %c0] : memref<1x4x4xf32>
      memref.store %3, %arg2[%c0, %arg3, %c0] : memref<1x4x4xf32>
      %4 = memref.load %2[%c0, %arg3, %c1] : memref<1x4x4xf32>
      memref.store %4, %arg2[%c0, %arg3, %c1] : memref<1x4x4xf32>
      %5 = memref.load %2[%c0, %arg3, %c2] : memref<1x4x4xf32>
      memref.store %5, %arg2[%c0, %arg3, %c2] : memref<1x4x4xf32>
      %6 = memref.load %2[%c0, %arg3, %c3] : memref<1x4x4xf32>
      memref.store %6, %arg2[%c0, %arg3, %c3] : memref<1x4x4xf32>
    }
    return
  }
}


// -----// IR Dump After SCFToControlFlow //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %c1 = arith.constant 1 : index
    %c4 = arith.constant 4 : index
    %c0 = arith.constant 0 : index
    %c8 = arith.constant 8 : index
    %c7 = arith.constant 7 : index
    %c6 = arith.constant 6 : index
    %c5 = arith.constant 5 : index
    %c3 = arith.constant 3 : index
    %c2 = arith.constant 2 : index
    %0 = memref.alloca() : memref<1x4x8xf32>
    cf.br ^bb1(%c0 : index)
  ^bb1(%1: index):  // 2 preds: ^bb0, ^bb2
    %2 = arith.cmpi slt, %1, %c4 : index
    cf.cond_br %2, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %3 = memref.load %arg0[%c0, %1, %c0] : memref<1x4x8xf32>
    memref.store %3, %0[%c0, %1, %c0] : memref<1x4x8xf32>
    %4 = memref.load %arg0[%c0, %1, %c1] : memref<1x4x8xf32>
    memref.store %4, %0[%c0, %1, %c1] : memref<1x4x8xf32>
    %5 = memref.load %arg0[%c0, %1, %c2] : memref<1x4x8xf32>
    memref.store %5, %0[%c0, %1, %c2] : memref<1x4x8xf32>
    %6 = memref.load %arg0[%c0, %1, %c3] : memref<1x4x8xf32>
    memref.store %6, %0[%c0, %1, %c3] : memref<1x4x8xf32>
    %7 = memref.load %arg0[%c0, %1, %c4] : memref<1x4x8xf32>
    memref.store %7, %0[%c0, %1, %c4] : memref<1x4x8xf32>
    %8 = memref.load %arg0[%c0, %1, %c5] : memref<1x4x8xf32>
    memref.store %8, %0[%c0, %1, %c5] : memref<1x4x8xf32>
    %9 = memref.load %arg0[%c0, %1, %c6] : memref<1x4x8xf32>
    memref.store %9, %0[%c0, %1, %c6] : memref<1x4x8xf32>
    %10 = memref.load %arg0[%c0, %1, %c7] : memref<1x4x8xf32>
    memref.store %10, %0[%c0, %1, %c7] : memref<1x4x8xf32>
    %11 = arith.addi %1, %c1 : index
    cf.br ^bb1(%11 : index)
  ^bb3:  // pred: ^bb1
    %12 = memref.alloca() : memref<1x8x4xf32>
    cf.br ^bb4(%c0 : index)
  ^bb4(%13: index):  // 2 preds: ^bb3, ^bb5
    %14 = arith.cmpi slt, %13, %c8 : index
    cf.cond_br %14, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %15 = memref.load %arg1[%c0, %13, %c0] : memref<1x8x4xf32>
    memref.store %15, %12[%c0, %13, %c0] : memref<1x8x4xf32>
    %16 = memref.load %arg1[%c0, %13, %c1] : memref<1x8x4xf32>
    memref.store %16, %12[%c0, %13, %c1] : memref<1x8x4xf32>
    %17 = memref.load %arg1[%c0, %13, %c2] : memref<1x8x4xf32>
    memref.store %17, %12[%c0, %13, %c2] : memref<1x8x4xf32>
    %18 = memref.load %arg1[%c0, %13, %c3] : memref<1x8x4xf32>
    memref.store %18, %12[%c0, %13, %c3] : memref<1x8x4xf32>
    %19 = arith.addi %13, %c1 : index
    cf.br ^bb4(%19 : index)
  ^bb6:  // pred: ^bb4
    %20 = memref.alloca() : memref<1x4x4xf32>
    cf.br ^bb7(%c0 : index)
  ^bb7(%21: index):  // 2 preds: ^bb6, ^bb8
    %22 = arith.cmpi slt, %21, %c4 : index
    cf.cond_br %22, ^bb8, ^bb9
  ^bb8:  // pred: ^bb7
    %23 = memref.load %arg2[%c0, %21, %c0] : memref<1x4x4xf32>
    memref.store %23, %20[%c0, %21, %c0] : memref<1x4x4xf32>
    %24 = memref.load %arg2[%c0, %21, %c1] : memref<1x4x4xf32>
    memref.store %24, %20[%c0, %21, %c1] : memref<1x4x4xf32>
    %25 = memref.load %arg2[%c0, %21, %c2] : memref<1x4x4xf32>
    memref.store %25, %20[%c0, %21, %c2] : memref<1x4x4xf32>
    %26 = memref.load %arg2[%c0, %21, %c3] : memref<1x4x4xf32>
    memref.store %26, %20[%c0, %21, %c3] : memref<1x4x4xf32>
    %27 = arith.addi %21, %c1 : index
    cf.br ^bb7(%27 : index)
  ^bb9:  // pred: ^bb7
    cf.br ^bb10(%c0 : index)
  ^bb10(%28: index):  // 2 preds: ^bb9, ^bb14
    %29 = arith.cmpi slt, %28, %c4 : index
    cf.cond_br %29, ^bb11, ^bb15
  ^bb11:  // pred: ^bb10
    cf.br ^bb12(%c0 : index)
  ^bb12(%30: index):  // 2 preds: ^bb11, ^bb13
    %31 = arith.cmpi slt, %30, %c4 : index
    cf.cond_br %31, ^bb13, ^bb14
  ^bb13:  // pred: ^bb12
    %32 = memref.load %0[%c0, %28, %c0] : memref<1x4x8xf32>
    %33 = memref.load %12[%c0, %c0, %30] : memref<1x8x4xf32>
    %34 = memref.load %20[%c0, %28, %30] : memref<1x4x4xf32>
    %35 = arith.mulf %32, %33 : f32
    %36 = arith.addf %34, %35 : f32
    %37 = memref.load %0[%c0, %28, %c1] : memref<1x4x8xf32>
    %38 = memref.load %12[%c0, %c1, %30] : memref<1x8x4xf32>
    %39 = arith.mulf %37, %38 : f32
    %40 = arith.addf %36, %39 : f32
    %41 = memref.load %0[%c0, %28, %c2] : memref<1x4x8xf32>
    %42 = memref.load %12[%c0, %c2, %30] : memref<1x8x4xf32>
    %43 = arith.mulf %41, %42 : f32
    %44 = arith.addf %40, %43 : f32
    %45 = memref.load %0[%c0, %28, %c3] : memref<1x4x8xf32>
    %46 = memref.load %12[%c0, %c3, %30] : memref<1x8x4xf32>
    %47 = arith.mulf %45, %46 : f32
    %48 = arith.addf %44, %47 : f32
    %49 = memref.load %0[%c0, %28, %c4] : memref<1x4x8xf32>
    %50 = memref.load %12[%c0, %c4, %30] : memref<1x8x4xf32>
    %51 = arith.mulf %49, %50 : f32
    %52 = arith.addf %48, %51 : f32
    %53 = memref.load %0[%c0, %28, %c5] : memref<1x4x8xf32>
    %54 = memref.load %12[%c0, %c5, %30] : memref<1x8x4xf32>
    %55 = arith.mulf %53, %54 : f32
    %56 = arith.addf %52, %55 : f32
    %57 = memref.load %0[%c0, %28, %c6] : memref<1x4x8xf32>
    %58 = memref.load %12[%c0, %c6, %30] : memref<1x8x4xf32>
    %59 = arith.mulf %57, %58 : f32
    %60 = arith.addf %56, %59 : f32
    %61 = memref.load %0[%c0, %28, %c7] : memref<1x4x8xf32>
    %62 = memref.load %12[%c0, %c7, %30] : memref<1x8x4xf32>
    %63 = arith.mulf %61, %62 : f32
    %64 = arith.addf %60, %63 : f32
    memref.store %64, %20[%c0, %28, %30] : memref<1x4x4xf32>
    %65 = arith.addi %30, %c1 : index
    cf.br ^bb12(%65 : index)
  ^bb14:  // pred: ^bb12
    %66 = arith.addi %28, %c1 : index
    cf.br ^bb10(%66 : index)
  ^bb15:  // pred: ^bb10
    cf.br ^bb16(%c0 : index)
  ^bb16(%67: index):  // 2 preds: ^bb15, ^bb17
    %68 = arith.cmpi slt, %67, %c4 : index
    cf.cond_br %68, ^bb17, ^bb18
  ^bb17:  // pred: ^bb16
    %69 = memref.load %20[%c0, %67, %c0] : memref<1x4x4xf32>
    memref.store %69, %arg2[%c0, %67, %c0] : memref<1x4x4xf32>
    %70 = memref.load %20[%c0, %67, %c1] : memref<1x4x4xf32>
    memref.store %70, %arg2[%c0, %67, %c1] : memref<1x4x4xf32>
    %71 = memref.load %20[%c0, %67, %c2] : memref<1x4x4xf32>
    memref.store %71, %arg2[%c0, %67, %c2] : memref<1x4x4xf32>
    %72 = memref.load %20[%c0, %67, %c3] : memref<1x4x4xf32>
    memref.store %72, %arg2[%c0, %67, %c3] : memref<1x4x4xf32>
    %73 = arith.addi %67, %c1 : index
    cf.br ^bb16(%73 : index)
  ^bb18:  // pred: ^bb16
    return
  }
}


// -----// IR Dump After Canonicalizer //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %c2 = arith.constant 2 : index
    %c3 = arith.constant 3 : index
    %c5 = arith.constant 5 : index
    %c6 = arith.constant 6 : index
    %c7 = arith.constant 7 : index
    %c8 = arith.constant 8 : index
    %c0 = arith.constant 0 : index
    %c4 = arith.constant 4 : index
    %c1 = arith.constant 1 : index
    %0 = memref.alloca() : memref<1x4x8xf32>
    cf.br ^bb1(%c0 : index)
  ^bb1(%1: index):  // 2 preds: ^bb0, ^bb2
    %2 = arith.cmpi slt, %1, %c4 : index
    cf.cond_br %2, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %3 = memref.load %arg0[%c0, %1, %c0] : memref<1x4x8xf32>
    memref.store %3, %0[%c0, %1, %c0] : memref<1x4x8xf32>
    %4 = memref.load %arg0[%c0, %1, %c1] : memref<1x4x8xf32>
    memref.store %4, %0[%c0, %1, %c1] : memref<1x4x8xf32>
    %5 = memref.load %arg0[%c0, %1, %c2] : memref<1x4x8xf32>
    memref.store %5, %0[%c0, %1, %c2] : memref<1x4x8xf32>
    %6 = memref.load %arg0[%c0, %1, %c3] : memref<1x4x8xf32>
    memref.store %6, %0[%c0, %1, %c3] : memref<1x4x8xf32>
    %7 = memref.load %arg0[%c0, %1, %c4] : memref<1x4x8xf32>
    memref.store %7, %0[%c0, %1, %c4] : memref<1x4x8xf32>
    %8 = memref.load %arg0[%c0, %1, %c5] : memref<1x4x8xf32>
    memref.store %8, %0[%c0, %1, %c5] : memref<1x4x8xf32>
    %9 = memref.load %arg0[%c0, %1, %c6] : memref<1x4x8xf32>
    memref.store %9, %0[%c0, %1, %c6] : memref<1x4x8xf32>
    %10 = memref.load %arg0[%c0, %1, %c7] : memref<1x4x8xf32>
    memref.store %10, %0[%c0, %1, %c7] : memref<1x4x8xf32>
    %11 = arith.addi %1, %c1 : index
    cf.br ^bb1(%11 : index)
  ^bb3:  // pred: ^bb1
    %12 = memref.alloca() : memref<1x8x4xf32>
    cf.br ^bb4(%c0 : index)
  ^bb4(%13: index):  // 2 preds: ^bb3, ^bb5
    %14 = arith.cmpi slt, %13, %c8 : index
    cf.cond_br %14, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %15 = memref.load %arg1[%c0, %13, %c0] : memref<1x8x4xf32>
    memref.store %15, %12[%c0, %13, %c0] : memref<1x8x4xf32>
    %16 = memref.load %arg1[%c0, %13, %c1] : memref<1x8x4xf32>
    memref.store %16, %12[%c0, %13, %c1] : memref<1x8x4xf32>
    %17 = memref.load %arg1[%c0, %13, %c2] : memref<1x8x4xf32>
    memref.store %17, %12[%c0, %13, %c2] : memref<1x8x4xf32>
    %18 = memref.load %arg1[%c0, %13, %c3] : memref<1x8x4xf32>
    memref.store %18, %12[%c0, %13, %c3] : memref<1x8x4xf32>
    %19 = arith.addi %13, %c1 : index
    cf.br ^bb4(%19 : index)
  ^bb6:  // pred: ^bb4
    %20 = memref.alloca() : memref<1x4x4xf32>
    cf.br ^bb7(%c0 : index)
  ^bb7(%21: index):  // 2 preds: ^bb6, ^bb8
    %22 = arith.cmpi slt, %21, %c4 : index
    cf.cond_br %22, ^bb8, ^bb9(%c0 : index)
  ^bb8:  // pred: ^bb7
    %23 = memref.load %arg2[%c0, %21, %c0] : memref<1x4x4xf32>
    memref.store %23, %20[%c0, %21, %c0] : memref<1x4x4xf32>
    %24 = memref.load %arg2[%c0, %21, %c1] : memref<1x4x4xf32>
    memref.store %24, %20[%c0, %21, %c1] : memref<1x4x4xf32>
    %25 = memref.load %arg2[%c0, %21, %c2] : memref<1x4x4xf32>
    memref.store %25, %20[%c0, %21, %c2] : memref<1x4x4xf32>
    %26 = memref.load %arg2[%c0, %21, %c3] : memref<1x4x4xf32>
    memref.store %26, %20[%c0, %21, %c3] : memref<1x4x4xf32>
    %27 = arith.addi %21, %c1 : index
    cf.br ^bb7(%27 : index)
  ^bb9(%28: index):  // 2 preds: ^bb7, ^bb12
    %29 = arith.cmpi slt, %28, %c4 : index
    cf.cond_br %29, ^bb10(%c0 : index), ^bb13(%c0 : index)
  ^bb10(%30: index):  // 2 preds: ^bb9, ^bb11
    %31 = arith.cmpi slt, %30, %c4 : index
    cf.cond_br %31, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %32 = memref.load %0[%c0, %28, %c0] : memref<1x4x8xf32>
    %33 = memref.load %12[%c0, %c0, %30] : memref<1x8x4xf32>
    %34 = memref.load %20[%c0, %28, %30] : memref<1x4x4xf32>
    %35 = arith.mulf %32, %33 : f32
    %36 = arith.addf %34, %35 : f32
    %37 = memref.load %0[%c0, %28, %c1] : memref<1x4x8xf32>
    %38 = memref.load %12[%c0, %c1, %30] : memref<1x8x4xf32>
    %39 = arith.mulf %37, %38 : f32
    %40 = arith.addf %36, %39 : f32
    %41 = memref.load %0[%c0, %28, %c2] : memref<1x4x8xf32>
    %42 = memref.load %12[%c0, %c2, %30] : memref<1x8x4xf32>
    %43 = arith.mulf %41, %42 : f32
    %44 = arith.addf %40, %43 : f32
    %45 = memref.load %0[%c0, %28, %c3] : memref<1x4x8xf32>
    %46 = memref.load %12[%c0, %c3, %30] : memref<1x8x4xf32>
    %47 = arith.mulf %45, %46 : f32
    %48 = arith.addf %44, %47 : f32
    %49 = memref.load %0[%c0, %28, %c4] : memref<1x4x8xf32>
    %50 = memref.load %12[%c0, %c4, %30] : memref<1x8x4xf32>
    %51 = arith.mulf %49, %50 : f32
    %52 = arith.addf %48, %51 : f32
    %53 = memref.load %0[%c0, %28, %c5] : memref<1x4x8xf32>
    %54 = memref.load %12[%c0, %c5, %30] : memref<1x8x4xf32>
    %55 = arith.mulf %53, %54 : f32
    %56 = arith.addf %52, %55 : f32
    %57 = memref.load %0[%c0, %28, %c6] : memref<1x4x8xf32>
    %58 = memref.load %12[%c0, %c6, %30] : memref<1x8x4xf32>
    %59 = arith.mulf %57, %58 : f32
    %60 = arith.addf %56, %59 : f32
    %61 = memref.load %0[%c0, %28, %c7] : memref<1x4x8xf32>
    %62 = memref.load %12[%c0, %c7, %30] : memref<1x8x4xf32>
    %63 = arith.mulf %61, %62 : f32
    %64 = arith.addf %60, %63 : f32
    memref.store %64, %20[%c0, %28, %30] : memref<1x4x4xf32>
    %65 = arith.addi %30, %c1 : index
    cf.br ^bb10(%65 : index)
  ^bb12:  // pred: ^bb10
    %66 = arith.addi %28, %c1 : index
    cf.br ^bb9(%66 : index)
  ^bb13(%67: index):  // 2 preds: ^bb9, ^bb14
    %68 = arith.cmpi slt, %67, %c4 : index
    cf.cond_br %68, ^bb14, ^bb15
  ^bb14:  // pred: ^bb13
    %69 = memref.load %20[%c0, %67, %c0] : memref<1x4x4xf32>
    memref.store %69, %arg2[%c0, %67, %c0] : memref<1x4x4xf32>
    %70 = memref.load %20[%c0, %67, %c1] : memref<1x4x4xf32>
    memref.store %70, %arg2[%c0, %67, %c1] : memref<1x4x4xf32>
    %71 = memref.load %20[%c0, %67, %c2] : memref<1x4x4xf32>
    memref.store %71, %arg2[%c0, %67, %c2] : memref<1x4x4xf32>
    %72 = memref.load %20[%c0, %67, %c3] : memref<1x4x4xf32>
    memref.store %72, %arg2[%c0, %67, %c3] : memref<1x4x4xf32>
    %73 = arith.addi %67, %c1 : index
    cf.br ^bb13(%73 : index)
  ^bb15:  // pred: ^bb13
    return
  }
}


// -----// IR Dump After CSE //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %c2 = arith.constant 2 : index
    %c3 = arith.constant 3 : index
    %c5 = arith.constant 5 : index
    %c6 = arith.constant 6 : index
    %c7 = arith.constant 7 : index
    %c8 = arith.constant 8 : index
    %c0 = arith.constant 0 : index
    %c4 = arith.constant 4 : index
    %c1 = arith.constant 1 : index
    %0 = memref.alloca() : memref<1x4x8xf32>
    cf.br ^bb1(%c0 : index)
  ^bb1(%1: index):  // 2 preds: ^bb0, ^bb2
    %2 = arith.cmpi slt, %1, %c4 : index
    cf.cond_br %2, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %3 = memref.load %arg0[%c0, %1, %c0] : memref<1x4x8xf32>
    memref.store %3, %0[%c0, %1, %c0] : memref<1x4x8xf32>
    %4 = memref.load %arg0[%c0, %1, %c1] : memref<1x4x8xf32>
    memref.store %4, %0[%c0, %1, %c1] : memref<1x4x8xf32>
    %5 = memref.load %arg0[%c0, %1, %c2] : memref<1x4x8xf32>
    memref.store %5, %0[%c0, %1, %c2] : memref<1x4x8xf32>
    %6 = memref.load %arg0[%c0, %1, %c3] : memref<1x4x8xf32>
    memref.store %6, %0[%c0, %1, %c3] : memref<1x4x8xf32>
    %7 = memref.load %arg0[%c0, %1, %c4] : memref<1x4x8xf32>
    memref.store %7, %0[%c0, %1, %c4] : memref<1x4x8xf32>
    %8 = memref.load %arg0[%c0, %1, %c5] : memref<1x4x8xf32>
    memref.store %8, %0[%c0, %1, %c5] : memref<1x4x8xf32>
    %9 = memref.load %arg0[%c0, %1, %c6] : memref<1x4x8xf32>
    memref.store %9, %0[%c0, %1, %c6] : memref<1x4x8xf32>
    %10 = memref.load %arg0[%c0, %1, %c7] : memref<1x4x8xf32>
    memref.store %10, %0[%c0, %1, %c7] : memref<1x4x8xf32>
    %11 = arith.addi %1, %c1 : index
    cf.br ^bb1(%11 : index)
  ^bb3:  // pred: ^bb1
    %12 = memref.alloca() : memref<1x8x4xf32>
    cf.br ^bb4(%c0 : index)
  ^bb4(%13: index):  // 2 preds: ^bb3, ^bb5
    %14 = arith.cmpi slt, %13, %c8 : index
    cf.cond_br %14, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %15 = memref.load %arg1[%c0, %13, %c0] : memref<1x8x4xf32>
    memref.store %15, %12[%c0, %13, %c0] : memref<1x8x4xf32>
    %16 = memref.load %arg1[%c0, %13, %c1] : memref<1x8x4xf32>
    memref.store %16, %12[%c0, %13, %c1] : memref<1x8x4xf32>
    %17 = memref.load %arg1[%c0, %13, %c2] : memref<1x8x4xf32>
    memref.store %17, %12[%c0, %13, %c2] : memref<1x8x4xf32>
    %18 = memref.load %arg1[%c0, %13, %c3] : memref<1x8x4xf32>
    memref.store %18, %12[%c0, %13, %c3] : memref<1x8x4xf32>
    %19 = arith.addi %13, %c1 : index
    cf.br ^bb4(%19 : index)
  ^bb6:  // pred: ^bb4
    %20 = memref.alloca() : memref<1x4x4xf32>
    cf.br ^bb7(%c0 : index)
  ^bb7(%21: index):  // 2 preds: ^bb6, ^bb8
    %22 = arith.cmpi slt, %21, %c4 : index
    cf.cond_br %22, ^bb8, ^bb9(%c0 : index)
  ^bb8:  // pred: ^bb7
    %23 = memref.load %arg2[%c0, %21, %c0] : memref<1x4x4xf32>
    memref.store %23, %20[%c0, %21, %c0] : memref<1x4x4xf32>
    %24 = memref.load %arg2[%c0, %21, %c1] : memref<1x4x4xf32>
    memref.store %24, %20[%c0, %21, %c1] : memref<1x4x4xf32>
    %25 = memref.load %arg2[%c0, %21, %c2] : memref<1x4x4xf32>
    memref.store %25, %20[%c0, %21, %c2] : memref<1x4x4xf32>
    %26 = memref.load %arg2[%c0, %21, %c3] : memref<1x4x4xf32>
    memref.store %26, %20[%c0, %21, %c3] : memref<1x4x4xf32>
    %27 = arith.addi %21, %c1 : index
    cf.br ^bb7(%27 : index)
  ^bb9(%28: index):  // 2 preds: ^bb7, ^bb12
    %29 = arith.cmpi slt, %28, %c4 : index
    cf.cond_br %29, ^bb10(%c0 : index), ^bb13(%c0 : index)
  ^bb10(%30: index):  // 2 preds: ^bb9, ^bb11
    %31 = arith.cmpi slt, %30, %c4 : index
    cf.cond_br %31, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %32 = memref.load %0[%c0, %28, %c0] : memref<1x4x8xf32>
    %33 = memref.load %12[%c0, %c0, %30] : memref<1x8x4xf32>
    %34 = memref.load %20[%c0, %28, %30] : memref<1x4x4xf32>
    %35 = arith.mulf %32, %33 : f32
    %36 = arith.addf %34, %35 : f32
    %37 = memref.load %0[%c0, %28, %c1] : memref<1x4x8xf32>
    %38 = memref.load %12[%c0, %c1, %30] : memref<1x8x4xf32>
    %39 = arith.mulf %37, %38 : f32
    %40 = arith.addf %36, %39 : f32
    %41 = memref.load %0[%c0, %28, %c2] : memref<1x4x8xf32>
    %42 = memref.load %12[%c0, %c2, %30] : memref<1x8x4xf32>
    %43 = arith.mulf %41, %42 : f32
    %44 = arith.addf %40, %43 : f32
    %45 = memref.load %0[%c0, %28, %c3] : memref<1x4x8xf32>
    %46 = memref.load %12[%c0, %c3, %30] : memref<1x8x4xf32>
    %47 = arith.mulf %45, %46 : f32
    %48 = arith.addf %44, %47 : f32
    %49 = memref.load %0[%c0, %28, %c4] : memref<1x4x8xf32>
    %50 = memref.load %12[%c0, %c4, %30] : memref<1x8x4xf32>
    %51 = arith.mulf %49, %50 : f32
    %52 = arith.addf %48, %51 : f32
    %53 = memref.load %0[%c0, %28, %c5] : memref<1x4x8xf32>
    %54 = memref.load %12[%c0, %c5, %30] : memref<1x8x4xf32>
    %55 = arith.mulf %53, %54 : f32
    %56 = arith.addf %52, %55 : f32
    %57 = memref.load %0[%c0, %28, %c6] : memref<1x4x8xf32>
    %58 = memref.load %12[%c0, %c6, %30] : memref<1x8x4xf32>
    %59 = arith.mulf %57, %58 : f32
    %60 = arith.addf %56, %59 : f32
    %61 = memref.load %0[%c0, %28, %c7] : memref<1x4x8xf32>
    %62 = memref.load %12[%c0, %c7, %30] : memref<1x8x4xf32>
    %63 = arith.mulf %61, %62 : f32
    %64 = arith.addf %60, %63 : f32
    memref.store %64, %20[%c0, %28, %30] : memref<1x4x4xf32>
    %65 = arith.addi %30, %c1 : index
    cf.br ^bb10(%65 : index)
  ^bb12:  // pred: ^bb10
    %66 = arith.addi %28, %c1 : index
    cf.br ^bb9(%66 : index)
  ^bb13(%67: index):  // 2 preds: ^bb9, ^bb14
    %68 = arith.cmpi slt, %67, %c4 : index
    cf.cond_br %68, ^bb14, ^bb15
  ^bb14:  // pred: ^bb13
    %69 = memref.load %20[%c0, %67, %c0] : memref<1x4x4xf32>
    memref.store %69, %arg2[%c0, %67, %c0] : memref<1x4x4xf32>
    %70 = memref.load %20[%c0, %67, %c1] : memref<1x4x4xf32>
    memref.store %70, %arg2[%c0, %67, %c1] : memref<1x4x4xf32>
    %71 = memref.load %20[%c0, %67, %c2] : memref<1x4x4xf32>
    memref.store %71, %arg2[%c0, %67, %c2] : memref<1x4x4xf32>
    %72 = memref.load %20[%c0, %67, %c3] : memref<1x4x4xf32>
    memref.store %72, %arg2[%c0, %67, %c3] : memref<1x4x4xf32>
    %73 = arith.addi %67, %c1 : index
    cf.br ^bb13(%73 : index)
  ^bb15:  // pred: ^bb13
    return
  }
}


// -----// IR Dump After ConvertMemRefToLLVM //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<1x4x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<1x8x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg0 : memref<1x4x8xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %c2 = arith.constant 2 : index
    %3 = builtin.unrealized_conversion_cast %c2 : index to i64
    %c3 = arith.constant 3 : index
    %4 = builtin.unrealized_conversion_cast %c3 : index to i64
    %c5 = arith.constant 5 : index
    %5 = builtin.unrealized_conversion_cast %c5 : index to i64
    %c6 = arith.constant 6 : index
    %6 = builtin.unrealized_conversion_cast %c6 : index to i64
    %c7 = arith.constant 7 : index
    %7 = builtin.unrealized_conversion_cast %c7 : index to i64
    %c8 = arith.constant 8 : index
    %c0 = arith.constant 0 : index
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %c4 = arith.constant 4 : index
    %9 = builtin.unrealized_conversion_cast %c4 : index to i64
    %c1 = arith.constant 1 : index
    %10 = builtin.unrealized_conversion_cast %c1 : index to i64
    %11 = llvm.mlir.constant(1 : index) : i64
    %12 = llvm.mlir.constant(4 : index) : i64
    %13 = llvm.mlir.constant(8 : index) : i64
    %14 = llvm.mlir.constant(1 : index) : i64
    %15 = llvm.mlir.constant(32 : index) : i64
    %16 = llvm.mlir.constant(32 : index) : i64
    %17 = llvm.mlir.null : !llvm.ptr<f32>
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %19 = llvm.ptrtoint %18 : !llvm.ptr<f32> to i64
    %20 = llvm.alloca %19 x f32 : (i64) -> !llvm.ptr<f32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %23 = llvm.insertvalue %20, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %24 = llvm.mlir.constant(0 : index) : i64
    %25 = llvm.insertvalue %24, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %26 = llvm.insertvalue %11, %25[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %27 = llvm.insertvalue %12, %26[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %28 = llvm.insertvalue %13, %27[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %29 = llvm.insertvalue %15, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %30 = llvm.insertvalue %13, %29[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %31 = llvm.insertvalue %14, %30[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb1(%c0 : index)
  ^bb1(%32: index):  // 2 preds: ^bb0, ^bb2
    %33 = builtin.unrealized_conversion_cast %32 : index to i64
    %34 = arith.cmpi slt, %32, %c4 : index
    cf.cond_br %34, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %35 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %36 = llvm.mlir.constant(32 : index) : i64
    %37 = llvm.mul %8, %36  : i64
    %38 = llvm.mlir.constant(8 : index) : i64
    %39 = llvm.mul %33, %38  : i64
    %40 = llvm.add %37, %39  : i64
    %41 = llvm.add %40, %8  : i64
    %42 = llvm.getelementptr %35[%41] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %43 = llvm.load %42 : !llvm.ptr<f32>
    %44 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %45 = llvm.mlir.constant(32 : index) : i64
    %46 = llvm.mul %8, %45  : i64
    %47 = llvm.mlir.constant(8 : index) : i64
    %48 = llvm.mul %33, %47  : i64
    %49 = llvm.add %46, %48  : i64
    %50 = llvm.add %49, %8  : i64
    %51 = llvm.getelementptr %44[%50] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %43, %51 : !llvm.ptr<f32>
    %52 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %53 = llvm.mlir.constant(32 : index) : i64
    %54 = llvm.mul %8, %53  : i64
    %55 = llvm.mlir.constant(8 : index) : i64
    %56 = llvm.mul %33, %55  : i64
    %57 = llvm.add %54, %56  : i64
    %58 = llvm.add %57, %10  : i64
    %59 = llvm.getelementptr %52[%58] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %60 = llvm.load %59 : !llvm.ptr<f32>
    %61 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %62 = llvm.mlir.constant(32 : index) : i64
    %63 = llvm.mul %8, %62  : i64
    %64 = llvm.mlir.constant(8 : index) : i64
    %65 = llvm.mul %33, %64  : i64
    %66 = llvm.add %63, %65  : i64
    %67 = llvm.add %66, %10  : i64
    %68 = llvm.getelementptr %61[%67] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %60, %68 : !llvm.ptr<f32>
    %69 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %70 = llvm.mlir.constant(32 : index) : i64
    %71 = llvm.mul %8, %70  : i64
    %72 = llvm.mlir.constant(8 : index) : i64
    %73 = llvm.mul %33, %72  : i64
    %74 = llvm.add %71, %73  : i64
    %75 = llvm.add %74, %3  : i64
    %76 = llvm.getelementptr %69[%75] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %77 = llvm.load %76 : !llvm.ptr<f32>
    %78 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %79 = llvm.mlir.constant(32 : index) : i64
    %80 = llvm.mul %8, %79  : i64
    %81 = llvm.mlir.constant(8 : index) : i64
    %82 = llvm.mul %33, %81  : i64
    %83 = llvm.add %80, %82  : i64
    %84 = llvm.add %83, %3  : i64
    %85 = llvm.getelementptr %78[%84] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %77, %85 : !llvm.ptr<f32>
    %86 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %87 = llvm.mlir.constant(32 : index) : i64
    %88 = llvm.mul %8, %87  : i64
    %89 = llvm.mlir.constant(8 : index) : i64
    %90 = llvm.mul %33, %89  : i64
    %91 = llvm.add %88, %90  : i64
    %92 = llvm.add %91, %4  : i64
    %93 = llvm.getelementptr %86[%92] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %94 = llvm.load %93 : !llvm.ptr<f32>
    %95 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %96 = llvm.mlir.constant(32 : index) : i64
    %97 = llvm.mul %8, %96  : i64
    %98 = llvm.mlir.constant(8 : index) : i64
    %99 = llvm.mul %33, %98  : i64
    %100 = llvm.add %97, %99  : i64
    %101 = llvm.add %100, %4  : i64
    %102 = llvm.getelementptr %95[%101] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %94, %102 : !llvm.ptr<f32>
    %103 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %104 = llvm.mlir.constant(32 : index) : i64
    %105 = llvm.mul %8, %104  : i64
    %106 = llvm.mlir.constant(8 : index) : i64
    %107 = llvm.mul %33, %106  : i64
    %108 = llvm.add %105, %107  : i64
    %109 = llvm.add %108, %9  : i64
    %110 = llvm.getelementptr %103[%109] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %111 = llvm.load %110 : !llvm.ptr<f32>
    %112 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %113 = llvm.mlir.constant(32 : index) : i64
    %114 = llvm.mul %8, %113  : i64
    %115 = llvm.mlir.constant(8 : index) : i64
    %116 = llvm.mul %33, %115  : i64
    %117 = llvm.add %114, %116  : i64
    %118 = llvm.add %117, %9  : i64
    %119 = llvm.getelementptr %112[%118] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %111, %119 : !llvm.ptr<f32>
    %120 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %121 = llvm.mlir.constant(32 : index) : i64
    %122 = llvm.mul %8, %121  : i64
    %123 = llvm.mlir.constant(8 : index) : i64
    %124 = llvm.mul %33, %123  : i64
    %125 = llvm.add %122, %124  : i64
    %126 = llvm.add %125, %5  : i64
    %127 = llvm.getelementptr %120[%126] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %128 = llvm.load %127 : !llvm.ptr<f32>
    %129 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %130 = llvm.mlir.constant(32 : index) : i64
    %131 = llvm.mul %8, %130  : i64
    %132 = llvm.mlir.constant(8 : index) : i64
    %133 = llvm.mul %33, %132  : i64
    %134 = llvm.add %131, %133  : i64
    %135 = llvm.add %134, %5  : i64
    %136 = llvm.getelementptr %129[%135] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %128, %136 : !llvm.ptr<f32>
    %137 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %138 = llvm.mlir.constant(32 : index) : i64
    %139 = llvm.mul %8, %138  : i64
    %140 = llvm.mlir.constant(8 : index) : i64
    %141 = llvm.mul %33, %140  : i64
    %142 = llvm.add %139, %141  : i64
    %143 = llvm.add %142, %6  : i64
    %144 = llvm.getelementptr %137[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %145 = llvm.load %144 : !llvm.ptr<f32>
    %146 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %147 = llvm.mlir.constant(32 : index) : i64
    %148 = llvm.mul %8, %147  : i64
    %149 = llvm.mlir.constant(8 : index) : i64
    %150 = llvm.mul %33, %149  : i64
    %151 = llvm.add %148, %150  : i64
    %152 = llvm.add %151, %6  : i64
    %153 = llvm.getelementptr %146[%152] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %145, %153 : !llvm.ptr<f32>
    %154 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %155 = llvm.mlir.constant(32 : index) : i64
    %156 = llvm.mul %8, %155  : i64
    %157 = llvm.mlir.constant(8 : index) : i64
    %158 = llvm.mul %33, %157  : i64
    %159 = llvm.add %156, %158  : i64
    %160 = llvm.add %159, %7  : i64
    %161 = llvm.getelementptr %154[%160] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %162 = llvm.load %161 : !llvm.ptr<f32>
    %163 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %164 = llvm.mlir.constant(32 : index) : i64
    %165 = llvm.mul %8, %164  : i64
    %166 = llvm.mlir.constant(8 : index) : i64
    %167 = llvm.mul %33, %166  : i64
    %168 = llvm.add %165, %167  : i64
    %169 = llvm.add %168, %7  : i64
    %170 = llvm.getelementptr %163[%169] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %162, %170 : !llvm.ptr<f32>
    %171 = arith.addi %32, %c1 : index
    cf.br ^bb1(%171 : index)
  ^bb3:  // pred: ^bb1
    %172 = llvm.mlir.constant(1 : index) : i64
    %173 = llvm.mlir.constant(8 : index) : i64
    %174 = llvm.mlir.constant(4 : index) : i64
    %175 = llvm.mlir.constant(1 : index) : i64
    %176 = llvm.mlir.constant(32 : index) : i64
    %177 = llvm.mlir.constant(32 : index) : i64
    %178 = llvm.mlir.null : !llvm.ptr<f32>
    %179 = llvm.getelementptr %178[%177] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %180 = llvm.ptrtoint %179 : !llvm.ptr<f32> to i64
    %181 = llvm.alloca %180 x f32 : (i64) -> !llvm.ptr<f32>
    %182 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %183 = llvm.insertvalue %181, %182[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %184 = llvm.insertvalue %181, %183[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %185 = llvm.mlir.constant(0 : index) : i64
    %186 = llvm.insertvalue %185, %184[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %187 = llvm.insertvalue %172, %186[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %188 = llvm.insertvalue %173, %187[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %189 = llvm.insertvalue %174, %188[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %190 = llvm.insertvalue %176, %189[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %191 = llvm.insertvalue %174, %190[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %192 = llvm.insertvalue %175, %191[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb4(%c0 : index)
  ^bb4(%193: index):  // 2 preds: ^bb3, ^bb5
    %194 = builtin.unrealized_conversion_cast %193 : index to i64
    %195 = arith.cmpi slt, %193, %c8 : index
    cf.cond_br %195, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %196 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %197 = llvm.mlir.constant(32 : index) : i64
    %198 = llvm.mul %8, %197  : i64
    %199 = llvm.mlir.constant(4 : index) : i64
    %200 = llvm.mul %194, %199  : i64
    %201 = llvm.add %198, %200  : i64
    %202 = llvm.add %201, %8  : i64
    %203 = llvm.getelementptr %196[%202] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %204 = llvm.load %203 : !llvm.ptr<f32>
    %205 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %206 = llvm.mlir.constant(32 : index) : i64
    %207 = llvm.mul %8, %206  : i64
    %208 = llvm.mlir.constant(4 : index) : i64
    %209 = llvm.mul %194, %208  : i64
    %210 = llvm.add %207, %209  : i64
    %211 = llvm.add %210, %8  : i64
    %212 = llvm.getelementptr %205[%211] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %204, %212 : !llvm.ptr<f32>
    %213 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %214 = llvm.mlir.constant(32 : index) : i64
    %215 = llvm.mul %8, %214  : i64
    %216 = llvm.mlir.constant(4 : index) : i64
    %217 = llvm.mul %194, %216  : i64
    %218 = llvm.add %215, %217  : i64
    %219 = llvm.add %218, %10  : i64
    %220 = llvm.getelementptr %213[%219] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %221 = llvm.load %220 : !llvm.ptr<f32>
    %222 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %223 = llvm.mlir.constant(32 : index) : i64
    %224 = llvm.mul %8, %223  : i64
    %225 = llvm.mlir.constant(4 : index) : i64
    %226 = llvm.mul %194, %225  : i64
    %227 = llvm.add %224, %226  : i64
    %228 = llvm.add %227, %10  : i64
    %229 = llvm.getelementptr %222[%228] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %221, %229 : !llvm.ptr<f32>
    %230 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %231 = llvm.mlir.constant(32 : index) : i64
    %232 = llvm.mul %8, %231  : i64
    %233 = llvm.mlir.constant(4 : index) : i64
    %234 = llvm.mul %194, %233  : i64
    %235 = llvm.add %232, %234  : i64
    %236 = llvm.add %235, %3  : i64
    %237 = llvm.getelementptr %230[%236] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %238 = llvm.load %237 : !llvm.ptr<f32>
    %239 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %240 = llvm.mlir.constant(32 : index) : i64
    %241 = llvm.mul %8, %240  : i64
    %242 = llvm.mlir.constant(4 : index) : i64
    %243 = llvm.mul %194, %242  : i64
    %244 = llvm.add %241, %243  : i64
    %245 = llvm.add %244, %3  : i64
    %246 = llvm.getelementptr %239[%245] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %238, %246 : !llvm.ptr<f32>
    %247 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %248 = llvm.mlir.constant(32 : index) : i64
    %249 = llvm.mul %8, %248  : i64
    %250 = llvm.mlir.constant(4 : index) : i64
    %251 = llvm.mul %194, %250  : i64
    %252 = llvm.add %249, %251  : i64
    %253 = llvm.add %252, %4  : i64
    %254 = llvm.getelementptr %247[%253] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %255 = llvm.load %254 : !llvm.ptr<f32>
    %256 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %257 = llvm.mlir.constant(32 : index) : i64
    %258 = llvm.mul %8, %257  : i64
    %259 = llvm.mlir.constant(4 : index) : i64
    %260 = llvm.mul %194, %259  : i64
    %261 = llvm.add %258, %260  : i64
    %262 = llvm.add %261, %4  : i64
    %263 = llvm.getelementptr %256[%262] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %255, %263 : !llvm.ptr<f32>
    %264 = arith.addi %193, %c1 : index
    cf.br ^bb4(%264 : index)
  ^bb6:  // pred: ^bb4
    %265 = llvm.mlir.constant(1 : index) : i64
    %266 = llvm.mlir.constant(4 : index) : i64
    %267 = llvm.mlir.constant(4 : index) : i64
    %268 = llvm.mlir.constant(1 : index) : i64
    %269 = llvm.mlir.constant(16 : index) : i64
    %270 = llvm.mlir.constant(16 : index) : i64
    %271 = llvm.mlir.null : !llvm.ptr<f32>
    %272 = llvm.getelementptr %271[%270] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %273 = llvm.ptrtoint %272 : !llvm.ptr<f32> to i64
    %274 = llvm.alloca %273 x f32 : (i64) -> !llvm.ptr<f32>
    %275 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %276 = llvm.insertvalue %274, %275[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %277 = llvm.insertvalue %274, %276[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %278 = llvm.mlir.constant(0 : index) : i64
    %279 = llvm.insertvalue %278, %277[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %280 = llvm.insertvalue %265, %279[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %281 = llvm.insertvalue %266, %280[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %282 = llvm.insertvalue %267, %281[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %283 = llvm.insertvalue %269, %282[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %284 = llvm.insertvalue %267, %283[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %285 = llvm.insertvalue %268, %284[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb7(%c0 : index)
  ^bb7(%286: index):  // 2 preds: ^bb6, ^bb8
    %287 = builtin.unrealized_conversion_cast %286 : index to i64
    %288 = arith.cmpi slt, %286, %c4 : index
    cf.cond_br %288, ^bb8, ^bb9(%c0 : index)
  ^bb8:  // pred: ^bb7
    %289 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %290 = llvm.mlir.constant(16 : index) : i64
    %291 = llvm.mul %8, %290  : i64
    %292 = llvm.mlir.constant(4 : index) : i64
    %293 = llvm.mul %287, %292  : i64
    %294 = llvm.add %291, %293  : i64
    %295 = llvm.add %294, %8  : i64
    %296 = llvm.getelementptr %289[%295] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %297 = llvm.load %296 : !llvm.ptr<f32>
    %298 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %299 = llvm.mlir.constant(16 : index) : i64
    %300 = llvm.mul %8, %299  : i64
    %301 = llvm.mlir.constant(4 : index) : i64
    %302 = llvm.mul %287, %301  : i64
    %303 = llvm.add %300, %302  : i64
    %304 = llvm.add %303, %8  : i64
    %305 = llvm.getelementptr %298[%304] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %297, %305 : !llvm.ptr<f32>
    %306 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %307 = llvm.mlir.constant(16 : index) : i64
    %308 = llvm.mul %8, %307  : i64
    %309 = llvm.mlir.constant(4 : index) : i64
    %310 = llvm.mul %287, %309  : i64
    %311 = llvm.add %308, %310  : i64
    %312 = llvm.add %311, %10  : i64
    %313 = llvm.getelementptr %306[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %314 = llvm.load %313 : !llvm.ptr<f32>
    %315 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %316 = llvm.mlir.constant(16 : index) : i64
    %317 = llvm.mul %8, %316  : i64
    %318 = llvm.mlir.constant(4 : index) : i64
    %319 = llvm.mul %287, %318  : i64
    %320 = llvm.add %317, %319  : i64
    %321 = llvm.add %320, %10  : i64
    %322 = llvm.getelementptr %315[%321] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %314, %322 : !llvm.ptr<f32>
    %323 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %324 = llvm.mlir.constant(16 : index) : i64
    %325 = llvm.mul %8, %324  : i64
    %326 = llvm.mlir.constant(4 : index) : i64
    %327 = llvm.mul %287, %326  : i64
    %328 = llvm.add %325, %327  : i64
    %329 = llvm.add %328, %3  : i64
    %330 = llvm.getelementptr %323[%329] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %331 = llvm.load %330 : !llvm.ptr<f32>
    %332 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %333 = llvm.mlir.constant(16 : index) : i64
    %334 = llvm.mul %8, %333  : i64
    %335 = llvm.mlir.constant(4 : index) : i64
    %336 = llvm.mul %287, %335  : i64
    %337 = llvm.add %334, %336  : i64
    %338 = llvm.add %337, %3  : i64
    %339 = llvm.getelementptr %332[%338] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %331, %339 : !llvm.ptr<f32>
    %340 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %341 = llvm.mlir.constant(16 : index) : i64
    %342 = llvm.mul %8, %341  : i64
    %343 = llvm.mlir.constant(4 : index) : i64
    %344 = llvm.mul %287, %343  : i64
    %345 = llvm.add %342, %344  : i64
    %346 = llvm.add %345, %4  : i64
    %347 = llvm.getelementptr %340[%346] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %348 = llvm.load %347 : !llvm.ptr<f32>
    %349 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %350 = llvm.mlir.constant(16 : index) : i64
    %351 = llvm.mul %8, %350  : i64
    %352 = llvm.mlir.constant(4 : index) : i64
    %353 = llvm.mul %287, %352  : i64
    %354 = llvm.add %351, %353  : i64
    %355 = llvm.add %354, %4  : i64
    %356 = llvm.getelementptr %349[%355] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %348, %356 : !llvm.ptr<f32>
    %357 = arith.addi %286, %c1 : index
    cf.br ^bb7(%357 : index)
  ^bb9(%358: index):  // 2 preds: ^bb7, ^bb12
    %359 = builtin.unrealized_conversion_cast %358 : index to i64
    %360 = arith.cmpi slt, %358, %c4 : index
    cf.cond_br %360, ^bb10(%c0 : index), ^bb13(%c0 : index)
  ^bb10(%361: index):  // 2 preds: ^bb9, ^bb11
    %362 = builtin.unrealized_conversion_cast %361 : index to i64
    %363 = arith.cmpi slt, %361, %c4 : index
    cf.cond_br %363, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %364 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %365 = llvm.mlir.constant(32 : index) : i64
    %366 = llvm.mul %8, %365  : i64
    %367 = llvm.mlir.constant(8 : index) : i64
    %368 = llvm.mul %359, %367  : i64
    %369 = llvm.add %366, %368  : i64
    %370 = llvm.add %369, %8  : i64
    %371 = llvm.getelementptr %364[%370] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %372 = llvm.load %371 : !llvm.ptr<f32>
    %373 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %374 = llvm.mlir.constant(32 : index) : i64
    %375 = llvm.mul %8, %374  : i64
    %376 = llvm.mlir.constant(4 : index) : i64
    %377 = llvm.mul %8, %376  : i64
    %378 = llvm.add %375, %377  : i64
    %379 = llvm.add %378, %362  : i64
    %380 = llvm.getelementptr %373[%379] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %381 = llvm.load %380 : !llvm.ptr<f32>
    %382 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %383 = llvm.mlir.constant(16 : index) : i64
    %384 = llvm.mul %8, %383  : i64
    %385 = llvm.mlir.constant(4 : index) : i64
    %386 = llvm.mul %359, %385  : i64
    %387 = llvm.add %384, %386  : i64
    %388 = llvm.add %387, %362  : i64
    %389 = llvm.getelementptr %382[%388] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %390 = llvm.load %389 : !llvm.ptr<f32>
    %391 = arith.mulf %372, %381 : f32
    %392 = arith.addf %390, %391 : f32
    %393 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %394 = llvm.mlir.constant(32 : index) : i64
    %395 = llvm.mul %8, %394  : i64
    %396 = llvm.mlir.constant(8 : index) : i64
    %397 = llvm.mul %359, %396  : i64
    %398 = llvm.add %395, %397  : i64
    %399 = llvm.add %398, %10  : i64
    %400 = llvm.getelementptr %393[%399] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %401 = llvm.load %400 : !llvm.ptr<f32>
    %402 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %403 = llvm.mlir.constant(32 : index) : i64
    %404 = llvm.mul %8, %403  : i64
    %405 = llvm.mlir.constant(4 : index) : i64
    %406 = llvm.mul %10, %405  : i64
    %407 = llvm.add %404, %406  : i64
    %408 = llvm.add %407, %362  : i64
    %409 = llvm.getelementptr %402[%408] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %410 = llvm.load %409 : !llvm.ptr<f32>
    %411 = arith.mulf %401, %410 : f32
    %412 = arith.addf %392, %411 : f32
    %413 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %414 = llvm.mlir.constant(32 : index) : i64
    %415 = llvm.mul %8, %414  : i64
    %416 = llvm.mlir.constant(8 : index) : i64
    %417 = llvm.mul %359, %416  : i64
    %418 = llvm.add %415, %417  : i64
    %419 = llvm.add %418, %3  : i64
    %420 = llvm.getelementptr %413[%419] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %421 = llvm.load %420 : !llvm.ptr<f32>
    %422 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %423 = llvm.mlir.constant(32 : index) : i64
    %424 = llvm.mul %8, %423  : i64
    %425 = llvm.mlir.constant(4 : index) : i64
    %426 = llvm.mul %3, %425  : i64
    %427 = llvm.add %424, %426  : i64
    %428 = llvm.add %427, %362  : i64
    %429 = llvm.getelementptr %422[%428] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %430 = llvm.load %429 : !llvm.ptr<f32>
    %431 = arith.mulf %421, %430 : f32
    %432 = arith.addf %412, %431 : f32
    %433 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %434 = llvm.mlir.constant(32 : index) : i64
    %435 = llvm.mul %8, %434  : i64
    %436 = llvm.mlir.constant(8 : index) : i64
    %437 = llvm.mul %359, %436  : i64
    %438 = llvm.add %435, %437  : i64
    %439 = llvm.add %438, %4  : i64
    %440 = llvm.getelementptr %433[%439] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %441 = llvm.load %440 : !llvm.ptr<f32>
    %442 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %443 = llvm.mlir.constant(32 : index) : i64
    %444 = llvm.mul %8, %443  : i64
    %445 = llvm.mlir.constant(4 : index) : i64
    %446 = llvm.mul %4, %445  : i64
    %447 = llvm.add %444, %446  : i64
    %448 = llvm.add %447, %362  : i64
    %449 = llvm.getelementptr %442[%448] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %450 = llvm.load %449 : !llvm.ptr<f32>
    %451 = arith.mulf %441, %450 : f32
    %452 = arith.addf %432, %451 : f32
    %453 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %454 = llvm.mlir.constant(32 : index) : i64
    %455 = llvm.mul %8, %454  : i64
    %456 = llvm.mlir.constant(8 : index) : i64
    %457 = llvm.mul %359, %456  : i64
    %458 = llvm.add %455, %457  : i64
    %459 = llvm.add %458, %9  : i64
    %460 = llvm.getelementptr %453[%459] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %461 = llvm.load %460 : !llvm.ptr<f32>
    %462 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %463 = llvm.mlir.constant(32 : index) : i64
    %464 = llvm.mul %8, %463  : i64
    %465 = llvm.mlir.constant(4 : index) : i64
    %466 = llvm.mul %9, %465  : i64
    %467 = llvm.add %464, %466  : i64
    %468 = llvm.add %467, %362  : i64
    %469 = llvm.getelementptr %462[%468] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %470 = llvm.load %469 : !llvm.ptr<f32>
    %471 = arith.mulf %461, %470 : f32
    %472 = arith.addf %452, %471 : f32
    %473 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %474 = llvm.mlir.constant(32 : index) : i64
    %475 = llvm.mul %8, %474  : i64
    %476 = llvm.mlir.constant(8 : index) : i64
    %477 = llvm.mul %359, %476  : i64
    %478 = llvm.add %475, %477  : i64
    %479 = llvm.add %478, %5  : i64
    %480 = llvm.getelementptr %473[%479] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %481 = llvm.load %480 : !llvm.ptr<f32>
    %482 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %483 = llvm.mlir.constant(32 : index) : i64
    %484 = llvm.mul %8, %483  : i64
    %485 = llvm.mlir.constant(4 : index) : i64
    %486 = llvm.mul %5, %485  : i64
    %487 = llvm.add %484, %486  : i64
    %488 = llvm.add %487, %362  : i64
    %489 = llvm.getelementptr %482[%488] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %490 = llvm.load %489 : !llvm.ptr<f32>
    %491 = arith.mulf %481, %490 : f32
    %492 = arith.addf %472, %491 : f32
    %493 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %494 = llvm.mlir.constant(32 : index) : i64
    %495 = llvm.mul %8, %494  : i64
    %496 = llvm.mlir.constant(8 : index) : i64
    %497 = llvm.mul %359, %496  : i64
    %498 = llvm.add %495, %497  : i64
    %499 = llvm.add %498, %6  : i64
    %500 = llvm.getelementptr %493[%499] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %501 = llvm.load %500 : !llvm.ptr<f32>
    %502 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %503 = llvm.mlir.constant(32 : index) : i64
    %504 = llvm.mul %8, %503  : i64
    %505 = llvm.mlir.constant(4 : index) : i64
    %506 = llvm.mul %6, %505  : i64
    %507 = llvm.add %504, %506  : i64
    %508 = llvm.add %507, %362  : i64
    %509 = llvm.getelementptr %502[%508] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %510 = llvm.load %509 : !llvm.ptr<f32>
    %511 = arith.mulf %501, %510 : f32
    %512 = arith.addf %492, %511 : f32
    %513 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %514 = llvm.mlir.constant(32 : index) : i64
    %515 = llvm.mul %8, %514  : i64
    %516 = llvm.mlir.constant(8 : index) : i64
    %517 = llvm.mul %359, %516  : i64
    %518 = llvm.add %515, %517  : i64
    %519 = llvm.add %518, %7  : i64
    %520 = llvm.getelementptr %513[%519] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %521 = llvm.load %520 : !llvm.ptr<f32>
    %522 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %523 = llvm.mlir.constant(32 : index) : i64
    %524 = llvm.mul %8, %523  : i64
    %525 = llvm.mlir.constant(4 : index) : i64
    %526 = llvm.mul %7, %525  : i64
    %527 = llvm.add %524, %526  : i64
    %528 = llvm.add %527, %362  : i64
    %529 = llvm.getelementptr %522[%528] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %530 = llvm.load %529 : !llvm.ptr<f32>
    %531 = arith.mulf %521, %530 : f32
    %532 = arith.addf %512, %531 : f32
    %533 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %534 = llvm.mlir.constant(16 : index) : i64
    %535 = llvm.mul %8, %534  : i64
    %536 = llvm.mlir.constant(4 : index) : i64
    %537 = llvm.mul %359, %536  : i64
    %538 = llvm.add %535, %537  : i64
    %539 = llvm.add %538, %362  : i64
    %540 = llvm.getelementptr %533[%539] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %532, %540 : !llvm.ptr<f32>
    %541 = arith.addi %361, %c1 : index
    cf.br ^bb10(%541 : index)
  ^bb12:  // pred: ^bb10
    %542 = arith.addi %358, %c1 : index
    cf.br ^bb9(%542 : index)
  ^bb13(%543: index):  // 2 preds: ^bb9, ^bb14
    %544 = builtin.unrealized_conversion_cast %543 : index to i64
    %545 = arith.cmpi slt, %543, %c4 : index
    cf.cond_br %545, ^bb14, ^bb15
  ^bb14:  // pred: ^bb13
    %546 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %547 = llvm.mlir.constant(16 : index) : i64
    %548 = llvm.mul %8, %547  : i64
    %549 = llvm.mlir.constant(4 : index) : i64
    %550 = llvm.mul %544, %549  : i64
    %551 = llvm.add %548, %550  : i64
    %552 = llvm.add %551, %8  : i64
    %553 = llvm.getelementptr %546[%552] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %554 = llvm.load %553 : !llvm.ptr<f32>
    %555 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %556 = llvm.mlir.constant(16 : index) : i64
    %557 = llvm.mul %8, %556  : i64
    %558 = llvm.mlir.constant(4 : index) : i64
    %559 = llvm.mul %544, %558  : i64
    %560 = llvm.add %557, %559  : i64
    %561 = llvm.add %560, %8  : i64
    %562 = llvm.getelementptr %555[%561] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %554, %562 : !llvm.ptr<f32>
    %563 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %564 = llvm.mlir.constant(16 : index) : i64
    %565 = llvm.mul %8, %564  : i64
    %566 = llvm.mlir.constant(4 : index) : i64
    %567 = llvm.mul %544, %566  : i64
    %568 = llvm.add %565, %567  : i64
    %569 = llvm.add %568, %10  : i64
    %570 = llvm.getelementptr %563[%569] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %571 = llvm.load %570 : !llvm.ptr<f32>
    %572 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %573 = llvm.mlir.constant(16 : index) : i64
    %574 = llvm.mul %8, %573  : i64
    %575 = llvm.mlir.constant(4 : index) : i64
    %576 = llvm.mul %544, %575  : i64
    %577 = llvm.add %574, %576  : i64
    %578 = llvm.add %577, %10  : i64
    %579 = llvm.getelementptr %572[%578] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %571, %579 : !llvm.ptr<f32>
    %580 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %581 = llvm.mlir.constant(16 : index) : i64
    %582 = llvm.mul %8, %581  : i64
    %583 = llvm.mlir.constant(4 : index) : i64
    %584 = llvm.mul %544, %583  : i64
    %585 = llvm.add %582, %584  : i64
    %586 = llvm.add %585, %3  : i64
    %587 = llvm.getelementptr %580[%586] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %588 = llvm.load %587 : !llvm.ptr<f32>
    %589 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %590 = llvm.mlir.constant(16 : index) : i64
    %591 = llvm.mul %8, %590  : i64
    %592 = llvm.mlir.constant(4 : index) : i64
    %593 = llvm.mul %544, %592  : i64
    %594 = llvm.add %591, %593  : i64
    %595 = llvm.add %594, %3  : i64
    %596 = llvm.getelementptr %589[%595] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %588, %596 : !llvm.ptr<f32>
    %597 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %598 = llvm.mlir.constant(16 : index) : i64
    %599 = llvm.mul %8, %598  : i64
    %600 = llvm.mlir.constant(4 : index) : i64
    %601 = llvm.mul %544, %600  : i64
    %602 = llvm.add %599, %601  : i64
    %603 = llvm.add %602, %4  : i64
    %604 = llvm.getelementptr %597[%603] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %605 = llvm.load %604 : !llvm.ptr<f32>
    %606 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %607 = llvm.mlir.constant(16 : index) : i64
    %608 = llvm.mul %8, %607  : i64
    %609 = llvm.mlir.constant(4 : index) : i64
    %610 = llvm.mul %544, %609  : i64
    %611 = llvm.add %608, %610  : i64
    %612 = llvm.add %611, %4  : i64
    %613 = llvm.getelementptr %606[%612] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %605, %613 : !llvm.ptr<f32>
    %614 = arith.addi %543, %c1 : index
    cf.br ^bb13(%614 : index)
  ^bb15:  // pred: ^bb13
    return
  }
}


// -----// IR Dump After ConvertMathToLLVM //----- //
func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<1x4x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<1x8x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg0 : memref<1x4x8xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %c2 = arith.constant 2 : index
  %3 = builtin.unrealized_conversion_cast %c2 : index to i64
  %c3 = arith.constant 3 : index
  %4 = builtin.unrealized_conversion_cast %c3 : index to i64
  %c5 = arith.constant 5 : index
  %5 = builtin.unrealized_conversion_cast %c5 : index to i64
  %c6 = arith.constant 6 : index
  %6 = builtin.unrealized_conversion_cast %c6 : index to i64
  %c7 = arith.constant 7 : index
  %7 = builtin.unrealized_conversion_cast %c7 : index to i64
  %c8 = arith.constant 8 : index
  %c0 = arith.constant 0 : index
  %8 = builtin.unrealized_conversion_cast %c0 : index to i64
  %c4 = arith.constant 4 : index
  %9 = builtin.unrealized_conversion_cast %c4 : index to i64
  %c1 = arith.constant 1 : index
  %10 = builtin.unrealized_conversion_cast %c1 : index to i64
  %11 = llvm.mlir.constant(1 : index) : i64
  %12 = llvm.mlir.constant(4 : index) : i64
  %13 = llvm.mlir.constant(8 : index) : i64
  %14 = llvm.mlir.constant(1 : index) : i64
  %15 = llvm.mlir.constant(32 : index) : i64
  %16 = llvm.mlir.constant(32 : index) : i64
  %17 = llvm.mlir.null : !llvm.ptr<f32>
  %18 = llvm.getelementptr %17[%16] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %19 = llvm.ptrtoint %18 : !llvm.ptr<f32> to i64
  %20 = llvm.alloca %19 x f32 : (i64) -> !llvm.ptr<f32>
  %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %23 = llvm.insertvalue %20, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %24 = llvm.mlir.constant(0 : index) : i64
  %25 = llvm.insertvalue %24, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %26 = llvm.insertvalue %11, %25[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %27 = llvm.insertvalue %12, %26[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %28 = llvm.insertvalue %13, %27[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %29 = llvm.insertvalue %15, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %30 = llvm.insertvalue %13, %29[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %31 = llvm.insertvalue %14, %30[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb1(%c0 : index)
^bb1(%32: index):  // 2 preds: ^bb0, ^bb2
  %33 = builtin.unrealized_conversion_cast %32 : index to i64
  %34 = arith.cmpi slt, %32, %c4 : index
  cf.cond_br %34, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %35 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %36 = llvm.mlir.constant(32 : index) : i64
  %37 = llvm.mul %8, %36  : i64
  %38 = llvm.mlir.constant(8 : index) : i64
  %39 = llvm.mul %33, %38  : i64
  %40 = llvm.add %37, %39  : i64
  %41 = llvm.add %40, %8  : i64
  %42 = llvm.getelementptr %35[%41] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %43 = llvm.load %42 : !llvm.ptr<f32>
  %44 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %45 = llvm.mlir.constant(32 : index) : i64
  %46 = llvm.mul %8, %45  : i64
  %47 = llvm.mlir.constant(8 : index) : i64
  %48 = llvm.mul %33, %47  : i64
  %49 = llvm.add %46, %48  : i64
  %50 = llvm.add %49, %8  : i64
  %51 = llvm.getelementptr %44[%50] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %43, %51 : !llvm.ptr<f32>
  %52 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %53 = llvm.mlir.constant(32 : index) : i64
  %54 = llvm.mul %8, %53  : i64
  %55 = llvm.mlir.constant(8 : index) : i64
  %56 = llvm.mul %33, %55  : i64
  %57 = llvm.add %54, %56  : i64
  %58 = llvm.add %57, %10  : i64
  %59 = llvm.getelementptr %52[%58] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %60 = llvm.load %59 : !llvm.ptr<f32>
  %61 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %62 = llvm.mlir.constant(32 : index) : i64
  %63 = llvm.mul %8, %62  : i64
  %64 = llvm.mlir.constant(8 : index) : i64
  %65 = llvm.mul %33, %64  : i64
  %66 = llvm.add %63, %65  : i64
  %67 = llvm.add %66, %10  : i64
  %68 = llvm.getelementptr %61[%67] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %60, %68 : !llvm.ptr<f32>
  %69 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %70 = llvm.mlir.constant(32 : index) : i64
  %71 = llvm.mul %8, %70  : i64
  %72 = llvm.mlir.constant(8 : index) : i64
  %73 = llvm.mul %33, %72  : i64
  %74 = llvm.add %71, %73  : i64
  %75 = llvm.add %74, %3  : i64
  %76 = llvm.getelementptr %69[%75] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %77 = llvm.load %76 : !llvm.ptr<f32>
  %78 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %79 = llvm.mlir.constant(32 : index) : i64
  %80 = llvm.mul %8, %79  : i64
  %81 = llvm.mlir.constant(8 : index) : i64
  %82 = llvm.mul %33, %81  : i64
  %83 = llvm.add %80, %82  : i64
  %84 = llvm.add %83, %3  : i64
  %85 = llvm.getelementptr %78[%84] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %77, %85 : !llvm.ptr<f32>
  %86 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %87 = llvm.mlir.constant(32 : index) : i64
  %88 = llvm.mul %8, %87  : i64
  %89 = llvm.mlir.constant(8 : index) : i64
  %90 = llvm.mul %33, %89  : i64
  %91 = llvm.add %88, %90  : i64
  %92 = llvm.add %91, %4  : i64
  %93 = llvm.getelementptr %86[%92] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %94 = llvm.load %93 : !llvm.ptr<f32>
  %95 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %96 = llvm.mlir.constant(32 : index) : i64
  %97 = llvm.mul %8, %96  : i64
  %98 = llvm.mlir.constant(8 : index) : i64
  %99 = llvm.mul %33, %98  : i64
  %100 = llvm.add %97, %99  : i64
  %101 = llvm.add %100, %4  : i64
  %102 = llvm.getelementptr %95[%101] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %94, %102 : !llvm.ptr<f32>
  %103 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %104 = llvm.mlir.constant(32 : index) : i64
  %105 = llvm.mul %8, %104  : i64
  %106 = llvm.mlir.constant(8 : index) : i64
  %107 = llvm.mul %33, %106  : i64
  %108 = llvm.add %105, %107  : i64
  %109 = llvm.add %108, %9  : i64
  %110 = llvm.getelementptr %103[%109] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %111 = llvm.load %110 : !llvm.ptr<f32>
  %112 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %113 = llvm.mlir.constant(32 : index) : i64
  %114 = llvm.mul %8, %113  : i64
  %115 = llvm.mlir.constant(8 : index) : i64
  %116 = llvm.mul %33, %115  : i64
  %117 = llvm.add %114, %116  : i64
  %118 = llvm.add %117, %9  : i64
  %119 = llvm.getelementptr %112[%118] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %111, %119 : !llvm.ptr<f32>
  %120 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %121 = llvm.mlir.constant(32 : index) : i64
  %122 = llvm.mul %8, %121  : i64
  %123 = llvm.mlir.constant(8 : index) : i64
  %124 = llvm.mul %33, %123  : i64
  %125 = llvm.add %122, %124  : i64
  %126 = llvm.add %125, %5  : i64
  %127 = llvm.getelementptr %120[%126] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %128 = llvm.load %127 : !llvm.ptr<f32>
  %129 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %130 = llvm.mlir.constant(32 : index) : i64
  %131 = llvm.mul %8, %130  : i64
  %132 = llvm.mlir.constant(8 : index) : i64
  %133 = llvm.mul %33, %132  : i64
  %134 = llvm.add %131, %133  : i64
  %135 = llvm.add %134, %5  : i64
  %136 = llvm.getelementptr %129[%135] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %128, %136 : !llvm.ptr<f32>
  %137 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %138 = llvm.mlir.constant(32 : index) : i64
  %139 = llvm.mul %8, %138  : i64
  %140 = llvm.mlir.constant(8 : index) : i64
  %141 = llvm.mul %33, %140  : i64
  %142 = llvm.add %139, %141  : i64
  %143 = llvm.add %142, %6  : i64
  %144 = llvm.getelementptr %137[%143] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %145 = llvm.load %144 : !llvm.ptr<f32>
  %146 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %147 = llvm.mlir.constant(32 : index) : i64
  %148 = llvm.mul %8, %147  : i64
  %149 = llvm.mlir.constant(8 : index) : i64
  %150 = llvm.mul %33, %149  : i64
  %151 = llvm.add %148, %150  : i64
  %152 = llvm.add %151, %6  : i64
  %153 = llvm.getelementptr %146[%152] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %145, %153 : !llvm.ptr<f32>
  %154 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %155 = llvm.mlir.constant(32 : index) : i64
  %156 = llvm.mul %8, %155  : i64
  %157 = llvm.mlir.constant(8 : index) : i64
  %158 = llvm.mul %33, %157  : i64
  %159 = llvm.add %156, %158  : i64
  %160 = llvm.add %159, %7  : i64
  %161 = llvm.getelementptr %154[%160] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %162 = llvm.load %161 : !llvm.ptr<f32>
  %163 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %164 = llvm.mlir.constant(32 : index) : i64
  %165 = llvm.mul %8, %164  : i64
  %166 = llvm.mlir.constant(8 : index) : i64
  %167 = llvm.mul %33, %166  : i64
  %168 = llvm.add %165, %167  : i64
  %169 = llvm.add %168, %7  : i64
  %170 = llvm.getelementptr %163[%169] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %162, %170 : !llvm.ptr<f32>
  %171 = arith.addi %32, %c1 : index
  cf.br ^bb1(%171 : index)
^bb3:  // pred: ^bb1
  %172 = llvm.mlir.constant(1 : index) : i64
  %173 = llvm.mlir.constant(8 : index) : i64
  %174 = llvm.mlir.constant(4 : index) : i64
  %175 = llvm.mlir.constant(1 : index) : i64
  %176 = llvm.mlir.constant(32 : index) : i64
  %177 = llvm.mlir.constant(32 : index) : i64
  %178 = llvm.mlir.null : !llvm.ptr<f32>
  %179 = llvm.getelementptr %178[%177] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %180 = llvm.ptrtoint %179 : !llvm.ptr<f32> to i64
  %181 = llvm.alloca %180 x f32 : (i64) -> !llvm.ptr<f32>
  %182 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %183 = llvm.insertvalue %181, %182[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %184 = llvm.insertvalue %181, %183[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %185 = llvm.mlir.constant(0 : index) : i64
  %186 = llvm.insertvalue %185, %184[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %187 = llvm.insertvalue %172, %186[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %188 = llvm.insertvalue %173, %187[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %189 = llvm.insertvalue %174, %188[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %190 = llvm.insertvalue %176, %189[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %191 = llvm.insertvalue %174, %190[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %192 = llvm.insertvalue %175, %191[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb4(%c0 : index)
^bb4(%193: index):  // 2 preds: ^bb3, ^bb5
  %194 = builtin.unrealized_conversion_cast %193 : index to i64
  %195 = arith.cmpi slt, %193, %c8 : index
  cf.cond_br %195, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %196 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %197 = llvm.mlir.constant(32 : index) : i64
  %198 = llvm.mul %8, %197  : i64
  %199 = llvm.mlir.constant(4 : index) : i64
  %200 = llvm.mul %194, %199  : i64
  %201 = llvm.add %198, %200  : i64
  %202 = llvm.add %201, %8  : i64
  %203 = llvm.getelementptr %196[%202] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %204 = llvm.load %203 : !llvm.ptr<f32>
  %205 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %206 = llvm.mlir.constant(32 : index) : i64
  %207 = llvm.mul %8, %206  : i64
  %208 = llvm.mlir.constant(4 : index) : i64
  %209 = llvm.mul %194, %208  : i64
  %210 = llvm.add %207, %209  : i64
  %211 = llvm.add %210, %8  : i64
  %212 = llvm.getelementptr %205[%211] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %204, %212 : !llvm.ptr<f32>
  %213 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %214 = llvm.mlir.constant(32 : index) : i64
  %215 = llvm.mul %8, %214  : i64
  %216 = llvm.mlir.constant(4 : index) : i64
  %217 = llvm.mul %194, %216  : i64
  %218 = llvm.add %215, %217  : i64
  %219 = llvm.add %218, %10  : i64
  %220 = llvm.getelementptr %213[%219] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %221 = llvm.load %220 : !llvm.ptr<f32>
  %222 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %223 = llvm.mlir.constant(32 : index) : i64
  %224 = llvm.mul %8, %223  : i64
  %225 = llvm.mlir.constant(4 : index) : i64
  %226 = llvm.mul %194, %225  : i64
  %227 = llvm.add %224, %226  : i64
  %228 = llvm.add %227, %10  : i64
  %229 = llvm.getelementptr %222[%228] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %221, %229 : !llvm.ptr<f32>
  %230 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %231 = llvm.mlir.constant(32 : index) : i64
  %232 = llvm.mul %8, %231  : i64
  %233 = llvm.mlir.constant(4 : index) : i64
  %234 = llvm.mul %194, %233  : i64
  %235 = llvm.add %232, %234  : i64
  %236 = llvm.add %235, %3  : i64
  %237 = llvm.getelementptr %230[%236] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %238 = llvm.load %237 : !llvm.ptr<f32>
  %239 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %240 = llvm.mlir.constant(32 : index) : i64
  %241 = llvm.mul %8, %240  : i64
  %242 = llvm.mlir.constant(4 : index) : i64
  %243 = llvm.mul %194, %242  : i64
  %244 = llvm.add %241, %243  : i64
  %245 = llvm.add %244, %3  : i64
  %246 = llvm.getelementptr %239[%245] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %238, %246 : !llvm.ptr<f32>
  %247 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %248 = llvm.mlir.constant(32 : index) : i64
  %249 = llvm.mul %8, %248  : i64
  %250 = llvm.mlir.constant(4 : index) : i64
  %251 = llvm.mul %194, %250  : i64
  %252 = llvm.add %249, %251  : i64
  %253 = llvm.add %252, %4  : i64
  %254 = llvm.getelementptr %247[%253] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %255 = llvm.load %254 : !llvm.ptr<f32>
  %256 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %257 = llvm.mlir.constant(32 : index) : i64
  %258 = llvm.mul %8, %257  : i64
  %259 = llvm.mlir.constant(4 : index) : i64
  %260 = llvm.mul %194, %259  : i64
  %261 = llvm.add %258, %260  : i64
  %262 = llvm.add %261, %4  : i64
  %263 = llvm.getelementptr %256[%262] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %255, %263 : !llvm.ptr<f32>
  %264 = arith.addi %193, %c1 : index
  cf.br ^bb4(%264 : index)
^bb6:  // pred: ^bb4
  %265 = llvm.mlir.constant(1 : index) : i64
  %266 = llvm.mlir.constant(4 : index) : i64
  %267 = llvm.mlir.constant(4 : index) : i64
  %268 = llvm.mlir.constant(1 : index) : i64
  %269 = llvm.mlir.constant(16 : index) : i64
  %270 = llvm.mlir.constant(16 : index) : i64
  %271 = llvm.mlir.null : !llvm.ptr<f32>
  %272 = llvm.getelementptr %271[%270] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %273 = llvm.ptrtoint %272 : !llvm.ptr<f32> to i64
  %274 = llvm.alloca %273 x f32 : (i64) -> !llvm.ptr<f32>
  %275 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %276 = llvm.insertvalue %274, %275[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %277 = llvm.insertvalue %274, %276[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %278 = llvm.mlir.constant(0 : index) : i64
  %279 = llvm.insertvalue %278, %277[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %280 = llvm.insertvalue %265, %279[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %281 = llvm.insertvalue %266, %280[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %282 = llvm.insertvalue %267, %281[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %283 = llvm.insertvalue %269, %282[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %284 = llvm.insertvalue %267, %283[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %285 = llvm.insertvalue %268, %284[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb7(%c0 : index)
^bb7(%286: index):  // 2 preds: ^bb6, ^bb8
  %287 = builtin.unrealized_conversion_cast %286 : index to i64
  %288 = arith.cmpi slt, %286, %c4 : index
  cf.cond_br %288, ^bb8, ^bb9(%c0 : index)
^bb8:  // pred: ^bb7
  %289 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %290 = llvm.mlir.constant(16 : index) : i64
  %291 = llvm.mul %8, %290  : i64
  %292 = llvm.mlir.constant(4 : index) : i64
  %293 = llvm.mul %287, %292  : i64
  %294 = llvm.add %291, %293  : i64
  %295 = llvm.add %294, %8  : i64
  %296 = llvm.getelementptr %289[%295] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %297 = llvm.load %296 : !llvm.ptr<f32>
  %298 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %299 = llvm.mlir.constant(16 : index) : i64
  %300 = llvm.mul %8, %299  : i64
  %301 = llvm.mlir.constant(4 : index) : i64
  %302 = llvm.mul %287, %301  : i64
  %303 = llvm.add %300, %302  : i64
  %304 = llvm.add %303, %8  : i64
  %305 = llvm.getelementptr %298[%304] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %297, %305 : !llvm.ptr<f32>
  %306 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %307 = llvm.mlir.constant(16 : index) : i64
  %308 = llvm.mul %8, %307  : i64
  %309 = llvm.mlir.constant(4 : index) : i64
  %310 = llvm.mul %287, %309  : i64
  %311 = llvm.add %308, %310  : i64
  %312 = llvm.add %311, %10  : i64
  %313 = llvm.getelementptr %306[%312] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %314 = llvm.load %313 : !llvm.ptr<f32>
  %315 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %316 = llvm.mlir.constant(16 : index) : i64
  %317 = llvm.mul %8, %316  : i64
  %318 = llvm.mlir.constant(4 : index) : i64
  %319 = llvm.mul %287, %318  : i64
  %320 = llvm.add %317, %319  : i64
  %321 = llvm.add %320, %10  : i64
  %322 = llvm.getelementptr %315[%321] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %314, %322 : !llvm.ptr<f32>
  %323 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %324 = llvm.mlir.constant(16 : index) : i64
  %325 = llvm.mul %8, %324  : i64
  %326 = llvm.mlir.constant(4 : index) : i64
  %327 = llvm.mul %287, %326  : i64
  %328 = llvm.add %325, %327  : i64
  %329 = llvm.add %328, %3  : i64
  %330 = llvm.getelementptr %323[%329] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %331 = llvm.load %330 : !llvm.ptr<f32>
  %332 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %333 = llvm.mlir.constant(16 : index) : i64
  %334 = llvm.mul %8, %333  : i64
  %335 = llvm.mlir.constant(4 : index) : i64
  %336 = llvm.mul %287, %335  : i64
  %337 = llvm.add %334, %336  : i64
  %338 = llvm.add %337, %3  : i64
  %339 = llvm.getelementptr %332[%338] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %331, %339 : !llvm.ptr<f32>
  %340 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %341 = llvm.mlir.constant(16 : index) : i64
  %342 = llvm.mul %8, %341  : i64
  %343 = llvm.mlir.constant(4 : index) : i64
  %344 = llvm.mul %287, %343  : i64
  %345 = llvm.add %342, %344  : i64
  %346 = llvm.add %345, %4  : i64
  %347 = llvm.getelementptr %340[%346] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %348 = llvm.load %347 : !llvm.ptr<f32>
  %349 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %350 = llvm.mlir.constant(16 : index) : i64
  %351 = llvm.mul %8, %350  : i64
  %352 = llvm.mlir.constant(4 : index) : i64
  %353 = llvm.mul %287, %352  : i64
  %354 = llvm.add %351, %353  : i64
  %355 = llvm.add %354, %4  : i64
  %356 = llvm.getelementptr %349[%355] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %348, %356 : !llvm.ptr<f32>
  %357 = arith.addi %286, %c1 : index
  cf.br ^bb7(%357 : index)
^bb9(%358: index):  // 2 preds: ^bb7, ^bb12
  %359 = builtin.unrealized_conversion_cast %358 : index to i64
  %360 = arith.cmpi slt, %358, %c4 : index
  cf.cond_br %360, ^bb10(%c0 : index), ^bb13(%c0 : index)
^bb10(%361: index):  // 2 preds: ^bb9, ^bb11
  %362 = builtin.unrealized_conversion_cast %361 : index to i64
  %363 = arith.cmpi slt, %361, %c4 : index
  cf.cond_br %363, ^bb11, ^bb12
^bb11:  // pred: ^bb10
  %364 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %365 = llvm.mlir.constant(32 : index) : i64
  %366 = llvm.mul %8, %365  : i64
  %367 = llvm.mlir.constant(8 : index) : i64
  %368 = llvm.mul %359, %367  : i64
  %369 = llvm.add %366, %368  : i64
  %370 = llvm.add %369, %8  : i64
  %371 = llvm.getelementptr %364[%370] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %372 = llvm.load %371 : !llvm.ptr<f32>
  %373 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %374 = llvm.mlir.constant(32 : index) : i64
  %375 = llvm.mul %8, %374  : i64
  %376 = llvm.mlir.constant(4 : index) : i64
  %377 = llvm.mul %8, %376  : i64
  %378 = llvm.add %375, %377  : i64
  %379 = llvm.add %378, %362  : i64
  %380 = llvm.getelementptr %373[%379] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %381 = llvm.load %380 : !llvm.ptr<f32>
  %382 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %383 = llvm.mlir.constant(16 : index) : i64
  %384 = llvm.mul %8, %383  : i64
  %385 = llvm.mlir.constant(4 : index) : i64
  %386 = llvm.mul %359, %385  : i64
  %387 = llvm.add %384, %386  : i64
  %388 = llvm.add %387, %362  : i64
  %389 = llvm.getelementptr %382[%388] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %390 = llvm.load %389 : !llvm.ptr<f32>
  %391 = arith.mulf %372, %381 : f32
  %392 = arith.addf %390, %391 : f32
  %393 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %394 = llvm.mlir.constant(32 : index) : i64
  %395 = llvm.mul %8, %394  : i64
  %396 = llvm.mlir.constant(8 : index) : i64
  %397 = llvm.mul %359, %396  : i64
  %398 = llvm.add %395, %397  : i64
  %399 = llvm.add %398, %10  : i64
  %400 = llvm.getelementptr %393[%399] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %401 = llvm.load %400 : !llvm.ptr<f32>
  %402 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %403 = llvm.mlir.constant(32 : index) : i64
  %404 = llvm.mul %8, %403  : i64
  %405 = llvm.mlir.constant(4 : index) : i64
  %406 = llvm.mul %10, %405  : i64
  %407 = llvm.add %404, %406  : i64
  %408 = llvm.add %407, %362  : i64
  %409 = llvm.getelementptr %402[%408] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %410 = llvm.load %409 : !llvm.ptr<f32>
  %411 = arith.mulf %401, %410 : f32
  %412 = arith.addf %392, %411 : f32
  %413 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %414 = llvm.mlir.constant(32 : index) : i64
  %415 = llvm.mul %8, %414  : i64
  %416 = llvm.mlir.constant(8 : index) : i64
  %417 = llvm.mul %359, %416  : i64
  %418 = llvm.add %415, %417  : i64
  %419 = llvm.add %418, %3  : i64
  %420 = llvm.getelementptr %413[%419] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %421 = llvm.load %420 : !llvm.ptr<f32>
  %422 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %423 = llvm.mlir.constant(32 : index) : i64
  %424 = llvm.mul %8, %423  : i64
  %425 = llvm.mlir.constant(4 : index) : i64
  %426 = llvm.mul %3, %425  : i64
  %427 = llvm.add %424, %426  : i64
  %428 = llvm.add %427, %362  : i64
  %429 = llvm.getelementptr %422[%428] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %430 = llvm.load %429 : !llvm.ptr<f32>
  %431 = arith.mulf %421, %430 : f32
  %432 = arith.addf %412, %431 : f32
  %433 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %434 = llvm.mlir.constant(32 : index) : i64
  %435 = llvm.mul %8, %434  : i64
  %436 = llvm.mlir.constant(8 : index) : i64
  %437 = llvm.mul %359, %436  : i64
  %438 = llvm.add %435, %437  : i64
  %439 = llvm.add %438, %4  : i64
  %440 = llvm.getelementptr %433[%439] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %441 = llvm.load %440 : !llvm.ptr<f32>
  %442 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %443 = llvm.mlir.constant(32 : index) : i64
  %444 = llvm.mul %8, %443  : i64
  %445 = llvm.mlir.constant(4 : index) : i64
  %446 = llvm.mul %4, %445  : i64
  %447 = llvm.add %444, %446  : i64
  %448 = llvm.add %447, %362  : i64
  %449 = llvm.getelementptr %442[%448] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %450 = llvm.load %449 : !llvm.ptr<f32>
  %451 = arith.mulf %441, %450 : f32
  %452 = arith.addf %432, %451 : f32
  %453 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %454 = llvm.mlir.constant(32 : index) : i64
  %455 = llvm.mul %8, %454  : i64
  %456 = llvm.mlir.constant(8 : index) : i64
  %457 = llvm.mul %359, %456  : i64
  %458 = llvm.add %455, %457  : i64
  %459 = llvm.add %458, %9  : i64
  %460 = llvm.getelementptr %453[%459] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %461 = llvm.load %460 : !llvm.ptr<f32>
  %462 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %463 = llvm.mlir.constant(32 : index) : i64
  %464 = llvm.mul %8, %463  : i64
  %465 = llvm.mlir.constant(4 : index) : i64
  %466 = llvm.mul %9, %465  : i64
  %467 = llvm.add %464, %466  : i64
  %468 = llvm.add %467, %362  : i64
  %469 = llvm.getelementptr %462[%468] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %470 = llvm.load %469 : !llvm.ptr<f32>
  %471 = arith.mulf %461, %470 : f32
  %472 = arith.addf %452, %471 : f32
  %473 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %474 = llvm.mlir.constant(32 : index) : i64
  %475 = llvm.mul %8, %474  : i64
  %476 = llvm.mlir.constant(8 : index) : i64
  %477 = llvm.mul %359, %476  : i64
  %478 = llvm.add %475, %477  : i64
  %479 = llvm.add %478, %5  : i64
  %480 = llvm.getelementptr %473[%479] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %481 = llvm.load %480 : !llvm.ptr<f32>
  %482 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %483 = llvm.mlir.constant(32 : index) : i64
  %484 = llvm.mul %8, %483  : i64
  %485 = llvm.mlir.constant(4 : index) : i64
  %486 = llvm.mul %5, %485  : i64
  %487 = llvm.add %484, %486  : i64
  %488 = llvm.add %487, %362  : i64
  %489 = llvm.getelementptr %482[%488] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %490 = llvm.load %489 : !llvm.ptr<f32>
  %491 = arith.mulf %481, %490 : f32
  %492 = arith.addf %472, %491 : f32
  %493 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %494 = llvm.mlir.constant(32 : index) : i64
  %495 = llvm.mul %8, %494  : i64
  %496 = llvm.mlir.constant(8 : index) : i64
  %497 = llvm.mul %359, %496  : i64
  %498 = llvm.add %495, %497  : i64
  %499 = llvm.add %498, %6  : i64
  %500 = llvm.getelementptr %493[%499] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %501 = llvm.load %500 : !llvm.ptr<f32>
  %502 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %503 = llvm.mlir.constant(32 : index) : i64
  %504 = llvm.mul %8, %503  : i64
  %505 = llvm.mlir.constant(4 : index) : i64
  %506 = llvm.mul %6, %505  : i64
  %507 = llvm.add %504, %506  : i64
  %508 = llvm.add %507, %362  : i64
  %509 = llvm.getelementptr %502[%508] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %510 = llvm.load %509 : !llvm.ptr<f32>
  %511 = arith.mulf %501, %510 : f32
  %512 = arith.addf %492, %511 : f32
  %513 = llvm.extractvalue %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %514 = llvm.mlir.constant(32 : index) : i64
  %515 = llvm.mul %8, %514  : i64
  %516 = llvm.mlir.constant(8 : index) : i64
  %517 = llvm.mul %359, %516  : i64
  %518 = llvm.add %515, %517  : i64
  %519 = llvm.add %518, %7  : i64
  %520 = llvm.getelementptr %513[%519] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %521 = llvm.load %520 : !llvm.ptr<f32>
  %522 = llvm.extractvalue %192[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %523 = llvm.mlir.constant(32 : index) : i64
  %524 = llvm.mul %8, %523  : i64
  %525 = llvm.mlir.constant(4 : index) : i64
  %526 = llvm.mul %7, %525  : i64
  %527 = llvm.add %524, %526  : i64
  %528 = llvm.add %527, %362  : i64
  %529 = llvm.getelementptr %522[%528] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %530 = llvm.load %529 : !llvm.ptr<f32>
  %531 = arith.mulf %521, %530 : f32
  %532 = arith.addf %512, %531 : f32
  %533 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %534 = llvm.mlir.constant(16 : index) : i64
  %535 = llvm.mul %8, %534  : i64
  %536 = llvm.mlir.constant(4 : index) : i64
  %537 = llvm.mul %359, %536  : i64
  %538 = llvm.add %535, %537  : i64
  %539 = llvm.add %538, %362  : i64
  %540 = llvm.getelementptr %533[%539] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %532, %540 : !llvm.ptr<f32>
  %541 = arith.addi %361, %c1 : index
  cf.br ^bb10(%541 : index)
^bb12:  // pred: ^bb10
  %542 = arith.addi %358, %c1 : index
  cf.br ^bb9(%542 : index)
^bb13(%543: index):  // 2 preds: ^bb9, ^bb14
  %544 = builtin.unrealized_conversion_cast %543 : index to i64
  %545 = arith.cmpi slt, %543, %c4 : index
  cf.cond_br %545, ^bb14, ^bb15
^bb14:  // pred: ^bb13
  %546 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %547 = llvm.mlir.constant(16 : index) : i64
  %548 = llvm.mul %8, %547  : i64
  %549 = llvm.mlir.constant(4 : index) : i64
  %550 = llvm.mul %544, %549  : i64
  %551 = llvm.add %548, %550  : i64
  %552 = llvm.add %551, %8  : i64
  %553 = llvm.getelementptr %546[%552] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %554 = llvm.load %553 : !llvm.ptr<f32>
  %555 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %556 = llvm.mlir.constant(16 : index) : i64
  %557 = llvm.mul %8, %556  : i64
  %558 = llvm.mlir.constant(4 : index) : i64
  %559 = llvm.mul %544, %558  : i64
  %560 = llvm.add %557, %559  : i64
  %561 = llvm.add %560, %8  : i64
  %562 = llvm.getelementptr %555[%561] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %554, %562 : !llvm.ptr<f32>
  %563 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %564 = llvm.mlir.constant(16 : index) : i64
  %565 = llvm.mul %8, %564  : i64
  %566 = llvm.mlir.constant(4 : index) : i64
  %567 = llvm.mul %544, %566  : i64
  %568 = llvm.add %565, %567  : i64
  %569 = llvm.add %568, %10  : i64
  %570 = llvm.getelementptr %563[%569] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %571 = llvm.load %570 : !llvm.ptr<f32>
  %572 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %573 = llvm.mlir.constant(16 : index) : i64
  %574 = llvm.mul %8, %573  : i64
  %575 = llvm.mlir.constant(4 : index) : i64
  %576 = llvm.mul %544, %575  : i64
  %577 = llvm.add %574, %576  : i64
  %578 = llvm.add %577, %10  : i64
  %579 = llvm.getelementptr %572[%578] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %571, %579 : !llvm.ptr<f32>
  %580 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %581 = llvm.mlir.constant(16 : index) : i64
  %582 = llvm.mul %8, %581  : i64
  %583 = llvm.mlir.constant(4 : index) : i64
  %584 = llvm.mul %544, %583  : i64
  %585 = llvm.add %582, %584  : i64
  %586 = llvm.add %585, %3  : i64
  %587 = llvm.getelementptr %580[%586] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %588 = llvm.load %587 : !llvm.ptr<f32>
  %589 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %590 = llvm.mlir.constant(16 : index) : i64
  %591 = llvm.mul %8, %590  : i64
  %592 = llvm.mlir.constant(4 : index) : i64
  %593 = llvm.mul %544, %592  : i64
  %594 = llvm.add %591, %593  : i64
  %595 = llvm.add %594, %3  : i64
  %596 = llvm.getelementptr %589[%595] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %588, %596 : !llvm.ptr<f32>
  %597 = llvm.extractvalue %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %598 = llvm.mlir.constant(16 : index) : i64
  %599 = llvm.mul %8, %598  : i64
  %600 = llvm.mlir.constant(4 : index) : i64
  %601 = llvm.mul %544, %600  : i64
  %602 = llvm.add %599, %601  : i64
  %603 = llvm.add %602, %4  : i64
  %604 = llvm.getelementptr %597[%603] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %605 = llvm.load %604 : !llvm.ptr<f32>
  %606 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %607 = llvm.mlir.constant(16 : index) : i64
  %608 = llvm.mul %8, %607  : i64
  %609 = llvm.mlir.constant(4 : index) : i64
  %610 = llvm.mul %544, %609  : i64
  %611 = llvm.add %608, %610  : i64
  %612 = llvm.add %611, %4  : i64
  %613 = llvm.getelementptr %606[%612] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %605, %613 : !llvm.ptr<f32>
  %614 = arith.addi %543, %c1 : index
  cf.br ^bb13(%614 : index)
^bb15:  // pred: ^bb13
  return
}

// -----// IR Dump After ConvertMathToLibm //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<1x4x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<1x8x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg0 : memref<1x4x8xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %c2 = arith.constant 2 : index
    %3 = builtin.unrealized_conversion_cast %c2 : index to i64
    %c3 = arith.constant 3 : index
    %4 = builtin.unrealized_conversion_cast %c3 : index to i64
    %c5 = arith.constant 5 : index
    %5 = builtin.unrealized_conversion_cast %c5 : index to i64
    %c6 = arith.constant 6 : index
    %6 = builtin.unrealized_conversion_cast %c6 : index to i64
    %c7 = arith.constant 7 : index
    %7 = builtin.unrealized_conversion_cast %c7 : index to i64
    %c8 = arith.constant 8 : index
    %c0 = arith.constant 0 : index
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %c4 = arith.constant 4 : index
    %9 = builtin.unrealized_conversion_cast %c4 : index to i64
    %c1 = arith.constant 1 : index
    %10 = builtin.unrealized_conversion_cast %c1 : index to i64
    %11 = llvm.mlir.constant(1 : index) : i64
    %12 = llvm.mlir.constant(4 : index) : i64
    %13 = llvm.mlir.constant(8 : index) : i64
    %14 = llvm.mlir.constant(1 : index) : i64
    %15 = llvm.mlir.constant(32 : index) : i64
    %16 = llvm.mlir.constant(32 : index) : i64
    %17 = llvm.mlir.null : !llvm.ptr<f32>
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %19 = llvm.ptrtoint %18 : !llvm.ptr<f32> to i64
    %20 = llvm.alloca %19 x f32 : (i64) -> !llvm.ptr<f32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %23 = llvm.insertvalue %20, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %24 = llvm.mlir.constant(0 : index) : i64
    %25 = llvm.insertvalue %24, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %26 = llvm.insertvalue %11, %25[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %27 = llvm.insertvalue %12, %26[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %28 = llvm.insertvalue %13, %27[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %29 = llvm.insertvalue %15, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %30 = llvm.insertvalue %13, %29[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %31 = llvm.insertvalue %14, %30[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb1(%c0 : index)
  ^bb1(%32: index):  // 2 preds: ^bb0, ^bb2
    %33 = builtin.unrealized_conversion_cast %32 : index to i64
    %34 = arith.cmpi slt, %32, %c4 : index
    cf.cond_br %34, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %35 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %36 = llvm.mlir.constant(32 : index) : i64
    %37 = llvm.mul %8, %36  : i64
    %38 = llvm.mlir.constant(8 : index) : i64
    %39 = llvm.mul %33, %38  : i64
    %40 = llvm.add %37, %39  : i64
    %41 = llvm.add %40, %8  : i64
    %42 = llvm.getelementptr %35[%41] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %43 = llvm.load %42 : !llvm.ptr<f32>
    %44 = llvm.mlir.constant(32 : index) : i64
    %45 = llvm.mul %8, %44  : i64
    %46 = llvm.mlir.constant(8 : index) : i64
    %47 = llvm.mul %33, %46  : i64
    %48 = llvm.add %45, %47  : i64
    %49 = llvm.add %48, %8  : i64
    %50 = llvm.getelementptr %20[%49] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %43, %50 : !llvm.ptr<f32>
    %51 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %52 = llvm.mlir.constant(32 : index) : i64
    %53 = llvm.mul %8, %52  : i64
    %54 = llvm.mlir.constant(8 : index) : i64
    %55 = llvm.mul %33, %54  : i64
    %56 = llvm.add %53, %55  : i64
    %57 = llvm.add %56, %10  : i64
    %58 = llvm.getelementptr %51[%57] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %59 = llvm.load %58 : !llvm.ptr<f32>
    %60 = llvm.mlir.constant(32 : index) : i64
    %61 = llvm.mul %8, %60  : i64
    %62 = llvm.mlir.constant(8 : index) : i64
    %63 = llvm.mul %33, %62  : i64
    %64 = llvm.add %61, %63  : i64
    %65 = llvm.add %64, %10  : i64
    %66 = llvm.getelementptr %20[%65] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %59, %66 : !llvm.ptr<f32>
    %67 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %68 = llvm.mlir.constant(32 : index) : i64
    %69 = llvm.mul %8, %68  : i64
    %70 = llvm.mlir.constant(8 : index) : i64
    %71 = llvm.mul %33, %70  : i64
    %72 = llvm.add %69, %71  : i64
    %73 = llvm.add %72, %3  : i64
    %74 = llvm.getelementptr %67[%73] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %75 = llvm.load %74 : !llvm.ptr<f32>
    %76 = llvm.mlir.constant(32 : index) : i64
    %77 = llvm.mul %8, %76  : i64
    %78 = llvm.mlir.constant(8 : index) : i64
    %79 = llvm.mul %33, %78  : i64
    %80 = llvm.add %77, %79  : i64
    %81 = llvm.add %80, %3  : i64
    %82 = llvm.getelementptr %20[%81] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %75, %82 : !llvm.ptr<f32>
    %83 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %84 = llvm.mlir.constant(32 : index) : i64
    %85 = llvm.mul %8, %84  : i64
    %86 = llvm.mlir.constant(8 : index) : i64
    %87 = llvm.mul %33, %86  : i64
    %88 = llvm.add %85, %87  : i64
    %89 = llvm.add %88, %4  : i64
    %90 = llvm.getelementptr %83[%89] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %91 = llvm.load %90 : !llvm.ptr<f32>
    %92 = llvm.mlir.constant(32 : index) : i64
    %93 = llvm.mul %8, %92  : i64
    %94 = llvm.mlir.constant(8 : index) : i64
    %95 = llvm.mul %33, %94  : i64
    %96 = llvm.add %93, %95  : i64
    %97 = llvm.add %96, %4  : i64
    %98 = llvm.getelementptr %20[%97] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %91, %98 : !llvm.ptr<f32>
    %99 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %100 = llvm.mlir.constant(32 : index) : i64
    %101 = llvm.mul %8, %100  : i64
    %102 = llvm.mlir.constant(8 : index) : i64
    %103 = llvm.mul %33, %102  : i64
    %104 = llvm.add %101, %103  : i64
    %105 = llvm.add %104, %9  : i64
    %106 = llvm.getelementptr %99[%105] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %107 = llvm.load %106 : !llvm.ptr<f32>
    %108 = llvm.mlir.constant(32 : index) : i64
    %109 = llvm.mul %8, %108  : i64
    %110 = llvm.mlir.constant(8 : index) : i64
    %111 = llvm.mul %33, %110  : i64
    %112 = llvm.add %109, %111  : i64
    %113 = llvm.add %112, %9  : i64
    %114 = llvm.getelementptr %20[%113] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %107, %114 : !llvm.ptr<f32>
    %115 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %116 = llvm.mlir.constant(32 : index) : i64
    %117 = llvm.mul %8, %116  : i64
    %118 = llvm.mlir.constant(8 : index) : i64
    %119 = llvm.mul %33, %118  : i64
    %120 = llvm.add %117, %119  : i64
    %121 = llvm.add %120, %5  : i64
    %122 = llvm.getelementptr %115[%121] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %123 = llvm.load %122 : !llvm.ptr<f32>
    %124 = llvm.mlir.constant(32 : index) : i64
    %125 = llvm.mul %8, %124  : i64
    %126 = llvm.mlir.constant(8 : index) : i64
    %127 = llvm.mul %33, %126  : i64
    %128 = llvm.add %125, %127  : i64
    %129 = llvm.add %128, %5  : i64
    %130 = llvm.getelementptr %20[%129] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %123, %130 : !llvm.ptr<f32>
    %131 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %132 = llvm.mlir.constant(32 : index) : i64
    %133 = llvm.mul %8, %132  : i64
    %134 = llvm.mlir.constant(8 : index) : i64
    %135 = llvm.mul %33, %134  : i64
    %136 = llvm.add %133, %135  : i64
    %137 = llvm.add %136, %6  : i64
    %138 = llvm.getelementptr %131[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %139 = llvm.load %138 : !llvm.ptr<f32>
    %140 = llvm.mlir.constant(32 : index) : i64
    %141 = llvm.mul %8, %140  : i64
    %142 = llvm.mlir.constant(8 : index) : i64
    %143 = llvm.mul %33, %142  : i64
    %144 = llvm.add %141, %143  : i64
    %145 = llvm.add %144, %6  : i64
    %146 = llvm.getelementptr %20[%145] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %139, %146 : !llvm.ptr<f32>
    %147 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %148 = llvm.mlir.constant(32 : index) : i64
    %149 = llvm.mul %8, %148  : i64
    %150 = llvm.mlir.constant(8 : index) : i64
    %151 = llvm.mul %33, %150  : i64
    %152 = llvm.add %149, %151  : i64
    %153 = llvm.add %152, %7  : i64
    %154 = llvm.getelementptr %147[%153] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %155 = llvm.load %154 : !llvm.ptr<f32>
    %156 = llvm.mlir.constant(32 : index) : i64
    %157 = llvm.mul %8, %156  : i64
    %158 = llvm.mlir.constant(8 : index) : i64
    %159 = llvm.mul %33, %158  : i64
    %160 = llvm.add %157, %159  : i64
    %161 = llvm.add %160, %7  : i64
    %162 = llvm.getelementptr %20[%161] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %155, %162 : !llvm.ptr<f32>
    %163 = arith.addi %32, %c1 : index
    cf.br ^bb1(%163 : index)
  ^bb3:  // pred: ^bb1
    %164 = llvm.mlir.constant(1 : index) : i64
    %165 = llvm.mlir.constant(8 : index) : i64
    %166 = llvm.mlir.constant(4 : index) : i64
    %167 = llvm.mlir.constant(1 : index) : i64
    %168 = llvm.mlir.constant(32 : index) : i64
    %169 = llvm.mlir.constant(32 : index) : i64
    %170 = llvm.mlir.null : !llvm.ptr<f32>
    %171 = llvm.getelementptr %170[%169] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %172 = llvm.ptrtoint %171 : !llvm.ptr<f32> to i64
    %173 = llvm.alloca %172 x f32 : (i64) -> !llvm.ptr<f32>
    %174 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %175 = llvm.insertvalue %173, %174[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %176 = llvm.insertvalue %173, %175[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %177 = llvm.mlir.constant(0 : index) : i64
    %178 = llvm.insertvalue %177, %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %179 = llvm.insertvalue %164, %178[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %180 = llvm.insertvalue %165, %179[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %181 = llvm.insertvalue %166, %180[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %182 = llvm.insertvalue %168, %181[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %183 = llvm.insertvalue %166, %182[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %184 = llvm.insertvalue %167, %183[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb4(%c0 : index)
  ^bb4(%185: index):  // 2 preds: ^bb3, ^bb5
    %186 = builtin.unrealized_conversion_cast %185 : index to i64
    %187 = arith.cmpi slt, %185, %c8 : index
    cf.cond_br %187, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %188 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %189 = llvm.mlir.constant(32 : index) : i64
    %190 = llvm.mul %8, %189  : i64
    %191 = llvm.mlir.constant(4 : index) : i64
    %192 = llvm.mul %186, %191  : i64
    %193 = llvm.add %190, %192  : i64
    %194 = llvm.add %193, %8  : i64
    %195 = llvm.getelementptr %188[%194] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %196 = llvm.load %195 : !llvm.ptr<f32>
    %197 = llvm.mlir.constant(32 : index) : i64
    %198 = llvm.mul %8, %197  : i64
    %199 = llvm.mlir.constant(4 : index) : i64
    %200 = llvm.mul %186, %199  : i64
    %201 = llvm.add %198, %200  : i64
    %202 = llvm.add %201, %8  : i64
    %203 = llvm.getelementptr %173[%202] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %196, %203 : !llvm.ptr<f32>
    %204 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %205 = llvm.mlir.constant(32 : index) : i64
    %206 = llvm.mul %8, %205  : i64
    %207 = llvm.mlir.constant(4 : index) : i64
    %208 = llvm.mul %186, %207  : i64
    %209 = llvm.add %206, %208  : i64
    %210 = llvm.add %209, %10  : i64
    %211 = llvm.getelementptr %204[%210] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %212 = llvm.load %211 : !llvm.ptr<f32>
    %213 = llvm.mlir.constant(32 : index) : i64
    %214 = llvm.mul %8, %213  : i64
    %215 = llvm.mlir.constant(4 : index) : i64
    %216 = llvm.mul %186, %215  : i64
    %217 = llvm.add %214, %216  : i64
    %218 = llvm.add %217, %10  : i64
    %219 = llvm.getelementptr %173[%218] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %212, %219 : !llvm.ptr<f32>
    %220 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %221 = llvm.mlir.constant(32 : index) : i64
    %222 = llvm.mul %8, %221  : i64
    %223 = llvm.mlir.constant(4 : index) : i64
    %224 = llvm.mul %186, %223  : i64
    %225 = llvm.add %222, %224  : i64
    %226 = llvm.add %225, %3  : i64
    %227 = llvm.getelementptr %220[%226] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %228 = llvm.load %227 : !llvm.ptr<f32>
    %229 = llvm.mlir.constant(32 : index) : i64
    %230 = llvm.mul %8, %229  : i64
    %231 = llvm.mlir.constant(4 : index) : i64
    %232 = llvm.mul %186, %231  : i64
    %233 = llvm.add %230, %232  : i64
    %234 = llvm.add %233, %3  : i64
    %235 = llvm.getelementptr %173[%234] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %228, %235 : !llvm.ptr<f32>
    %236 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %237 = llvm.mlir.constant(32 : index) : i64
    %238 = llvm.mul %8, %237  : i64
    %239 = llvm.mlir.constant(4 : index) : i64
    %240 = llvm.mul %186, %239  : i64
    %241 = llvm.add %238, %240  : i64
    %242 = llvm.add %241, %4  : i64
    %243 = llvm.getelementptr %236[%242] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %244 = llvm.load %243 : !llvm.ptr<f32>
    %245 = llvm.mlir.constant(32 : index) : i64
    %246 = llvm.mul %8, %245  : i64
    %247 = llvm.mlir.constant(4 : index) : i64
    %248 = llvm.mul %186, %247  : i64
    %249 = llvm.add %246, %248  : i64
    %250 = llvm.add %249, %4  : i64
    %251 = llvm.getelementptr %173[%250] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %244, %251 : !llvm.ptr<f32>
    %252 = arith.addi %185, %c1 : index
    cf.br ^bb4(%252 : index)
  ^bb6:  // pred: ^bb4
    %253 = llvm.mlir.constant(1 : index) : i64
    %254 = llvm.mlir.constant(4 : index) : i64
    %255 = llvm.mlir.constant(4 : index) : i64
    %256 = llvm.mlir.constant(1 : index) : i64
    %257 = llvm.mlir.constant(16 : index) : i64
    %258 = llvm.mlir.constant(16 : index) : i64
    %259 = llvm.mlir.null : !llvm.ptr<f32>
    %260 = llvm.getelementptr %259[%258] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %261 = llvm.ptrtoint %260 : !llvm.ptr<f32> to i64
    %262 = llvm.alloca %261 x f32 : (i64) -> !llvm.ptr<f32>
    %263 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %264 = llvm.insertvalue %262, %263[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %265 = llvm.insertvalue %262, %264[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %266 = llvm.mlir.constant(0 : index) : i64
    %267 = llvm.insertvalue %266, %265[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %268 = llvm.insertvalue %253, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %269 = llvm.insertvalue %254, %268[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %270 = llvm.insertvalue %255, %269[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %271 = llvm.insertvalue %257, %270[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %272 = llvm.insertvalue %255, %271[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %273 = llvm.insertvalue %256, %272[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb7(%c0 : index)
  ^bb7(%274: index):  // 2 preds: ^bb6, ^bb8
    %275 = builtin.unrealized_conversion_cast %274 : index to i64
    %276 = arith.cmpi slt, %274, %c4 : index
    cf.cond_br %276, ^bb8, ^bb9(%c0 : index)
  ^bb8:  // pred: ^bb7
    %277 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %278 = llvm.mlir.constant(16 : index) : i64
    %279 = llvm.mul %8, %278  : i64
    %280 = llvm.mlir.constant(4 : index) : i64
    %281 = llvm.mul %275, %280  : i64
    %282 = llvm.add %279, %281  : i64
    %283 = llvm.add %282, %8  : i64
    %284 = llvm.getelementptr %277[%283] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %285 = llvm.load %284 : !llvm.ptr<f32>
    %286 = llvm.mlir.constant(16 : index) : i64
    %287 = llvm.mul %8, %286  : i64
    %288 = llvm.mlir.constant(4 : index) : i64
    %289 = llvm.mul %275, %288  : i64
    %290 = llvm.add %287, %289  : i64
    %291 = llvm.add %290, %8  : i64
    %292 = llvm.getelementptr %262[%291] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %285, %292 : !llvm.ptr<f32>
    %293 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %294 = llvm.mlir.constant(16 : index) : i64
    %295 = llvm.mul %8, %294  : i64
    %296 = llvm.mlir.constant(4 : index) : i64
    %297 = llvm.mul %275, %296  : i64
    %298 = llvm.add %295, %297  : i64
    %299 = llvm.add %298, %10  : i64
    %300 = llvm.getelementptr %293[%299] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %301 = llvm.load %300 : !llvm.ptr<f32>
    %302 = llvm.mlir.constant(16 : index) : i64
    %303 = llvm.mul %8, %302  : i64
    %304 = llvm.mlir.constant(4 : index) : i64
    %305 = llvm.mul %275, %304  : i64
    %306 = llvm.add %303, %305  : i64
    %307 = llvm.add %306, %10  : i64
    %308 = llvm.getelementptr %262[%307] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %301, %308 : !llvm.ptr<f32>
    %309 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %310 = llvm.mlir.constant(16 : index) : i64
    %311 = llvm.mul %8, %310  : i64
    %312 = llvm.mlir.constant(4 : index) : i64
    %313 = llvm.mul %275, %312  : i64
    %314 = llvm.add %311, %313  : i64
    %315 = llvm.add %314, %3  : i64
    %316 = llvm.getelementptr %309[%315] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %317 = llvm.load %316 : !llvm.ptr<f32>
    %318 = llvm.mlir.constant(16 : index) : i64
    %319 = llvm.mul %8, %318  : i64
    %320 = llvm.mlir.constant(4 : index) : i64
    %321 = llvm.mul %275, %320  : i64
    %322 = llvm.add %319, %321  : i64
    %323 = llvm.add %322, %3  : i64
    %324 = llvm.getelementptr %262[%323] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %317, %324 : !llvm.ptr<f32>
    %325 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %326 = llvm.mlir.constant(16 : index) : i64
    %327 = llvm.mul %8, %326  : i64
    %328 = llvm.mlir.constant(4 : index) : i64
    %329 = llvm.mul %275, %328  : i64
    %330 = llvm.add %327, %329  : i64
    %331 = llvm.add %330, %4  : i64
    %332 = llvm.getelementptr %325[%331] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %333 = llvm.load %332 : !llvm.ptr<f32>
    %334 = llvm.mlir.constant(16 : index) : i64
    %335 = llvm.mul %8, %334  : i64
    %336 = llvm.mlir.constant(4 : index) : i64
    %337 = llvm.mul %275, %336  : i64
    %338 = llvm.add %335, %337  : i64
    %339 = llvm.add %338, %4  : i64
    %340 = llvm.getelementptr %262[%339] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %333, %340 : !llvm.ptr<f32>
    %341 = arith.addi %274, %c1 : index
    cf.br ^bb7(%341 : index)
  ^bb9(%342: index):  // 2 preds: ^bb7, ^bb12
    %343 = builtin.unrealized_conversion_cast %342 : index to i64
    %344 = arith.cmpi slt, %342, %c4 : index
    cf.cond_br %344, ^bb10(%c0 : index), ^bb13(%c0 : index)
  ^bb10(%345: index):  // 2 preds: ^bb9, ^bb11
    %346 = builtin.unrealized_conversion_cast %345 : index to i64
    %347 = arith.cmpi slt, %345, %c4 : index
    cf.cond_br %347, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %348 = llvm.mlir.constant(32 : index) : i64
    %349 = llvm.mul %8, %348  : i64
    %350 = llvm.mlir.constant(8 : index) : i64
    %351 = llvm.mul %343, %350  : i64
    %352 = llvm.add %349, %351  : i64
    %353 = llvm.add %352, %8  : i64
    %354 = llvm.getelementptr %20[%353] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %355 = llvm.load %354 : !llvm.ptr<f32>
    %356 = llvm.mlir.constant(32 : index) : i64
    %357 = llvm.mul %8, %356  : i64
    %358 = llvm.mlir.constant(4 : index) : i64
    %359 = llvm.mul %8, %358  : i64
    %360 = llvm.add %357, %359  : i64
    %361 = llvm.add %360, %346  : i64
    %362 = llvm.getelementptr %173[%361] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %363 = llvm.load %362 : !llvm.ptr<f32>
    %364 = llvm.mlir.constant(16 : index) : i64
    %365 = llvm.mul %8, %364  : i64
    %366 = llvm.mlir.constant(4 : index) : i64
    %367 = llvm.mul %343, %366  : i64
    %368 = llvm.add %365, %367  : i64
    %369 = llvm.add %368, %346  : i64
    %370 = llvm.getelementptr %262[%369] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %371 = llvm.load %370 : !llvm.ptr<f32>
    %372 = arith.mulf %355, %363 : f32
    %373 = arith.addf %371, %372 : f32
    %374 = llvm.mlir.constant(32 : index) : i64
    %375 = llvm.mul %8, %374  : i64
    %376 = llvm.mlir.constant(8 : index) : i64
    %377 = llvm.mul %343, %376  : i64
    %378 = llvm.add %375, %377  : i64
    %379 = llvm.add %378, %10  : i64
    %380 = llvm.getelementptr %20[%379] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %381 = llvm.load %380 : !llvm.ptr<f32>
    %382 = llvm.mlir.constant(32 : index) : i64
    %383 = llvm.mul %8, %382  : i64
    %384 = llvm.mlir.constant(4 : index) : i64
    %385 = llvm.mul %10, %384  : i64
    %386 = llvm.add %383, %385  : i64
    %387 = llvm.add %386, %346  : i64
    %388 = llvm.getelementptr %173[%387] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %389 = llvm.load %388 : !llvm.ptr<f32>
    %390 = arith.mulf %381, %389 : f32
    %391 = arith.addf %373, %390 : f32
    %392 = llvm.mlir.constant(32 : index) : i64
    %393 = llvm.mul %8, %392  : i64
    %394 = llvm.mlir.constant(8 : index) : i64
    %395 = llvm.mul %343, %394  : i64
    %396 = llvm.add %393, %395  : i64
    %397 = llvm.add %396, %3  : i64
    %398 = llvm.getelementptr %20[%397] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %399 = llvm.load %398 : !llvm.ptr<f32>
    %400 = llvm.mlir.constant(32 : index) : i64
    %401 = llvm.mul %8, %400  : i64
    %402 = llvm.mlir.constant(4 : index) : i64
    %403 = llvm.mul %3, %402  : i64
    %404 = llvm.add %401, %403  : i64
    %405 = llvm.add %404, %346  : i64
    %406 = llvm.getelementptr %173[%405] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %407 = llvm.load %406 : !llvm.ptr<f32>
    %408 = arith.mulf %399, %407 : f32
    %409 = arith.addf %391, %408 : f32
    %410 = llvm.mlir.constant(32 : index) : i64
    %411 = llvm.mul %8, %410  : i64
    %412 = llvm.mlir.constant(8 : index) : i64
    %413 = llvm.mul %343, %412  : i64
    %414 = llvm.add %411, %413  : i64
    %415 = llvm.add %414, %4  : i64
    %416 = llvm.getelementptr %20[%415] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %417 = llvm.load %416 : !llvm.ptr<f32>
    %418 = llvm.mlir.constant(32 : index) : i64
    %419 = llvm.mul %8, %418  : i64
    %420 = llvm.mlir.constant(4 : index) : i64
    %421 = llvm.mul %4, %420  : i64
    %422 = llvm.add %419, %421  : i64
    %423 = llvm.add %422, %346  : i64
    %424 = llvm.getelementptr %173[%423] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %425 = llvm.load %424 : !llvm.ptr<f32>
    %426 = arith.mulf %417, %425 : f32
    %427 = arith.addf %409, %426 : f32
    %428 = llvm.mlir.constant(32 : index) : i64
    %429 = llvm.mul %8, %428  : i64
    %430 = llvm.mlir.constant(8 : index) : i64
    %431 = llvm.mul %343, %430  : i64
    %432 = llvm.add %429, %431  : i64
    %433 = llvm.add %432, %9  : i64
    %434 = llvm.getelementptr %20[%433] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %435 = llvm.load %434 : !llvm.ptr<f32>
    %436 = llvm.mlir.constant(32 : index) : i64
    %437 = llvm.mul %8, %436  : i64
    %438 = llvm.mlir.constant(4 : index) : i64
    %439 = llvm.mul %9, %438  : i64
    %440 = llvm.add %437, %439  : i64
    %441 = llvm.add %440, %346  : i64
    %442 = llvm.getelementptr %173[%441] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %443 = llvm.load %442 : !llvm.ptr<f32>
    %444 = arith.mulf %435, %443 : f32
    %445 = arith.addf %427, %444 : f32
    %446 = llvm.mlir.constant(32 : index) : i64
    %447 = llvm.mul %8, %446  : i64
    %448 = llvm.mlir.constant(8 : index) : i64
    %449 = llvm.mul %343, %448  : i64
    %450 = llvm.add %447, %449  : i64
    %451 = llvm.add %450, %5  : i64
    %452 = llvm.getelementptr %20[%451] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %453 = llvm.load %452 : !llvm.ptr<f32>
    %454 = llvm.mlir.constant(32 : index) : i64
    %455 = llvm.mul %8, %454  : i64
    %456 = llvm.mlir.constant(4 : index) : i64
    %457 = llvm.mul %5, %456  : i64
    %458 = llvm.add %455, %457  : i64
    %459 = llvm.add %458, %346  : i64
    %460 = llvm.getelementptr %173[%459] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %461 = llvm.load %460 : !llvm.ptr<f32>
    %462 = arith.mulf %453, %461 : f32
    %463 = arith.addf %445, %462 : f32
    %464 = llvm.mlir.constant(32 : index) : i64
    %465 = llvm.mul %8, %464  : i64
    %466 = llvm.mlir.constant(8 : index) : i64
    %467 = llvm.mul %343, %466  : i64
    %468 = llvm.add %465, %467  : i64
    %469 = llvm.add %468, %6  : i64
    %470 = llvm.getelementptr %20[%469] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %471 = llvm.load %470 : !llvm.ptr<f32>
    %472 = llvm.mlir.constant(32 : index) : i64
    %473 = llvm.mul %8, %472  : i64
    %474 = llvm.mlir.constant(4 : index) : i64
    %475 = llvm.mul %6, %474  : i64
    %476 = llvm.add %473, %475  : i64
    %477 = llvm.add %476, %346  : i64
    %478 = llvm.getelementptr %173[%477] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %479 = llvm.load %478 : !llvm.ptr<f32>
    %480 = arith.mulf %471, %479 : f32
    %481 = arith.addf %463, %480 : f32
    %482 = llvm.mlir.constant(32 : index) : i64
    %483 = llvm.mul %8, %482  : i64
    %484 = llvm.mlir.constant(8 : index) : i64
    %485 = llvm.mul %343, %484  : i64
    %486 = llvm.add %483, %485  : i64
    %487 = llvm.add %486, %7  : i64
    %488 = llvm.getelementptr %20[%487] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %489 = llvm.load %488 : !llvm.ptr<f32>
    %490 = llvm.mlir.constant(32 : index) : i64
    %491 = llvm.mul %8, %490  : i64
    %492 = llvm.mlir.constant(4 : index) : i64
    %493 = llvm.mul %7, %492  : i64
    %494 = llvm.add %491, %493  : i64
    %495 = llvm.add %494, %346  : i64
    %496 = llvm.getelementptr %173[%495] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %497 = llvm.load %496 : !llvm.ptr<f32>
    %498 = arith.mulf %489, %497 : f32
    %499 = arith.addf %481, %498 : f32
    %500 = llvm.mlir.constant(16 : index) : i64
    %501 = llvm.mul %8, %500  : i64
    %502 = llvm.mlir.constant(4 : index) : i64
    %503 = llvm.mul %343, %502  : i64
    %504 = llvm.add %501, %503  : i64
    %505 = llvm.add %504, %346  : i64
    %506 = llvm.getelementptr %262[%505] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %499, %506 : !llvm.ptr<f32>
    %507 = arith.addi %345, %c1 : index
    cf.br ^bb10(%507 : index)
  ^bb12:  // pred: ^bb10
    %508 = arith.addi %342, %c1 : index
    cf.br ^bb9(%508 : index)
  ^bb13(%509: index):  // 2 preds: ^bb9, ^bb14
    %510 = builtin.unrealized_conversion_cast %509 : index to i64
    %511 = arith.cmpi slt, %509, %c4 : index
    cf.cond_br %511, ^bb14, ^bb15
  ^bb14:  // pred: ^bb13
    %512 = llvm.mlir.constant(16 : index) : i64
    %513 = llvm.mul %8, %512  : i64
    %514 = llvm.mlir.constant(4 : index) : i64
    %515 = llvm.mul %510, %514  : i64
    %516 = llvm.add %513, %515  : i64
    %517 = llvm.add %516, %8  : i64
    %518 = llvm.getelementptr %262[%517] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %519 = llvm.load %518 : !llvm.ptr<f32>
    %520 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %521 = llvm.mlir.constant(16 : index) : i64
    %522 = llvm.mul %8, %521  : i64
    %523 = llvm.mlir.constant(4 : index) : i64
    %524 = llvm.mul %510, %523  : i64
    %525 = llvm.add %522, %524  : i64
    %526 = llvm.add %525, %8  : i64
    %527 = llvm.getelementptr %520[%526] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %519, %527 : !llvm.ptr<f32>
    %528 = llvm.mlir.constant(16 : index) : i64
    %529 = llvm.mul %8, %528  : i64
    %530 = llvm.mlir.constant(4 : index) : i64
    %531 = llvm.mul %510, %530  : i64
    %532 = llvm.add %529, %531  : i64
    %533 = llvm.add %532, %10  : i64
    %534 = llvm.getelementptr %262[%533] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %535 = llvm.load %534 : !llvm.ptr<f32>
    %536 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %537 = llvm.mlir.constant(16 : index) : i64
    %538 = llvm.mul %8, %537  : i64
    %539 = llvm.mlir.constant(4 : index) : i64
    %540 = llvm.mul %510, %539  : i64
    %541 = llvm.add %538, %540  : i64
    %542 = llvm.add %541, %10  : i64
    %543 = llvm.getelementptr %536[%542] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %535, %543 : !llvm.ptr<f32>
    %544 = llvm.mlir.constant(16 : index) : i64
    %545 = llvm.mul %8, %544  : i64
    %546 = llvm.mlir.constant(4 : index) : i64
    %547 = llvm.mul %510, %546  : i64
    %548 = llvm.add %545, %547  : i64
    %549 = llvm.add %548, %3  : i64
    %550 = llvm.getelementptr %262[%549] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %551 = llvm.load %550 : !llvm.ptr<f32>
    %552 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %553 = llvm.mlir.constant(16 : index) : i64
    %554 = llvm.mul %8, %553  : i64
    %555 = llvm.mlir.constant(4 : index) : i64
    %556 = llvm.mul %510, %555  : i64
    %557 = llvm.add %554, %556  : i64
    %558 = llvm.add %557, %3  : i64
    %559 = llvm.getelementptr %552[%558] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %551, %559 : !llvm.ptr<f32>
    %560 = llvm.mlir.constant(16 : index) : i64
    %561 = llvm.mul %8, %560  : i64
    %562 = llvm.mlir.constant(4 : index) : i64
    %563 = llvm.mul %510, %562  : i64
    %564 = llvm.add %561, %563  : i64
    %565 = llvm.add %564, %4  : i64
    %566 = llvm.getelementptr %262[%565] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %567 = llvm.load %566 : !llvm.ptr<f32>
    %568 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %569 = llvm.mlir.constant(16 : index) : i64
    %570 = llvm.mul %8, %569  : i64
    %571 = llvm.mlir.constant(4 : index) : i64
    %572 = llvm.mul %510, %571  : i64
    %573 = llvm.add %570, %572  : i64
    %574 = llvm.add %573, %4  : i64
    %575 = llvm.getelementptr %568[%574] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %567, %575 : !llvm.ptr<f32>
    %576 = arith.addi %509, %c1 : index
    cf.br ^bb13(%576 : index)
  ^bb15:  // pred: ^bb13
    return
  }
}


// -----// IR Dump After ArithmeticExpandOps //----- //
module attributes {soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
    %0 = builtin.unrealized_conversion_cast %arg2 : memref<1x4x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %1 = builtin.unrealized_conversion_cast %arg1 : memref<1x8x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %2 = builtin.unrealized_conversion_cast %arg0 : memref<1x4x8xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %c2 = arith.constant 2 : index
    %3 = builtin.unrealized_conversion_cast %c2 : index to i64
    %c3 = arith.constant 3 : index
    %4 = builtin.unrealized_conversion_cast %c3 : index to i64
    %c5 = arith.constant 5 : index
    %5 = builtin.unrealized_conversion_cast %c5 : index to i64
    %c6 = arith.constant 6 : index
    %6 = builtin.unrealized_conversion_cast %c6 : index to i64
    %c7 = arith.constant 7 : index
    %7 = builtin.unrealized_conversion_cast %c7 : index to i64
    %c8 = arith.constant 8 : index
    %c0 = arith.constant 0 : index
    %8 = builtin.unrealized_conversion_cast %c0 : index to i64
    %c4 = arith.constant 4 : index
    %9 = builtin.unrealized_conversion_cast %c4 : index to i64
    %c1 = arith.constant 1 : index
    %10 = builtin.unrealized_conversion_cast %c1 : index to i64
    %11 = llvm.mlir.constant(1 : index) : i64
    %12 = llvm.mlir.constant(4 : index) : i64
    %13 = llvm.mlir.constant(8 : index) : i64
    %14 = llvm.mlir.constant(1 : index) : i64
    %15 = llvm.mlir.constant(32 : index) : i64
    %16 = llvm.mlir.constant(32 : index) : i64
    %17 = llvm.mlir.null : !llvm.ptr<f32>
    %18 = llvm.getelementptr %17[%16] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %19 = llvm.ptrtoint %18 : !llvm.ptr<f32> to i64
    %20 = llvm.alloca %19 x f32 : (i64) -> !llvm.ptr<f32>
    %21 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %22 = llvm.insertvalue %20, %21[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %23 = llvm.insertvalue %20, %22[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %24 = llvm.mlir.constant(0 : index) : i64
    %25 = llvm.insertvalue %24, %23[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %26 = llvm.insertvalue %11, %25[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %27 = llvm.insertvalue %12, %26[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %28 = llvm.insertvalue %13, %27[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %29 = llvm.insertvalue %15, %28[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %30 = llvm.insertvalue %13, %29[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %31 = llvm.insertvalue %14, %30[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb1(%c0 : index)
  ^bb1(%32: index):  // 2 preds: ^bb0, ^bb2
    %33 = builtin.unrealized_conversion_cast %32 : index to i64
    %34 = arith.cmpi slt, %32, %c4 : index
    cf.cond_br %34, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %35 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %36 = llvm.mlir.constant(32 : index) : i64
    %37 = llvm.mul %8, %36  : i64
    %38 = llvm.mlir.constant(8 : index) : i64
    %39 = llvm.mul %33, %38  : i64
    %40 = llvm.add %37, %39  : i64
    %41 = llvm.add %40, %8  : i64
    %42 = llvm.getelementptr %35[%41] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %43 = llvm.load %42 : !llvm.ptr<f32>
    %44 = llvm.mlir.constant(32 : index) : i64
    %45 = llvm.mul %8, %44  : i64
    %46 = llvm.mlir.constant(8 : index) : i64
    %47 = llvm.mul %33, %46  : i64
    %48 = llvm.add %45, %47  : i64
    %49 = llvm.add %48, %8  : i64
    %50 = llvm.getelementptr %20[%49] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %43, %50 : !llvm.ptr<f32>
    %51 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %52 = llvm.mlir.constant(32 : index) : i64
    %53 = llvm.mul %8, %52  : i64
    %54 = llvm.mlir.constant(8 : index) : i64
    %55 = llvm.mul %33, %54  : i64
    %56 = llvm.add %53, %55  : i64
    %57 = llvm.add %56, %10  : i64
    %58 = llvm.getelementptr %51[%57] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %59 = llvm.load %58 : !llvm.ptr<f32>
    %60 = llvm.mlir.constant(32 : index) : i64
    %61 = llvm.mul %8, %60  : i64
    %62 = llvm.mlir.constant(8 : index) : i64
    %63 = llvm.mul %33, %62  : i64
    %64 = llvm.add %61, %63  : i64
    %65 = llvm.add %64, %10  : i64
    %66 = llvm.getelementptr %20[%65] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %59, %66 : !llvm.ptr<f32>
    %67 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %68 = llvm.mlir.constant(32 : index) : i64
    %69 = llvm.mul %8, %68  : i64
    %70 = llvm.mlir.constant(8 : index) : i64
    %71 = llvm.mul %33, %70  : i64
    %72 = llvm.add %69, %71  : i64
    %73 = llvm.add %72, %3  : i64
    %74 = llvm.getelementptr %67[%73] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %75 = llvm.load %74 : !llvm.ptr<f32>
    %76 = llvm.mlir.constant(32 : index) : i64
    %77 = llvm.mul %8, %76  : i64
    %78 = llvm.mlir.constant(8 : index) : i64
    %79 = llvm.mul %33, %78  : i64
    %80 = llvm.add %77, %79  : i64
    %81 = llvm.add %80, %3  : i64
    %82 = llvm.getelementptr %20[%81] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %75, %82 : !llvm.ptr<f32>
    %83 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %84 = llvm.mlir.constant(32 : index) : i64
    %85 = llvm.mul %8, %84  : i64
    %86 = llvm.mlir.constant(8 : index) : i64
    %87 = llvm.mul %33, %86  : i64
    %88 = llvm.add %85, %87  : i64
    %89 = llvm.add %88, %4  : i64
    %90 = llvm.getelementptr %83[%89] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %91 = llvm.load %90 : !llvm.ptr<f32>
    %92 = llvm.mlir.constant(32 : index) : i64
    %93 = llvm.mul %8, %92  : i64
    %94 = llvm.mlir.constant(8 : index) : i64
    %95 = llvm.mul %33, %94  : i64
    %96 = llvm.add %93, %95  : i64
    %97 = llvm.add %96, %4  : i64
    %98 = llvm.getelementptr %20[%97] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %91, %98 : !llvm.ptr<f32>
    %99 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %100 = llvm.mlir.constant(32 : index) : i64
    %101 = llvm.mul %8, %100  : i64
    %102 = llvm.mlir.constant(8 : index) : i64
    %103 = llvm.mul %33, %102  : i64
    %104 = llvm.add %101, %103  : i64
    %105 = llvm.add %104, %9  : i64
    %106 = llvm.getelementptr %99[%105] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %107 = llvm.load %106 : !llvm.ptr<f32>
    %108 = llvm.mlir.constant(32 : index) : i64
    %109 = llvm.mul %8, %108  : i64
    %110 = llvm.mlir.constant(8 : index) : i64
    %111 = llvm.mul %33, %110  : i64
    %112 = llvm.add %109, %111  : i64
    %113 = llvm.add %112, %9  : i64
    %114 = llvm.getelementptr %20[%113] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %107, %114 : !llvm.ptr<f32>
    %115 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %116 = llvm.mlir.constant(32 : index) : i64
    %117 = llvm.mul %8, %116  : i64
    %118 = llvm.mlir.constant(8 : index) : i64
    %119 = llvm.mul %33, %118  : i64
    %120 = llvm.add %117, %119  : i64
    %121 = llvm.add %120, %5  : i64
    %122 = llvm.getelementptr %115[%121] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %123 = llvm.load %122 : !llvm.ptr<f32>
    %124 = llvm.mlir.constant(32 : index) : i64
    %125 = llvm.mul %8, %124  : i64
    %126 = llvm.mlir.constant(8 : index) : i64
    %127 = llvm.mul %33, %126  : i64
    %128 = llvm.add %125, %127  : i64
    %129 = llvm.add %128, %5  : i64
    %130 = llvm.getelementptr %20[%129] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %123, %130 : !llvm.ptr<f32>
    %131 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %132 = llvm.mlir.constant(32 : index) : i64
    %133 = llvm.mul %8, %132  : i64
    %134 = llvm.mlir.constant(8 : index) : i64
    %135 = llvm.mul %33, %134  : i64
    %136 = llvm.add %133, %135  : i64
    %137 = llvm.add %136, %6  : i64
    %138 = llvm.getelementptr %131[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %139 = llvm.load %138 : !llvm.ptr<f32>
    %140 = llvm.mlir.constant(32 : index) : i64
    %141 = llvm.mul %8, %140  : i64
    %142 = llvm.mlir.constant(8 : index) : i64
    %143 = llvm.mul %33, %142  : i64
    %144 = llvm.add %141, %143  : i64
    %145 = llvm.add %144, %6  : i64
    %146 = llvm.getelementptr %20[%145] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %139, %146 : !llvm.ptr<f32>
    %147 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %148 = llvm.mlir.constant(32 : index) : i64
    %149 = llvm.mul %8, %148  : i64
    %150 = llvm.mlir.constant(8 : index) : i64
    %151 = llvm.mul %33, %150  : i64
    %152 = llvm.add %149, %151  : i64
    %153 = llvm.add %152, %7  : i64
    %154 = llvm.getelementptr %147[%153] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %155 = llvm.load %154 : !llvm.ptr<f32>
    %156 = llvm.mlir.constant(32 : index) : i64
    %157 = llvm.mul %8, %156  : i64
    %158 = llvm.mlir.constant(8 : index) : i64
    %159 = llvm.mul %33, %158  : i64
    %160 = llvm.add %157, %159  : i64
    %161 = llvm.add %160, %7  : i64
    %162 = llvm.getelementptr %20[%161] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %155, %162 : !llvm.ptr<f32>
    %163 = arith.addi %32, %c1 : index
    cf.br ^bb1(%163 : index)
  ^bb3:  // pred: ^bb1
    %164 = llvm.mlir.constant(1 : index) : i64
    %165 = llvm.mlir.constant(8 : index) : i64
    %166 = llvm.mlir.constant(4 : index) : i64
    %167 = llvm.mlir.constant(1 : index) : i64
    %168 = llvm.mlir.constant(32 : index) : i64
    %169 = llvm.mlir.constant(32 : index) : i64
    %170 = llvm.mlir.null : !llvm.ptr<f32>
    %171 = llvm.getelementptr %170[%169] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %172 = llvm.ptrtoint %171 : !llvm.ptr<f32> to i64
    %173 = llvm.alloca %172 x f32 : (i64) -> !llvm.ptr<f32>
    %174 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %175 = llvm.insertvalue %173, %174[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %176 = llvm.insertvalue %173, %175[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %177 = llvm.mlir.constant(0 : index) : i64
    %178 = llvm.insertvalue %177, %176[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %179 = llvm.insertvalue %164, %178[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %180 = llvm.insertvalue %165, %179[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %181 = llvm.insertvalue %166, %180[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %182 = llvm.insertvalue %168, %181[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %183 = llvm.insertvalue %166, %182[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %184 = llvm.insertvalue %167, %183[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb4(%c0 : index)
  ^bb4(%185: index):  // 2 preds: ^bb3, ^bb5
    %186 = builtin.unrealized_conversion_cast %185 : index to i64
    %187 = arith.cmpi slt, %185, %c8 : index
    cf.cond_br %187, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %188 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %189 = llvm.mlir.constant(32 : index) : i64
    %190 = llvm.mul %8, %189  : i64
    %191 = llvm.mlir.constant(4 : index) : i64
    %192 = llvm.mul %186, %191  : i64
    %193 = llvm.add %190, %192  : i64
    %194 = llvm.add %193, %8  : i64
    %195 = llvm.getelementptr %188[%194] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %196 = llvm.load %195 : !llvm.ptr<f32>
    %197 = llvm.mlir.constant(32 : index) : i64
    %198 = llvm.mul %8, %197  : i64
    %199 = llvm.mlir.constant(4 : index) : i64
    %200 = llvm.mul %186, %199  : i64
    %201 = llvm.add %198, %200  : i64
    %202 = llvm.add %201, %8  : i64
    %203 = llvm.getelementptr %173[%202] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %196, %203 : !llvm.ptr<f32>
    %204 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %205 = llvm.mlir.constant(32 : index) : i64
    %206 = llvm.mul %8, %205  : i64
    %207 = llvm.mlir.constant(4 : index) : i64
    %208 = llvm.mul %186, %207  : i64
    %209 = llvm.add %206, %208  : i64
    %210 = llvm.add %209, %10  : i64
    %211 = llvm.getelementptr %204[%210] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %212 = llvm.load %211 : !llvm.ptr<f32>
    %213 = llvm.mlir.constant(32 : index) : i64
    %214 = llvm.mul %8, %213  : i64
    %215 = llvm.mlir.constant(4 : index) : i64
    %216 = llvm.mul %186, %215  : i64
    %217 = llvm.add %214, %216  : i64
    %218 = llvm.add %217, %10  : i64
    %219 = llvm.getelementptr %173[%218] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %212, %219 : !llvm.ptr<f32>
    %220 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %221 = llvm.mlir.constant(32 : index) : i64
    %222 = llvm.mul %8, %221  : i64
    %223 = llvm.mlir.constant(4 : index) : i64
    %224 = llvm.mul %186, %223  : i64
    %225 = llvm.add %222, %224  : i64
    %226 = llvm.add %225, %3  : i64
    %227 = llvm.getelementptr %220[%226] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %228 = llvm.load %227 : !llvm.ptr<f32>
    %229 = llvm.mlir.constant(32 : index) : i64
    %230 = llvm.mul %8, %229  : i64
    %231 = llvm.mlir.constant(4 : index) : i64
    %232 = llvm.mul %186, %231  : i64
    %233 = llvm.add %230, %232  : i64
    %234 = llvm.add %233, %3  : i64
    %235 = llvm.getelementptr %173[%234] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %228, %235 : !llvm.ptr<f32>
    %236 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %237 = llvm.mlir.constant(32 : index) : i64
    %238 = llvm.mul %8, %237  : i64
    %239 = llvm.mlir.constant(4 : index) : i64
    %240 = llvm.mul %186, %239  : i64
    %241 = llvm.add %238, %240  : i64
    %242 = llvm.add %241, %4  : i64
    %243 = llvm.getelementptr %236[%242] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %244 = llvm.load %243 : !llvm.ptr<f32>
    %245 = llvm.mlir.constant(32 : index) : i64
    %246 = llvm.mul %8, %245  : i64
    %247 = llvm.mlir.constant(4 : index) : i64
    %248 = llvm.mul %186, %247  : i64
    %249 = llvm.add %246, %248  : i64
    %250 = llvm.add %249, %4  : i64
    %251 = llvm.getelementptr %173[%250] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %244, %251 : !llvm.ptr<f32>
    %252 = arith.addi %185, %c1 : index
    cf.br ^bb4(%252 : index)
  ^bb6:  // pred: ^bb4
    %253 = llvm.mlir.constant(1 : index) : i64
    %254 = llvm.mlir.constant(4 : index) : i64
    %255 = llvm.mlir.constant(4 : index) : i64
    %256 = llvm.mlir.constant(1 : index) : i64
    %257 = llvm.mlir.constant(16 : index) : i64
    %258 = llvm.mlir.constant(16 : index) : i64
    %259 = llvm.mlir.null : !llvm.ptr<f32>
    %260 = llvm.getelementptr %259[%258] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %261 = llvm.ptrtoint %260 : !llvm.ptr<f32> to i64
    %262 = llvm.alloca %261 x f32 : (i64) -> !llvm.ptr<f32>
    %263 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %264 = llvm.insertvalue %262, %263[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %265 = llvm.insertvalue %262, %264[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %266 = llvm.mlir.constant(0 : index) : i64
    %267 = llvm.insertvalue %266, %265[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %268 = llvm.insertvalue %253, %267[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %269 = llvm.insertvalue %254, %268[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %270 = llvm.insertvalue %255, %269[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %271 = llvm.insertvalue %257, %270[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %272 = llvm.insertvalue %255, %271[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %273 = llvm.insertvalue %256, %272[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    cf.br ^bb7(%c0 : index)
  ^bb7(%274: index):  // 2 preds: ^bb6, ^bb8
    %275 = builtin.unrealized_conversion_cast %274 : index to i64
    %276 = arith.cmpi slt, %274, %c4 : index
    cf.cond_br %276, ^bb8, ^bb9(%c0 : index)
  ^bb8:  // pred: ^bb7
    %277 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %278 = llvm.mlir.constant(16 : index) : i64
    %279 = llvm.mul %8, %278  : i64
    %280 = llvm.mlir.constant(4 : index) : i64
    %281 = llvm.mul %275, %280  : i64
    %282 = llvm.add %279, %281  : i64
    %283 = llvm.add %282, %8  : i64
    %284 = llvm.getelementptr %277[%283] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %285 = llvm.load %284 : !llvm.ptr<f32>
    %286 = llvm.mlir.constant(16 : index) : i64
    %287 = llvm.mul %8, %286  : i64
    %288 = llvm.mlir.constant(4 : index) : i64
    %289 = llvm.mul %275, %288  : i64
    %290 = llvm.add %287, %289  : i64
    %291 = llvm.add %290, %8  : i64
    %292 = llvm.getelementptr %262[%291] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %285, %292 : !llvm.ptr<f32>
    %293 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %294 = llvm.mlir.constant(16 : index) : i64
    %295 = llvm.mul %8, %294  : i64
    %296 = llvm.mlir.constant(4 : index) : i64
    %297 = llvm.mul %275, %296  : i64
    %298 = llvm.add %295, %297  : i64
    %299 = llvm.add %298, %10  : i64
    %300 = llvm.getelementptr %293[%299] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %301 = llvm.load %300 : !llvm.ptr<f32>
    %302 = llvm.mlir.constant(16 : index) : i64
    %303 = llvm.mul %8, %302  : i64
    %304 = llvm.mlir.constant(4 : index) : i64
    %305 = llvm.mul %275, %304  : i64
    %306 = llvm.add %303, %305  : i64
    %307 = llvm.add %306, %10  : i64
    %308 = llvm.getelementptr %262[%307] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %301, %308 : !llvm.ptr<f32>
    %309 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %310 = llvm.mlir.constant(16 : index) : i64
    %311 = llvm.mul %8, %310  : i64
    %312 = llvm.mlir.constant(4 : index) : i64
    %313 = llvm.mul %275, %312  : i64
    %314 = llvm.add %311, %313  : i64
    %315 = llvm.add %314, %3  : i64
    %316 = llvm.getelementptr %309[%315] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %317 = llvm.load %316 : !llvm.ptr<f32>
    %318 = llvm.mlir.constant(16 : index) : i64
    %319 = llvm.mul %8, %318  : i64
    %320 = llvm.mlir.constant(4 : index) : i64
    %321 = llvm.mul %275, %320  : i64
    %322 = llvm.add %319, %321  : i64
    %323 = llvm.add %322, %3  : i64
    %324 = llvm.getelementptr %262[%323] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %317, %324 : !llvm.ptr<f32>
    %325 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %326 = llvm.mlir.constant(16 : index) : i64
    %327 = llvm.mul %8, %326  : i64
    %328 = llvm.mlir.constant(4 : index) : i64
    %329 = llvm.mul %275, %328  : i64
    %330 = llvm.add %327, %329  : i64
    %331 = llvm.add %330, %4  : i64
    %332 = llvm.getelementptr %325[%331] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %333 = llvm.load %332 : !llvm.ptr<f32>
    %334 = llvm.mlir.constant(16 : index) : i64
    %335 = llvm.mul %8, %334  : i64
    %336 = llvm.mlir.constant(4 : index) : i64
    %337 = llvm.mul %275, %336  : i64
    %338 = llvm.add %335, %337  : i64
    %339 = llvm.add %338, %4  : i64
    %340 = llvm.getelementptr %262[%339] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %333, %340 : !llvm.ptr<f32>
    %341 = arith.addi %274, %c1 : index
    cf.br ^bb7(%341 : index)
  ^bb9(%342: index):  // 2 preds: ^bb7, ^bb12
    %343 = builtin.unrealized_conversion_cast %342 : index to i64
    %344 = arith.cmpi slt, %342, %c4 : index
    cf.cond_br %344, ^bb10(%c0 : index), ^bb13(%c0 : index)
  ^bb10(%345: index):  // 2 preds: ^bb9, ^bb11
    %346 = builtin.unrealized_conversion_cast %345 : index to i64
    %347 = arith.cmpi slt, %345, %c4 : index
    cf.cond_br %347, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %348 = llvm.mlir.constant(32 : index) : i64
    %349 = llvm.mul %8, %348  : i64
    %350 = llvm.mlir.constant(8 : index) : i64
    %351 = llvm.mul %343, %350  : i64
    %352 = llvm.add %349, %351  : i64
    %353 = llvm.add %352, %8  : i64
    %354 = llvm.getelementptr %20[%353] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %355 = llvm.load %354 : !llvm.ptr<f32>
    %356 = llvm.mlir.constant(32 : index) : i64
    %357 = llvm.mul %8, %356  : i64
    %358 = llvm.mlir.constant(4 : index) : i64
    %359 = llvm.mul %8, %358  : i64
    %360 = llvm.add %357, %359  : i64
    %361 = llvm.add %360, %346  : i64
    %362 = llvm.getelementptr %173[%361] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %363 = llvm.load %362 : !llvm.ptr<f32>
    %364 = llvm.mlir.constant(16 : index) : i64
    %365 = llvm.mul %8, %364  : i64
    %366 = llvm.mlir.constant(4 : index) : i64
    %367 = llvm.mul %343, %366  : i64
    %368 = llvm.add %365, %367  : i64
    %369 = llvm.add %368, %346  : i64
    %370 = llvm.getelementptr %262[%369] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %371 = llvm.load %370 : !llvm.ptr<f32>
    %372 = arith.mulf %355, %363 : f32
    %373 = arith.addf %371, %372 : f32
    %374 = llvm.mlir.constant(32 : index) : i64
    %375 = llvm.mul %8, %374  : i64
    %376 = llvm.mlir.constant(8 : index) : i64
    %377 = llvm.mul %343, %376  : i64
    %378 = llvm.add %375, %377  : i64
    %379 = llvm.add %378, %10  : i64
    %380 = llvm.getelementptr %20[%379] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %381 = llvm.load %380 : !llvm.ptr<f32>
    %382 = llvm.mlir.constant(32 : index) : i64
    %383 = llvm.mul %8, %382  : i64
    %384 = llvm.mlir.constant(4 : index) : i64
    %385 = llvm.mul %10, %384  : i64
    %386 = llvm.add %383, %385  : i64
    %387 = llvm.add %386, %346  : i64
    %388 = llvm.getelementptr %173[%387] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %389 = llvm.load %388 : !llvm.ptr<f32>
    %390 = arith.mulf %381, %389 : f32
    %391 = arith.addf %373, %390 : f32
    %392 = llvm.mlir.constant(32 : index) : i64
    %393 = llvm.mul %8, %392  : i64
    %394 = llvm.mlir.constant(8 : index) : i64
    %395 = llvm.mul %343, %394  : i64
    %396 = llvm.add %393, %395  : i64
    %397 = llvm.add %396, %3  : i64
    %398 = llvm.getelementptr %20[%397] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %399 = llvm.load %398 : !llvm.ptr<f32>
    %400 = llvm.mlir.constant(32 : index) : i64
    %401 = llvm.mul %8, %400  : i64
    %402 = llvm.mlir.constant(4 : index) : i64
    %403 = llvm.mul %3, %402  : i64
    %404 = llvm.add %401, %403  : i64
    %405 = llvm.add %404, %346  : i64
    %406 = llvm.getelementptr %173[%405] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %407 = llvm.load %406 : !llvm.ptr<f32>
    %408 = arith.mulf %399, %407 : f32
    %409 = arith.addf %391, %408 : f32
    %410 = llvm.mlir.constant(32 : index) : i64
    %411 = llvm.mul %8, %410  : i64
    %412 = llvm.mlir.constant(8 : index) : i64
    %413 = llvm.mul %343, %412  : i64
    %414 = llvm.add %411, %413  : i64
    %415 = llvm.add %414, %4  : i64
    %416 = llvm.getelementptr %20[%415] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %417 = llvm.load %416 : !llvm.ptr<f32>
    %418 = llvm.mlir.constant(32 : index) : i64
    %419 = llvm.mul %8, %418  : i64
    %420 = llvm.mlir.constant(4 : index) : i64
    %421 = llvm.mul %4, %420  : i64
    %422 = llvm.add %419, %421  : i64
    %423 = llvm.add %422, %346  : i64
    %424 = llvm.getelementptr %173[%423] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %425 = llvm.load %424 : !llvm.ptr<f32>
    %426 = arith.mulf %417, %425 : f32
    %427 = arith.addf %409, %426 : f32
    %428 = llvm.mlir.constant(32 : index) : i64
    %429 = llvm.mul %8, %428  : i64
    %430 = llvm.mlir.constant(8 : index) : i64
    %431 = llvm.mul %343, %430  : i64
    %432 = llvm.add %429, %431  : i64
    %433 = llvm.add %432, %9  : i64
    %434 = llvm.getelementptr %20[%433] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %435 = llvm.load %434 : !llvm.ptr<f32>
    %436 = llvm.mlir.constant(32 : index) : i64
    %437 = llvm.mul %8, %436  : i64
    %438 = llvm.mlir.constant(4 : index) : i64
    %439 = llvm.mul %9, %438  : i64
    %440 = llvm.add %437, %439  : i64
    %441 = llvm.add %440, %346  : i64
    %442 = llvm.getelementptr %173[%441] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %443 = llvm.load %442 : !llvm.ptr<f32>
    %444 = arith.mulf %435, %443 : f32
    %445 = arith.addf %427, %444 : f32
    %446 = llvm.mlir.constant(32 : index) : i64
    %447 = llvm.mul %8, %446  : i64
    %448 = llvm.mlir.constant(8 : index) : i64
    %449 = llvm.mul %343, %448  : i64
    %450 = llvm.add %447, %449  : i64
    %451 = llvm.add %450, %5  : i64
    %452 = llvm.getelementptr %20[%451] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %453 = llvm.load %452 : !llvm.ptr<f32>
    %454 = llvm.mlir.constant(32 : index) : i64
    %455 = llvm.mul %8, %454  : i64
    %456 = llvm.mlir.constant(4 : index) : i64
    %457 = llvm.mul %5, %456  : i64
    %458 = llvm.add %455, %457  : i64
    %459 = llvm.add %458, %346  : i64
    %460 = llvm.getelementptr %173[%459] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %461 = llvm.load %460 : !llvm.ptr<f32>
    %462 = arith.mulf %453, %461 : f32
    %463 = arith.addf %445, %462 : f32
    %464 = llvm.mlir.constant(32 : index) : i64
    %465 = llvm.mul %8, %464  : i64
    %466 = llvm.mlir.constant(8 : index) : i64
    %467 = llvm.mul %343, %466  : i64
    %468 = llvm.add %465, %467  : i64
    %469 = llvm.add %468, %6  : i64
    %470 = llvm.getelementptr %20[%469] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %471 = llvm.load %470 : !llvm.ptr<f32>
    %472 = llvm.mlir.constant(32 : index) : i64
    %473 = llvm.mul %8, %472  : i64
    %474 = llvm.mlir.constant(4 : index) : i64
    %475 = llvm.mul %6, %474  : i64
    %476 = llvm.add %473, %475  : i64
    %477 = llvm.add %476, %346  : i64
    %478 = llvm.getelementptr %173[%477] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %479 = llvm.load %478 : !llvm.ptr<f32>
    %480 = arith.mulf %471, %479 : f32
    %481 = arith.addf %463, %480 : f32
    %482 = llvm.mlir.constant(32 : index) : i64
    %483 = llvm.mul %8, %482  : i64
    %484 = llvm.mlir.constant(8 : index) : i64
    %485 = llvm.mul %343, %484  : i64
    %486 = llvm.add %483, %485  : i64
    %487 = llvm.add %486, %7  : i64
    %488 = llvm.getelementptr %20[%487] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %489 = llvm.load %488 : !llvm.ptr<f32>
    %490 = llvm.mlir.constant(32 : index) : i64
    %491 = llvm.mul %8, %490  : i64
    %492 = llvm.mlir.constant(4 : index) : i64
    %493 = llvm.mul %7, %492  : i64
    %494 = llvm.add %491, %493  : i64
    %495 = llvm.add %494, %346  : i64
    %496 = llvm.getelementptr %173[%495] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %497 = llvm.load %496 : !llvm.ptr<f32>
    %498 = arith.mulf %489, %497 : f32
    %499 = arith.addf %481, %498 : f32
    %500 = llvm.mlir.constant(16 : index) : i64
    %501 = llvm.mul %8, %500  : i64
    %502 = llvm.mlir.constant(4 : index) : i64
    %503 = llvm.mul %343, %502  : i64
    %504 = llvm.add %501, %503  : i64
    %505 = llvm.add %504, %346  : i64
    %506 = llvm.getelementptr %262[%505] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %499, %506 : !llvm.ptr<f32>
    %507 = arith.addi %345, %c1 : index
    cf.br ^bb10(%507 : index)
  ^bb12:  // pred: ^bb10
    %508 = arith.addi %342, %c1 : index
    cf.br ^bb9(%508 : index)
  ^bb13(%509: index):  // 2 preds: ^bb9, ^bb14
    %510 = builtin.unrealized_conversion_cast %509 : index to i64
    %511 = arith.cmpi slt, %509, %c4 : index
    cf.cond_br %511, ^bb14, ^bb15
  ^bb14:  // pred: ^bb13
    %512 = llvm.mlir.constant(16 : index) : i64
    %513 = llvm.mul %8, %512  : i64
    %514 = llvm.mlir.constant(4 : index) : i64
    %515 = llvm.mul %510, %514  : i64
    %516 = llvm.add %513, %515  : i64
    %517 = llvm.add %516, %8  : i64
    %518 = llvm.getelementptr %262[%517] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %519 = llvm.load %518 : !llvm.ptr<f32>
    %520 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %521 = llvm.mlir.constant(16 : index) : i64
    %522 = llvm.mul %8, %521  : i64
    %523 = llvm.mlir.constant(4 : index) : i64
    %524 = llvm.mul %510, %523  : i64
    %525 = llvm.add %522, %524  : i64
    %526 = llvm.add %525, %8  : i64
    %527 = llvm.getelementptr %520[%526] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %519, %527 : !llvm.ptr<f32>
    %528 = llvm.mlir.constant(16 : index) : i64
    %529 = llvm.mul %8, %528  : i64
    %530 = llvm.mlir.constant(4 : index) : i64
    %531 = llvm.mul %510, %530  : i64
    %532 = llvm.add %529, %531  : i64
    %533 = llvm.add %532, %10  : i64
    %534 = llvm.getelementptr %262[%533] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %535 = llvm.load %534 : !llvm.ptr<f32>
    %536 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %537 = llvm.mlir.constant(16 : index) : i64
    %538 = llvm.mul %8, %537  : i64
    %539 = llvm.mlir.constant(4 : index) : i64
    %540 = llvm.mul %510, %539  : i64
    %541 = llvm.add %538, %540  : i64
    %542 = llvm.add %541, %10  : i64
    %543 = llvm.getelementptr %536[%542] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %535, %543 : !llvm.ptr<f32>
    %544 = llvm.mlir.constant(16 : index) : i64
    %545 = llvm.mul %8, %544  : i64
    %546 = llvm.mlir.constant(4 : index) : i64
    %547 = llvm.mul %510, %546  : i64
    %548 = llvm.add %545, %547  : i64
    %549 = llvm.add %548, %3  : i64
    %550 = llvm.getelementptr %262[%549] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %551 = llvm.load %550 : !llvm.ptr<f32>
    %552 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %553 = llvm.mlir.constant(16 : index) : i64
    %554 = llvm.mul %8, %553  : i64
    %555 = llvm.mlir.constant(4 : index) : i64
    %556 = llvm.mul %510, %555  : i64
    %557 = llvm.add %554, %556  : i64
    %558 = llvm.add %557, %3  : i64
    %559 = llvm.getelementptr %552[%558] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %551, %559 : !llvm.ptr<f32>
    %560 = llvm.mlir.constant(16 : index) : i64
    %561 = llvm.mul %8, %560  : i64
    %562 = llvm.mlir.constant(4 : index) : i64
    %563 = llvm.mul %510, %562  : i64
    %564 = llvm.add %561, %563  : i64
    %565 = llvm.add %564, %4  : i64
    %566 = llvm.getelementptr %262[%565] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %567 = llvm.load %566 : !llvm.ptr<f32>
    %568 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %569 = llvm.mlir.constant(16 : index) : i64
    %570 = llvm.mul %8, %569  : i64
    %571 = llvm.mlir.constant(4 : index) : i64
    %572 = llvm.mul %510, %571  : i64
    %573 = llvm.add %570, %572  : i64
    %574 = llvm.add %573, %4  : i64
    %575 = llvm.getelementptr %568[%574] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %567, %575 : !llvm.ptr<f32>
    %576 = arith.addi %509, %c1 : index
    cf.br ^bb13(%576 : index)
  ^bb15:  // pred: ^bb13
    return
  }
}


// -----// IR Dump After ConvertArithmeticToLLVM //----- //
func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<1x4x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<1x8x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg0 : memref<1x4x8xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %3 = llvm.mlir.constant(2 : index) : i64
  %4 = builtin.unrealized_conversion_cast %3 : i64 to index
  %5 = builtin.unrealized_conversion_cast %4 : index to i64
  %6 = llvm.mlir.constant(3 : index) : i64
  %7 = builtin.unrealized_conversion_cast %6 : i64 to index
  %8 = builtin.unrealized_conversion_cast %7 : index to i64
  %9 = llvm.mlir.constant(5 : index) : i64
  %10 = builtin.unrealized_conversion_cast %9 : i64 to index
  %11 = builtin.unrealized_conversion_cast %10 : index to i64
  %12 = llvm.mlir.constant(6 : index) : i64
  %13 = builtin.unrealized_conversion_cast %12 : i64 to index
  %14 = builtin.unrealized_conversion_cast %13 : index to i64
  %15 = llvm.mlir.constant(7 : index) : i64
  %16 = builtin.unrealized_conversion_cast %15 : i64 to index
  %17 = builtin.unrealized_conversion_cast %16 : index to i64
  %18 = llvm.mlir.constant(8 : index) : i64
  %19 = llvm.mlir.constant(0 : index) : i64
  %20 = builtin.unrealized_conversion_cast %19 : i64 to index
  %21 = builtin.unrealized_conversion_cast %20 : index to i64
  %22 = llvm.mlir.constant(4 : index) : i64
  %23 = builtin.unrealized_conversion_cast %22 : i64 to index
  %24 = builtin.unrealized_conversion_cast %23 : index to i64
  %25 = llvm.mlir.constant(1 : index) : i64
  %26 = builtin.unrealized_conversion_cast %25 : i64 to index
  %27 = builtin.unrealized_conversion_cast %26 : index to i64
  %28 = llvm.mlir.constant(1 : index) : i64
  %29 = llvm.mlir.constant(4 : index) : i64
  %30 = llvm.mlir.constant(8 : index) : i64
  %31 = llvm.mlir.constant(1 : index) : i64
  %32 = llvm.mlir.constant(32 : index) : i64
  %33 = llvm.mlir.constant(32 : index) : i64
  %34 = llvm.mlir.null : !llvm.ptr<f32>
  %35 = llvm.getelementptr %34[%33] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %36 = llvm.ptrtoint %35 : !llvm.ptr<f32> to i64
  %37 = llvm.alloca %36 x f32 : (i64) -> !llvm.ptr<f32>
  %38 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %39 = llvm.insertvalue %37, %38[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %40 = llvm.insertvalue %37, %39[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %41 = llvm.mlir.constant(0 : index) : i64
  %42 = llvm.insertvalue %41, %40[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %43 = llvm.insertvalue %28, %42[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %44 = llvm.insertvalue %29, %43[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %45 = llvm.insertvalue %30, %44[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %46 = llvm.insertvalue %32, %45[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %47 = llvm.insertvalue %30, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %48 = llvm.insertvalue %31, %47[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb1(%20 : index)
^bb1(%49: index):  // 2 preds: ^bb0, ^bb2
  %50 = builtin.unrealized_conversion_cast %49 : index to i64
  %51 = builtin.unrealized_conversion_cast %49 : index to i64
  %52 = llvm.icmp "slt" %50, %22 : i64
  cf.cond_br %52, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %53 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %54 = llvm.mlir.constant(32 : index) : i64
  %55 = llvm.mul %21, %54  : i64
  %56 = llvm.mlir.constant(8 : index) : i64
  %57 = llvm.mul %51, %56  : i64
  %58 = llvm.add %55, %57  : i64
  %59 = llvm.add %58, %21  : i64
  %60 = llvm.getelementptr %53[%59] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %61 = llvm.load %60 : !llvm.ptr<f32>
  %62 = llvm.mlir.constant(32 : index) : i64
  %63 = llvm.mul %21, %62  : i64
  %64 = llvm.mlir.constant(8 : index) : i64
  %65 = llvm.mul %51, %64  : i64
  %66 = llvm.add %63, %65  : i64
  %67 = llvm.add %66, %21  : i64
  %68 = llvm.getelementptr %37[%67] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %61, %68 : !llvm.ptr<f32>
  %69 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %70 = llvm.mlir.constant(32 : index) : i64
  %71 = llvm.mul %21, %70  : i64
  %72 = llvm.mlir.constant(8 : index) : i64
  %73 = llvm.mul %51, %72  : i64
  %74 = llvm.add %71, %73  : i64
  %75 = llvm.add %74, %27  : i64
  %76 = llvm.getelementptr %69[%75] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %77 = llvm.load %76 : !llvm.ptr<f32>
  %78 = llvm.mlir.constant(32 : index) : i64
  %79 = llvm.mul %21, %78  : i64
  %80 = llvm.mlir.constant(8 : index) : i64
  %81 = llvm.mul %51, %80  : i64
  %82 = llvm.add %79, %81  : i64
  %83 = llvm.add %82, %27  : i64
  %84 = llvm.getelementptr %37[%83] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %77, %84 : !llvm.ptr<f32>
  %85 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %86 = llvm.mlir.constant(32 : index) : i64
  %87 = llvm.mul %21, %86  : i64
  %88 = llvm.mlir.constant(8 : index) : i64
  %89 = llvm.mul %51, %88  : i64
  %90 = llvm.add %87, %89  : i64
  %91 = llvm.add %90, %5  : i64
  %92 = llvm.getelementptr %85[%91] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %93 = llvm.load %92 : !llvm.ptr<f32>
  %94 = llvm.mlir.constant(32 : index) : i64
  %95 = llvm.mul %21, %94  : i64
  %96 = llvm.mlir.constant(8 : index) : i64
  %97 = llvm.mul %51, %96  : i64
  %98 = llvm.add %95, %97  : i64
  %99 = llvm.add %98, %5  : i64
  %100 = llvm.getelementptr %37[%99] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %93, %100 : !llvm.ptr<f32>
  %101 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %102 = llvm.mlir.constant(32 : index) : i64
  %103 = llvm.mul %21, %102  : i64
  %104 = llvm.mlir.constant(8 : index) : i64
  %105 = llvm.mul %51, %104  : i64
  %106 = llvm.add %103, %105  : i64
  %107 = llvm.add %106, %8  : i64
  %108 = llvm.getelementptr %101[%107] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %109 = llvm.load %108 : !llvm.ptr<f32>
  %110 = llvm.mlir.constant(32 : index) : i64
  %111 = llvm.mul %21, %110  : i64
  %112 = llvm.mlir.constant(8 : index) : i64
  %113 = llvm.mul %51, %112  : i64
  %114 = llvm.add %111, %113  : i64
  %115 = llvm.add %114, %8  : i64
  %116 = llvm.getelementptr %37[%115] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %109, %116 : !llvm.ptr<f32>
  %117 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %118 = llvm.mlir.constant(32 : index) : i64
  %119 = llvm.mul %21, %118  : i64
  %120 = llvm.mlir.constant(8 : index) : i64
  %121 = llvm.mul %51, %120  : i64
  %122 = llvm.add %119, %121  : i64
  %123 = llvm.add %122, %24  : i64
  %124 = llvm.getelementptr %117[%123] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %125 = llvm.load %124 : !llvm.ptr<f32>
  %126 = llvm.mlir.constant(32 : index) : i64
  %127 = llvm.mul %21, %126  : i64
  %128 = llvm.mlir.constant(8 : index) : i64
  %129 = llvm.mul %51, %128  : i64
  %130 = llvm.add %127, %129  : i64
  %131 = llvm.add %130, %24  : i64
  %132 = llvm.getelementptr %37[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %125, %132 : !llvm.ptr<f32>
  %133 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %134 = llvm.mlir.constant(32 : index) : i64
  %135 = llvm.mul %21, %134  : i64
  %136 = llvm.mlir.constant(8 : index) : i64
  %137 = llvm.mul %51, %136  : i64
  %138 = llvm.add %135, %137  : i64
  %139 = llvm.add %138, %11  : i64
  %140 = llvm.getelementptr %133[%139] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %141 = llvm.load %140 : !llvm.ptr<f32>
  %142 = llvm.mlir.constant(32 : index) : i64
  %143 = llvm.mul %21, %142  : i64
  %144 = llvm.mlir.constant(8 : index) : i64
  %145 = llvm.mul %51, %144  : i64
  %146 = llvm.add %143, %145  : i64
  %147 = llvm.add %146, %11  : i64
  %148 = llvm.getelementptr %37[%147] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %141, %148 : !llvm.ptr<f32>
  %149 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %150 = llvm.mlir.constant(32 : index) : i64
  %151 = llvm.mul %21, %150  : i64
  %152 = llvm.mlir.constant(8 : index) : i64
  %153 = llvm.mul %51, %152  : i64
  %154 = llvm.add %151, %153  : i64
  %155 = llvm.add %154, %14  : i64
  %156 = llvm.getelementptr %149[%155] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %157 = llvm.load %156 : !llvm.ptr<f32>
  %158 = llvm.mlir.constant(32 : index) : i64
  %159 = llvm.mul %21, %158  : i64
  %160 = llvm.mlir.constant(8 : index) : i64
  %161 = llvm.mul %51, %160  : i64
  %162 = llvm.add %159, %161  : i64
  %163 = llvm.add %162, %14  : i64
  %164 = llvm.getelementptr %37[%163] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %157, %164 : !llvm.ptr<f32>
  %165 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %166 = llvm.mlir.constant(32 : index) : i64
  %167 = llvm.mul %21, %166  : i64
  %168 = llvm.mlir.constant(8 : index) : i64
  %169 = llvm.mul %51, %168  : i64
  %170 = llvm.add %167, %169  : i64
  %171 = llvm.add %170, %17  : i64
  %172 = llvm.getelementptr %165[%171] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %173 = llvm.load %172 : !llvm.ptr<f32>
  %174 = llvm.mlir.constant(32 : index) : i64
  %175 = llvm.mul %21, %174  : i64
  %176 = llvm.mlir.constant(8 : index) : i64
  %177 = llvm.mul %51, %176  : i64
  %178 = llvm.add %175, %177  : i64
  %179 = llvm.add %178, %17  : i64
  %180 = llvm.getelementptr %37[%179] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %173, %180 : !llvm.ptr<f32>
  %181 = llvm.add %50, %25  : i64
  %182 = builtin.unrealized_conversion_cast %181 : i64 to index
  cf.br ^bb1(%182 : index)
^bb3:  // pred: ^bb1
  %183 = llvm.mlir.constant(1 : index) : i64
  %184 = llvm.mlir.constant(8 : index) : i64
  %185 = llvm.mlir.constant(4 : index) : i64
  %186 = llvm.mlir.constant(1 : index) : i64
  %187 = llvm.mlir.constant(32 : index) : i64
  %188 = llvm.mlir.constant(32 : index) : i64
  %189 = llvm.mlir.null : !llvm.ptr<f32>
  %190 = llvm.getelementptr %189[%188] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %191 = llvm.ptrtoint %190 : !llvm.ptr<f32> to i64
  %192 = llvm.alloca %191 x f32 : (i64) -> !llvm.ptr<f32>
  %193 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %194 = llvm.insertvalue %192, %193[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %195 = llvm.insertvalue %192, %194[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %196 = llvm.mlir.constant(0 : index) : i64
  %197 = llvm.insertvalue %196, %195[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %198 = llvm.insertvalue %183, %197[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %199 = llvm.insertvalue %184, %198[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %200 = llvm.insertvalue %185, %199[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %201 = llvm.insertvalue %187, %200[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %202 = llvm.insertvalue %185, %201[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %203 = llvm.insertvalue %186, %202[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb4(%20 : index)
^bb4(%204: index):  // 2 preds: ^bb3, ^bb5
  %205 = builtin.unrealized_conversion_cast %204 : index to i64
  %206 = builtin.unrealized_conversion_cast %204 : index to i64
  %207 = llvm.icmp "slt" %205, %18 : i64
  cf.cond_br %207, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %208 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %209 = llvm.mlir.constant(32 : index) : i64
  %210 = llvm.mul %21, %209  : i64
  %211 = llvm.mlir.constant(4 : index) : i64
  %212 = llvm.mul %206, %211  : i64
  %213 = llvm.add %210, %212  : i64
  %214 = llvm.add %213, %21  : i64
  %215 = llvm.getelementptr %208[%214] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %216 = llvm.load %215 : !llvm.ptr<f32>
  %217 = llvm.mlir.constant(32 : index) : i64
  %218 = llvm.mul %21, %217  : i64
  %219 = llvm.mlir.constant(4 : index) : i64
  %220 = llvm.mul %206, %219  : i64
  %221 = llvm.add %218, %220  : i64
  %222 = llvm.add %221, %21  : i64
  %223 = llvm.getelementptr %192[%222] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %216, %223 : !llvm.ptr<f32>
  %224 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %225 = llvm.mlir.constant(32 : index) : i64
  %226 = llvm.mul %21, %225  : i64
  %227 = llvm.mlir.constant(4 : index) : i64
  %228 = llvm.mul %206, %227  : i64
  %229 = llvm.add %226, %228  : i64
  %230 = llvm.add %229, %27  : i64
  %231 = llvm.getelementptr %224[%230] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %232 = llvm.load %231 : !llvm.ptr<f32>
  %233 = llvm.mlir.constant(32 : index) : i64
  %234 = llvm.mul %21, %233  : i64
  %235 = llvm.mlir.constant(4 : index) : i64
  %236 = llvm.mul %206, %235  : i64
  %237 = llvm.add %234, %236  : i64
  %238 = llvm.add %237, %27  : i64
  %239 = llvm.getelementptr %192[%238] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %232, %239 : !llvm.ptr<f32>
  %240 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %241 = llvm.mlir.constant(32 : index) : i64
  %242 = llvm.mul %21, %241  : i64
  %243 = llvm.mlir.constant(4 : index) : i64
  %244 = llvm.mul %206, %243  : i64
  %245 = llvm.add %242, %244  : i64
  %246 = llvm.add %245, %5  : i64
  %247 = llvm.getelementptr %240[%246] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %248 = llvm.load %247 : !llvm.ptr<f32>
  %249 = llvm.mlir.constant(32 : index) : i64
  %250 = llvm.mul %21, %249  : i64
  %251 = llvm.mlir.constant(4 : index) : i64
  %252 = llvm.mul %206, %251  : i64
  %253 = llvm.add %250, %252  : i64
  %254 = llvm.add %253, %5  : i64
  %255 = llvm.getelementptr %192[%254] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %248, %255 : !llvm.ptr<f32>
  %256 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %257 = llvm.mlir.constant(32 : index) : i64
  %258 = llvm.mul %21, %257  : i64
  %259 = llvm.mlir.constant(4 : index) : i64
  %260 = llvm.mul %206, %259  : i64
  %261 = llvm.add %258, %260  : i64
  %262 = llvm.add %261, %8  : i64
  %263 = llvm.getelementptr %256[%262] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %264 = llvm.load %263 : !llvm.ptr<f32>
  %265 = llvm.mlir.constant(32 : index) : i64
  %266 = llvm.mul %21, %265  : i64
  %267 = llvm.mlir.constant(4 : index) : i64
  %268 = llvm.mul %206, %267  : i64
  %269 = llvm.add %266, %268  : i64
  %270 = llvm.add %269, %8  : i64
  %271 = llvm.getelementptr %192[%270] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %264, %271 : !llvm.ptr<f32>
  %272 = llvm.add %205, %25  : i64
  %273 = builtin.unrealized_conversion_cast %272 : i64 to index
  cf.br ^bb4(%273 : index)
^bb6:  // pred: ^bb4
  %274 = llvm.mlir.constant(1 : index) : i64
  %275 = llvm.mlir.constant(4 : index) : i64
  %276 = llvm.mlir.constant(4 : index) : i64
  %277 = llvm.mlir.constant(1 : index) : i64
  %278 = llvm.mlir.constant(16 : index) : i64
  %279 = llvm.mlir.constant(16 : index) : i64
  %280 = llvm.mlir.null : !llvm.ptr<f32>
  %281 = llvm.getelementptr %280[%279] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %282 = llvm.ptrtoint %281 : !llvm.ptr<f32> to i64
  %283 = llvm.alloca %282 x f32 : (i64) -> !llvm.ptr<f32>
  %284 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %285 = llvm.insertvalue %283, %284[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %286 = llvm.insertvalue %283, %285[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %287 = llvm.mlir.constant(0 : index) : i64
  %288 = llvm.insertvalue %287, %286[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %289 = llvm.insertvalue %274, %288[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %290 = llvm.insertvalue %275, %289[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %291 = llvm.insertvalue %276, %290[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %292 = llvm.insertvalue %278, %291[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %293 = llvm.insertvalue %276, %292[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %294 = llvm.insertvalue %277, %293[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb7(%20 : index)
^bb7(%295: index):  // 2 preds: ^bb6, ^bb8
  %296 = builtin.unrealized_conversion_cast %295 : index to i64
  %297 = builtin.unrealized_conversion_cast %295 : index to i64
  %298 = llvm.icmp "slt" %296, %22 : i64
  cf.cond_br %298, ^bb8, ^bb9(%20 : index)
^bb8:  // pred: ^bb7
  %299 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %300 = llvm.mlir.constant(16 : index) : i64
  %301 = llvm.mul %21, %300  : i64
  %302 = llvm.mlir.constant(4 : index) : i64
  %303 = llvm.mul %297, %302  : i64
  %304 = llvm.add %301, %303  : i64
  %305 = llvm.add %304, %21  : i64
  %306 = llvm.getelementptr %299[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %307 = llvm.load %306 : !llvm.ptr<f32>
  %308 = llvm.mlir.constant(16 : index) : i64
  %309 = llvm.mul %21, %308  : i64
  %310 = llvm.mlir.constant(4 : index) : i64
  %311 = llvm.mul %297, %310  : i64
  %312 = llvm.add %309, %311  : i64
  %313 = llvm.add %312, %21  : i64
  %314 = llvm.getelementptr %283[%313] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %307, %314 : !llvm.ptr<f32>
  %315 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %316 = llvm.mlir.constant(16 : index) : i64
  %317 = llvm.mul %21, %316  : i64
  %318 = llvm.mlir.constant(4 : index) : i64
  %319 = llvm.mul %297, %318  : i64
  %320 = llvm.add %317, %319  : i64
  %321 = llvm.add %320, %27  : i64
  %322 = llvm.getelementptr %315[%321] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %323 = llvm.load %322 : !llvm.ptr<f32>
  %324 = llvm.mlir.constant(16 : index) : i64
  %325 = llvm.mul %21, %324  : i64
  %326 = llvm.mlir.constant(4 : index) : i64
  %327 = llvm.mul %297, %326  : i64
  %328 = llvm.add %325, %327  : i64
  %329 = llvm.add %328, %27  : i64
  %330 = llvm.getelementptr %283[%329] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %323, %330 : !llvm.ptr<f32>
  %331 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %332 = llvm.mlir.constant(16 : index) : i64
  %333 = llvm.mul %21, %332  : i64
  %334 = llvm.mlir.constant(4 : index) : i64
  %335 = llvm.mul %297, %334  : i64
  %336 = llvm.add %333, %335  : i64
  %337 = llvm.add %336, %5  : i64
  %338 = llvm.getelementptr %331[%337] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %339 = llvm.load %338 : !llvm.ptr<f32>
  %340 = llvm.mlir.constant(16 : index) : i64
  %341 = llvm.mul %21, %340  : i64
  %342 = llvm.mlir.constant(4 : index) : i64
  %343 = llvm.mul %297, %342  : i64
  %344 = llvm.add %341, %343  : i64
  %345 = llvm.add %344, %5  : i64
  %346 = llvm.getelementptr %283[%345] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %339, %346 : !llvm.ptr<f32>
  %347 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %348 = llvm.mlir.constant(16 : index) : i64
  %349 = llvm.mul %21, %348  : i64
  %350 = llvm.mlir.constant(4 : index) : i64
  %351 = llvm.mul %297, %350  : i64
  %352 = llvm.add %349, %351  : i64
  %353 = llvm.add %352, %8  : i64
  %354 = llvm.getelementptr %347[%353] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %355 = llvm.load %354 : !llvm.ptr<f32>
  %356 = llvm.mlir.constant(16 : index) : i64
  %357 = llvm.mul %21, %356  : i64
  %358 = llvm.mlir.constant(4 : index) : i64
  %359 = llvm.mul %297, %358  : i64
  %360 = llvm.add %357, %359  : i64
  %361 = llvm.add %360, %8  : i64
  %362 = llvm.getelementptr %283[%361] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %355, %362 : !llvm.ptr<f32>
  %363 = llvm.add %296, %25  : i64
  %364 = builtin.unrealized_conversion_cast %363 : i64 to index
  cf.br ^bb7(%364 : index)
^bb9(%365: index):  // 2 preds: ^bb7, ^bb12
  %366 = builtin.unrealized_conversion_cast %365 : index to i64
  %367 = builtin.unrealized_conversion_cast %365 : index to i64
  %368 = llvm.icmp "slt" %366, %22 : i64
  cf.cond_br %368, ^bb10(%20 : index), ^bb13(%20 : index)
^bb10(%369: index):  // 2 preds: ^bb9, ^bb11
  %370 = builtin.unrealized_conversion_cast %369 : index to i64
  %371 = builtin.unrealized_conversion_cast %369 : index to i64
  %372 = llvm.icmp "slt" %370, %22 : i64
  cf.cond_br %372, ^bb11, ^bb12
^bb11:  // pred: ^bb10
  %373 = llvm.mlir.constant(32 : index) : i64
  %374 = llvm.mul %21, %373  : i64
  %375 = llvm.mlir.constant(8 : index) : i64
  %376 = llvm.mul %367, %375  : i64
  %377 = llvm.add %374, %376  : i64
  %378 = llvm.add %377, %21  : i64
  %379 = llvm.getelementptr %37[%378] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %380 = llvm.load %379 : !llvm.ptr<f32>
  %381 = llvm.mlir.constant(32 : index) : i64
  %382 = llvm.mul %21, %381  : i64
  %383 = llvm.mlir.constant(4 : index) : i64
  %384 = llvm.mul %21, %383  : i64
  %385 = llvm.add %382, %384  : i64
  %386 = llvm.add %385, %371  : i64
  %387 = llvm.getelementptr %192[%386] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %388 = llvm.load %387 : !llvm.ptr<f32>
  %389 = llvm.mlir.constant(16 : index) : i64
  %390 = llvm.mul %21, %389  : i64
  %391 = llvm.mlir.constant(4 : index) : i64
  %392 = llvm.mul %367, %391  : i64
  %393 = llvm.add %390, %392  : i64
  %394 = llvm.add %393, %371  : i64
  %395 = llvm.getelementptr %283[%394] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %396 = llvm.load %395 : !llvm.ptr<f32>
  %397 = llvm.fmul %380, %388  : f32
  %398 = llvm.fadd %396, %397  : f32
  %399 = llvm.mlir.constant(32 : index) : i64
  %400 = llvm.mul %21, %399  : i64
  %401 = llvm.mlir.constant(8 : index) : i64
  %402 = llvm.mul %367, %401  : i64
  %403 = llvm.add %400, %402  : i64
  %404 = llvm.add %403, %27  : i64
  %405 = llvm.getelementptr %37[%404] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %406 = llvm.load %405 : !llvm.ptr<f32>
  %407 = llvm.mlir.constant(32 : index) : i64
  %408 = llvm.mul %21, %407  : i64
  %409 = llvm.mlir.constant(4 : index) : i64
  %410 = llvm.mul %27, %409  : i64
  %411 = llvm.add %408, %410  : i64
  %412 = llvm.add %411, %371  : i64
  %413 = llvm.getelementptr %192[%412] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %414 = llvm.load %413 : !llvm.ptr<f32>
  %415 = llvm.fmul %406, %414  : f32
  %416 = llvm.fadd %398, %415  : f32
  %417 = llvm.mlir.constant(32 : index) : i64
  %418 = llvm.mul %21, %417  : i64
  %419 = llvm.mlir.constant(8 : index) : i64
  %420 = llvm.mul %367, %419  : i64
  %421 = llvm.add %418, %420  : i64
  %422 = llvm.add %421, %5  : i64
  %423 = llvm.getelementptr %37[%422] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %424 = llvm.load %423 : !llvm.ptr<f32>
  %425 = llvm.mlir.constant(32 : index) : i64
  %426 = llvm.mul %21, %425  : i64
  %427 = llvm.mlir.constant(4 : index) : i64
  %428 = llvm.mul %5, %427  : i64
  %429 = llvm.add %426, %428  : i64
  %430 = llvm.add %429, %371  : i64
  %431 = llvm.getelementptr %192[%430] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %432 = llvm.load %431 : !llvm.ptr<f32>
  %433 = llvm.fmul %424, %432  : f32
  %434 = llvm.fadd %416, %433  : f32
  %435 = llvm.mlir.constant(32 : index) : i64
  %436 = llvm.mul %21, %435  : i64
  %437 = llvm.mlir.constant(8 : index) : i64
  %438 = llvm.mul %367, %437  : i64
  %439 = llvm.add %436, %438  : i64
  %440 = llvm.add %439, %8  : i64
  %441 = llvm.getelementptr %37[%440] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %442 = llvm.load %441 : !llvm.ptr<f32>
  %443 = llvm.mlir.constant(32 : index) : i64
  %444 = llvm.mul %21, %443  : i64
  %445 = llvm.mlir.constant(4 : index) : i64
  %446 = llvm.mul %8, %445  : i64
  %447 = llvm.add %444, %446  : i64
  %448 = llvm.add %447, %371  : i64
  %449 = llvm.getelementptr %192[%448] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %450 = llvm.load %449 : !llvm.ptr<f32>
  %451 = llvm.fmul %442, %450  : f32
  %452 = llvm.fadd %434, %451  : f32
  %453 = llvm.mlir.constant(32 : index) : i64
  %454 = llvm.mul %21, %453  : i64
  %455 = llvm.mlir.constant(8 : index) : i64
  %456 = llvm.mul %367, %455  : i64
  %457 = llvm.add %454, %456  : i64
  %458 = llvm.add %457, %24  : i64
  %459 = llvm.getelementptr %37[%458] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %460 = llvm.load %459 : !llvm.ptr<f32>
  %461 = llvm.mlir.constant(32 : index) : i64
  %462 = llvm.mul %21, %461  : i64
  %463 = llvm.mlir.constant(4 : index) : i64
  %464 = llvm.mul %24, %463  : i64
  %465 = llvm.add %462, %464  : i64
  %466 = llvm.add %465, %371  : i64
  %467 = llvm.getelementptr %192[%466] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %468 = llvm.load %467 : !llvm.ptr<f32>
  %469 = llvm.fmul %460, %468  : f32
  %470 = llvm.fadd %452, %469  : f32
  %471 = llvm.mlir.constant(32 : index) : i64
  %472 = llvm.mul %21, %471  : i64
  %473 = llvm.mlir.constant(8 : index) : i64
  %474 = llvm.mul %367, %473  : i64
  %475 = llvm.add %472, %474  : i64
  %476 = llvm.add %475, %11  : i64
  %477 = llvm.getelementptr %37[%476] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %478 = llvm.load %477 : !llvm.ptr<f32>
  %479 = llvm.mlir.constant(32 : index) : i64
  %480 = llvm.mul %21, %479  : i64
  %481 = llvm.mlir.constant(4 : index) : i64
  %482 = llvm.mul %11, %481  : i64
  %483 = llvm.add %480, %482  : i64
  %484 = llvm.add %483, %371  : i64
  %485 = llvm.getelementptr %192[%484] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %486 = llvm.load %485 : !llvm.ptr<f32>
  %487 = llvm.fmul %478, %486  : f32
  %488 = llvm.fadd %470, %487  : f32
  %489 = llvm.mlir.constant(32 : index) : i64
  %490 = llvm.mul %21, %489  : i64
  %491 = llvm.mlir.constant(8 : index) : i64
  %492 = llvm.mul %367, %491  : i64
  %493 = llvm.add %490, %492  : i64
  %494 = llvm.add %493, %14  : i64
  %495 = llvm.getelementptr %37[%494] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %496 = llvm.load %495 : !llvm.ptr<f32>
  %497 = llvm.mlir.constant(32 : index) : i64
  %498 = llvm.mul %21, %497  : i64
  %499 = llvm.mlir.constant(4 : index) : i64
  %500 = llvm.mul %14, %499  : i64
  %501 = llvm.add %498, %500  : i64
  %502 = llvm.add %501, %371  : i64
  %503 = llvm.getelementptr %192[%502] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %504 = llvm.load %503 : !llvm.ptr<f32>
  %505 = llvm.fmul %496, %504  : f32
  %506 = llvm.fadd %488, %505  : f32
  %507 = llvm.mlir.constant(32 : index) : i64
  %508 = llvm.mul %21, %507  : i64
  %509 = llvm.mlir.constant(8 : index) : i64
  %510 = llvm.mul %367, %509  : i64
  %511 = llvm.add %508, %510  : i64
  %512 = llvm.add %511, %17  : i64
  %513 = llvm.getelementptr %37[%512] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %514 = llvm.load %513 : !llvm.ptr<f32>
  %515 = llvm.mlir.constant(32 : index) : i64
  %516 = llvm.mul %21, %515  : i64
  %517 = llvm.mlir.constant(4 : index) : i64
  %518 = llvm.mul %17, %517  : i64
  %519 = llvm.add %516, %518  : i64
  %520 = llvm.add %519, %371  : i64
  %521 = llvm.getelementptr %192[%520] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %522 = llvm.load %521 : !llvm.ptr<f32>
  %523 = llvm.fmul %514, %522  : f32
  %524 = llvm.fadd %506, %523  : f32
  %525 = llvm.mlir.constant(16 : index) : i64
  %526 = llvm.mul %21, %525  : i64
  %527 = llvm.mlir.constant(4 : index) : i64
  %528 = llvm.mul %367, %527  : i64
  %529 = llvm.add %526, %528  : i64
  %530 = llvm.add %529, %371  : i64
  %531 = llvm.getelementptr %283[%530] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %524, %531 : !llvm.ptr<f32>
  %532 = llvm.add %370, %25  : i64
  %533 = builtin.unrealized_conversion_cast %532 : i64 to index
  cf.br ^bb10(%533 : index)
^bb12:  // pred: ^bb10
  %534 = llvm.add %366, %25  : i64
  %535 = builtin.unrealized_conversion_cast %534 : i64 to index
  cf.br ^bb9(%535 : index)
^bb13(%536: index):  // 2 preds: ^bb9, ^bb14
  %537 = builtin.unrealized_conversion_cast %536 : index to i64
  %538 = builtin.unrealized_conversion_cast %536 : index to i64
  %539 = llvm.icmp "slt" %537, %22 : i64
  cf.cond_br %539, ^bb14, ^bb15
^bb14:  // pred: ^bb13
  %540 = llvm.mlir.constant(16 : index) : i64
  %541 = llvm.mul %21, %540  : i64
  %542 = llvm.mlir.constant(4 : index) : i64
  %543 = llvm.mul %538, %542  : i64
  %544 = llvm.add %541, %543  : i64
  %545 = llvm.add %544, %21  : i64
  %546 = llvm.getelementptr %283[%545] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %547 = llvm.load %546 : !llvm.ptr<f32>
  %548 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %549 = llvm.mlir.constant(16 : index) : i64
  %550 = llvm.mul %21, %549  : i64
  %551 = llvm.mlir.constant(4 : index) : i64
  %552 = llvm.mul %538, %551  : i64
  %553 = llvm.add %550, %552  : i64
  %554 = llvm.add %553, %21  : i64
  %555 = llvm.getelementptr %548[%554] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %547, %555 : !llvm.ptr<f32>
  %556 = llvm.mlir.constant(16 : index) : i64
  %557 = llvm.mul %21, %556  : i64
  %558 = llvm.mlir.constant(4 : index) : i64
  %559 = llvm.mul %538, %558  : i64
  %560 = llvm.add %557, %559  : i64
  %561 = llvm.add %560, %27  : i64
  %562 = llvm.getelementptr %283[%561] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %563 = llvm.load %562 : !llvm.ptr<f32>
  %564 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %565 = llvm.mlir.constant(16 : index) : i64
  %566 = llvm.mul %21, %565  : i64
  %567 = llvm.mlir.constant(4 : index) : i64
  %568 = llvm.mul %538, %567  : i64
  %569 = llvm.add %566, %568  : i64
  %570 = llvm.add %569, %27  : i64
  %571 = llvm.getelementptr %564[%570] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %563, %571 : !llvm.ptr<f32>
  %572 = llvm.mlir.constant(16 : index) : i64
  %573 = llvm.mul %21, %572  : i64
  %574 = llvm.mlir.constant(4 : index) : i64
  %575 = llvm.mul %538, %574  : i64
  %576 = llvm.add %573, %575  : i64
  %577 = llvm.add %576, %5  : i64
  %578 = llvm.getelementptr %283[%577] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %579 = llvm.load %578 : !llvm.ptr<f32>
  %580 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %581 = llvm.mlir.constant(16 : index) : i64
  %582 = llvm.mul %21, %581  : i64
  %583 = llvm.mlir.constant(4 : index) : i64
  %584 = llvm.mul %538, %583  : i64
  %585 = llvm.add %582, %584  : i64
  %586 = llvm.add %585, %5  : i64
  %587 = llvm.getelementptr %580[%586] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %579, %587 : !llvm.ptr<f32>
  %588 = llvm.mlir.constant(16 : index) : i64
  %589 = llvm.mul %21, %588  : i64
  %590 = llvm.mlir.constant(4 : index) : i64
  %591 = llvm.mul %538, %590  : i64
  %592 = llvm.add %589, %591  : i64
  %593 = llvm.add %592, %8  : i64
  %594 = llvm.getelementptr %283[%593] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %595 = llvm.load %594 : !llvm.ptr<f32>
  %596 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %597 = llvm.mlir.constant(16 : index) : i64
  %598 = llvm.mul %21, %597  : i64
  %599 = llvm.mlir.constant(4 : index) : i64
  %600 = llvm.mul %538, %599  : i64
  %601 = llvm.add %598, %600  : i64
  %602 = llvm.add %601, %8  : i64
  %603 = llvm.getelementptr %596[%602] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %595, %603 : !llvm.ptr<f32>
  %604 = llvm.add %537, %25  : i64
  %605 = builtin.unrealized_conversion_cast %604 : i64 to index
  cf.br ^bb13(%605 : index)
^bb15:  // pred: ^bb13
  return
}

// -----// IR Dump After ExpandOps //----- //
func @main_kernel(%arg0: memref<1x4x8xf32> {llvm.noalias}, %arg1: memref<1x8x4xf32> {llvm.noalias}, %arg2: memref<1x4x4xf32> {llvm.noalias}) {
  %0 = builtin.unrealized_conversion_cast %arg2 : memref<1x4x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %1 = builtin.unrealized_conversion_cast %arg1 : memref<1x8x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %2 = builtin.unrealized_conversion_cast %arg0 : memref<1x4x8xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %3 = llvm.mlir.constant(2 : index) : i64
  %4 = builtin.unrealized_conversion_cast %3 : i64 to index
  %5 = llvm.mlir.constant(3 : index) : i64
  %6 = builtin.unrealized_conversion_cast %5 : i64 to index
  %7 = llvm.mlir.constant(5 : index) : i64
  %8 = builtin.unrealized_conversion_cast %7 : i64 to index
  %9 = llvm.mlir.constant(6 : index) : i64
  %10 = builtin.unrealized_conversion_cast %9 : i64 to index
  %11 = llvm.mlir.constant(7 : index) : i64
  %12 = builtin.unrealized_conversion_cast %11 : i64 to index
  %13 = llvm.mlir.constant(8 : index) : i64
  %14 = llvm.mlir.constant(0 : index) : i64
  %15 = builtin.unrealized_conversion_cast %14 : i64 to index
  %16 = llvm.mlir.constant(4 : index) : i64
  %17 = builtin.unrealized_conversion_cast %16 : i64 to index
  %18 = llvm.mlir.constant(1 : index) : i64
  %19 = builtin.unrealized_conversion_cast %18 : i64 to index
  %20 = llvm.mlir.constant(1 : index) : i64
  %21 = llvm.mlir.constant(4 : index) : i64
  %22 = llvm.mlir.constant(8 : index) : i64
  %23 = llvm.mlir.constant(1 : index) : i64
  %24 = llvm.mlir.constant(32 : index) : i64
  %25 = llvm.mlir.constant(32 : index) : i64
  %26 = llvm.mlir.null : !llvm.ptr<f32>
  %27 = llvm.getelementptr %26[%25] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %28 = llvm.ptrtoint %27 : !llvm.ptr<f32> to i64
  %29 = llvm.alloca %28 x f32 : (i64) -> !llvm.ptr<f32>
  %30 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %31 = llvm.insertvalue %29, %30[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %32 = llvm.insertvalue %29, %31[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %33 = llvm.mlir.constant(0 : index) : i64
  %34 = llvm.insertvalue %33, %32[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %35 = llvm.insertvalue %20, %34[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %36 = llvm.insertvalue %21, %35[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %37 = llvm.insertvalue %22, %36[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %38 = llvm.insertvalue %24, %37[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %39 = llvm.insertvalue %22, %38[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %40 = llvm.insertvalue %23, %39[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb1(%15 : index)
^bb1(%41: index):  // 2 preds: ^bb0, ^bb2
  %42 = builtin.unrealized_conversion_cast %41 : index to i64
  %43 = builtin.unrealized_conversion_cast %41 : index to i64
  %44 = llvm.icmp "slt" %42, %16 : i64
  cf.cond_br %44, ^bb2, ^bb3
^bb2:  // pred: ^bb1
  %45 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %46 = llvm.mlir.constant(32 : index) : i64
  %47 = llvm.mul %14, %46  : i64
  %48 = llvm.mlir.constant(8 : index) : i64
  %49 = llvm.mul %43, %48  : i64
  %50 = llvm.add %47, %49  : i64
  %51 = llvm.add %50, %14  : i64
  %52 = llvm.getelementptr %45[%51] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %53 = llvm.load %52 : !llvm.ptr<f32>
  %54 = llvm.mlir.constant(32 : index) : i64
  %55 = llvm.mul %14, %54  : i64
  %56 = llvm.mlir.constant(8 : index) : i64
  %57 = llvm.mul %43, %56  : i64
  %58 = llvm.add %55, %57  : i64
  %59 = llvm.add %58, %14  : i64
  %60 = llvm.getelementptr %29[%59] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %53, %60 : !llvm.ptr<f32>
  %61 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %62 = llvm.mlir.constant(32 : index) : i64
  %63 = llvm.mul %14, %62  : i64
  %64 = llvm.mlir.constant(8 : index) : i64
  %65 = llvm.mul %43, %64  : i64
  %66 = llvm.add %63, %65  : i64
  %67 = llvm.add %66, %18  : i64
  %68 = llvm.getelementptr %61[%67] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %69 = llvm.load %68 : !llvm.ptr<f32>
  %70 = llvm.mlir.constant(32 : index) : i64
  %71 = llvm.mul %14, %70  : i64
  %72 = llvm.mlir.constant(8 : index) : i64
  %73 = llvm.mul %43, %72  : i64
  %74 = llvm.add %71, %73  : i64
  %75 = llvm.add %74, %18  : i64
  %76 = llvm.getelementptr %29[%75] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %69, %76 : !llvm.ptr<f32>
  %77 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %78 = llvm.mlir.constant(32 : index) : i64
  %79 = llvm.mul %14, %78  : i64
  %80 = llvm.mlir.constant(8 : index) : i64
  %81 = llvm.mul %43, %80  : i64
  %82 = llvm.add %79, %81  : i64
  %83 = llvm.add %82, %3  : i64
  %84 = llvm.getelementptr %77[%83] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %85 = llvm.load %84 : !llvm.ptr<f32>
  %86 = llvm.mlir.constant(32 : index) : i64
  %87 = llvm.mul %14, %86  : i64
  %88 = llvm.mlir.constant(8 : index) : i64
  %89 = llvm.mul %43, %88  : i64
  %90 = llvm.add %87, %89  : i64
  %91 = llvm.add %90, %3  : i64
  %92 = llvm.getelementptr %29[%91] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %85, %92 : !llvm.ptr<f32>
  %93 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %94 = llvm.mlir.constant(32 : index) : i64
  %95 = llvm.mul %14, %94  : i64
  %96 = llvm.mlir.constant(8 : index) : i64
  %97 = llvm.mul %43, %96  : i64
  %98 = llvm.add %95, %97  : i64
  %99 = llvm.add %98, %5  : i64
  %100 = llvm.getelementptr %93[%99] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %101 = llvm.load %100 : !llvm.ptr<f32>
  %102 = llvm.mlir.constant(32 : index) : i64
  %103 = llvm.mul %14, %102  : i64
  %104 = llvm.mlir.constant(8 : index) : i64
  %105 = llvm.mul %43, %104  : i64
  %106 = llvm.add %103, %105  : i64
  %107 = llvm.add %106, %5  : i64
  %108 = llvm.getelementptr %29[%107] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %101, %108 : !llvm.ptr<f32>
  %109 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %110 = llvm.mlir.constant(32 : index) : i64
  %111 = llvm.mul %14, %110  : i64
  %112 = llvm.mlir.constant(8 : index) : i64
  %113 = llvm.mul %43, %112  : i64
  %114 = llvm.add %111, %113  : i64
  %115 = llvm.add %114, %16  : i64
  %116 = llvm.getelementptr %109[%115] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %117 = llvm.load %116 : !llvm.ptr<f32>
  %118 = llvm.mlir.constant(32 : index) : i64
  %119 = llvm.mul %14, %118  : i64
  %120 = llvm.mlir.constant(8 : index) : i64
  %121 = llvm.mul %43, %120  : i64
  %122 = llvm.add %119, %121  : i64
  %123 = llvm.add %122, %16  : i64
  %124 = llvm.getelementptr %29[%123] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %117, %124 : !llvm.ptr<f32>
  %125 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %126 = llvm.mlir.constant(32 : index) : i64
  %127 = llvm.mul %14, %126  : i64
  %128 = llvm.mlir.constant(8 : index) : i64
  %129 = llvm.mul %43, %128  : i64
  %130 = llvm.add %127, %129  : i64
  %131 = llvm.add %130, %7  : i64
  %132 = llvm.getelementptr %125[%131] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %133 = llvm.load %132 : !llvm.ptr<f32>
  %134 = llvm.mlir.constant(32 : index) : i64
  %135 = llvm.mul %14, %134  : i64
  %136 = llvm.mlir.constant(8 : index) : i64
  %137 = llvm.mul %43, %136  : i64
  %138 = llvm.add %135, %137  : i64
  %139 = llvm.add %138, %7  : i64
  %140 = llvm.getelementptr %29[%139] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %133, %140 : !llvm.ptr<f32>
  %141 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %142 = llvm.mlir.constant(32 : index) : i64
  %143 = llvm.mul %14, %142  : i64
  %144 = llvm.mlir.constant(8 : index) : i64
  %145 = llvm.mul %43, %144  : i64
  %146 = llvm.add %143, %145  : i64
  %147 = llvm.add %146, %9  : i64
  %148 = llvm.getelementptr %141[%147] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %149 = llvm.load %148 : !llvm.ptr<f32>
  %150 = llvm.mlir.constant(32 : index) : i64
  %151 = llvm.mul %14, %150  : i64
  %152 = llvm.mlir.constant(8 : index) : i64
  %153 = llvm.mul %43, %152  : i64
  %154 = llvm.add %151, %153  : i64
  %155 = llvm.add %154, %9  : i64
  %156 = llvm.getelementptr %29[%155] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %149, %156 : !llvm.ptr<f32>
  %157 = llvm.extractvalue %2[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %158 = llvm.mlir.constant(32 : index) : i64
  %159 = llvm.mul %14, %158  : i64
  %160 = llvm.mlir.constant(8 : index) : i64
  %161 = llvm.mul %43, %160  : i64
  %162 = llvm.add %159, %161  : i64
  %163 = llvm.add %162, %11  : i64
  %164 = llvm.getelementptr %157[%163] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %165 = llvm.load %164 : !llvm.ptr<f32>
  %166 = llvm.mlir.constant(32 : index) : i64
  %167 = llvm.mul %14, %166  : i64
  %168 = llvm.mlir.constant(8 : index) : i64
  %169 = llvm.mul %43, %168  : i64
  %170 = llvm.add %167, %169  : i64
  %171 = llvm.add %170, %11  : i64
  %172 = llvm.getelementptr %29[%171] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %165, %172 : !llvm.ptr<f32>
  %173 = llvm.add %42, %18  : i64
  %174 = builtin.unrealized_conversion_cast %173 : i64 to index
  cf.br ^bb1(%174 : index)
^bb3:  // pred: ^bb1
  %175 = llvm.mlir.constant(1 : index) : i64
  %176 = llvm.mlir.constant(8 : index) : i64
  %177 = llvm.mlir.constant(4 : index) : i64
  %178 = llvm.mlir.constant(1 : index) : i64
  %179 = llvm.mlir.constant(32 : index) : i64
  %180 = llvm.mlir.constant(32 : index) : i64
  %181 = llvm.mlir.null : !llvm.ptr<f32>
  %182 = llvm.getelementptr %181[%180] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %183 = llvm.ptrtoint %182 : !llvm.ptr<f32> to i64
  %184 = llvm.alloca %183 x f32 : (i64) -> !llvm.ptr<f32>
  %185 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %186 = llvm.insertvalue %184, %185[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %187 = llvm.insertvalue %184, %186[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %188 = llvm.mlir.constant(0 : index) : i64
  %189 = llvm.insertvalue %188, %187[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %190 = llvm.insertvalue %175, %189[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %191 = llvm.insertvalue %176, %190[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %192 = llvm.insertvalue %177, %191[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %193 = llvm.insertvalue %179, %192[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %194 = llvm.insertvalue %177, %193[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %195 = llvm.insertvalue %178, %194[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb4(%15 : index)
^bb4(%196: index):  // 2 preds: ^bb3, ^bb5
  %197 = builtin.unrealized_conversion_cast %196 : index to i64
  %198 = builtin.unrealized_conversion_cast %196 : index to i64
  %199 = llvm.icmp "slt" %197, %13 : i64
  cf.cond_br %199, ^bb5, ^bb6
^bb5:  // pred: ^bb4
  %200 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %201 = llvm.mlir.constant(32 : index) : i64
  %202 = llvm.mul %14, %201  : i64
  %203 = llvm.mlir.constant(4 : index) : i64
  %204 = llvm.mul %198, %203  : i64
  %205 = llvm.add %202, %204  : i64
  %206 = llvm.add %205, %14  : i64
  %207 = llvm.getelementptr %200[%206] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %208 = llvm.load %207 : !llvm.ptr<f32>
  %209 = llvm.mlir.constant(32 : index) : i64
  %210 = llvm.mul %14, %209  : i64
  %211 = llvm.mlir.constant(4 : index) : i64
  %212 = llvm.mul %198, %211  : i64
  %213 = llvm.add %210, %212  : i64
  %214 = llvm.add %213, %14  : i64
  %215 = llvm.getelementptr %184[%214] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %208, %215 : !llvm.ptr<f32>
  %216 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %217 = llvm.mlir.constant(32 : index) : i64
  %218 = llvm.mul %14, %217  : i64
  %219 = llvm.mlir.constant(4 : index) : i64
  %220 = llvm.mul %198, %219  : i64
  %221 = llvm.add %218, %220  : i64
  %222 = llvm.add %221, %18  : i64
  %223 = llvm.getelementptr %216[%222] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %224 = llvm.load %223 : !llvm.ptr<f32>
  %225 = llvm.mlir.constant(32 : index) : i64
  %226 = llvm.mul %14, %225  : i64
  %227 = llvm.mlir.constant(4 : index) : i64
  %228 = llvm.mul %198, %227  : i64
  %229 = llvm.add %226, %228  : i64
  %230 = llvm.add %229, %18  : i64
  %231 = llvm.getelementptr %184[%230] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %224, %231 : !llvm.ptr<f32>
  %232 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %233 = llvm.mlir.constant(32 : index) : i64
  %234 = llvm.mul %14, %233  : i64
  %235 = llvm.mlir.constant(4 : index) : i64
  %236 = llvm.mul %198, %235  : i64
  %237 = llvm.add %234, %236  : i64
  %238 = llvm.add %237, %3  : i64
  %239 = llvm.getelementptr %232[%238] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %240 = llvm.load %239 : !llvm.ptr<f32>
  %241 = llvm.mlir.constant(32 : index) : i64
  %242 = llvm.mul %14, %241  : i64
  %243 = llvm.mlir.constant(4 : index) : i64
  %244 = llvm.mul %198, %243  : i64
  %245 = llvm.add %242, %244  : i64
  %246 = llvm.add %245, %3  : i64
  %247 = llvm.getelementptr %184[%246] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %240, %247 : !llvm.ptr<f32>
  %248 = llvm.extractvalue %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %249 = llvm.mlir.constant(32 : index) : i64
  %250 = llvm.mul %14, %249  : i64
  %251 = llvm.mlir.constant(4 : index) : i64
  %252 = llvm.mul %198, %251  : i64
  %253 = llvm.add %250, %252  : i64
  %254 = llvm.add %253, %5  : i64
  %255 = llvm.getelementptr %248[%254] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %256 = llvm.load %255 : !llvm.ptr<f32>
  %257 = llvm.mlir.constant(32 : index) : i64
  %258 = llvm.mul %14, %257  : i64
  %259 = llvm.mlir.constant(4 : index) : i64
  %260 = llvm.mul %198, %259  : i64
  %261 = llvm.add %258, %260  : i64
  %262 = llvm.add %261, %5  : i64
  %263 = llvm.getelementptr %184[%262] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %256, %263 : !llvm.ptr<f32>
  %264 = llvm.add %197, %18  : i64
  %265 = builtin.unrealized_conversion_cast %264 : i64 to index
  cf.br ^bb4(%265 : index)
^bb6:  // pred: ^bb4
  %266 = llvm.mlir.constant(1 : index) : i64
  %267 = llvm.mlir.constant(4 : index) : i64
  %268 = llvm.mlir.constant(4 : index) : i64
  %269 = llvm.mlir.constant(1 : index) : i64
  %270 = llvm.mlir.constant(16 : index) : i64
  %271 = llvm.mlir.constant(16 : index) : i64
  %272 = llvm.mlir.null : !llvm.ptr<f32>
  %273 = llvm.getelementptr %272[%271] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %274 = llvm.ptrtoint %273 : !llvm.ptr<f32> to i64
  %275 = llvm.alloca %274 x f32 : (i64) -> !llvm.ptr<f32>
  %276 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %277 = llvm.insertvalue %275, %276[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %278 = llvm.insertvalue %275, %277[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %279 = llvm.mlir.constant(0 : index) : i64
  %280 = llvm.insertvalue %279, %278[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %281 = llvm.insertvalue %266, %280[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %282 = llvm.insertvalue %267, %281[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %283 = llvm.insertvalue %268, %282[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %284 = llvm.insertvalue %270, %283[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %285 = llvm.insertvalue %268, %284[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %286 = llvm.insertvalue %269, %285[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  cf.br ^bb7(%15 : index)
^bb7(%287: index):  // 2 preds: ^bb6, ^bb8
  %288 = builtin.unrealized_conversion_cast %287 : index to i64
  %289 = builtin.unrealized_conversion_cast %287 : index to i64
  %290 = llvm.icmp "slt" %288, %16 : i64
  cf.cond_br %290, ^bb8, ^bb9(%15 : index)
^bb8:  // pred: ^bb7
  %291 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %292 = llvm.mlir.constant(16 : index) : i64
  %293 = llvm.mul %14, %292  : i64
  %294 = llvm.mlir.constant(4 : index) : i64
  %295 = llvm.mul %289, %294  : i64
  %296 = llvm.add %293, %295  : i64
  %297 = llvm.add %296, %14  : i64
  %298 = llvm.getelementptr %291[%297] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %299 = llvm.load %298 : !llvm.ptr<f32>
  %300 = llvm.mlir.constant(16 : index) : i64
  %301 = llvm.mul %14, %300  : i64
  %302 = llvm.mlir.constant(4 : index) : i64
  %303 = llvm.mul %289, %302  : i64
  %304 = llvm.add %301, %303  : i64
  %305 = llvm.add %304, %14  : i64
  %306 = llvm.getelementptr %275[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %299, %306 : !llvm.ptr<f32>
  %307 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %308 = llvm.mlir.constant(16 : index) : i64
  %309 = llvm.mul %14, %308  : i64
  %310 = llvm.mlir.constant(4 : index) : i64
  %311 = llvm.mul %289, %310  : i64
  %312 = llvm.add %309, %311  : i64
  %313 = llvm.add %312, %18  : i64
  %314 = llvm.getelementptr %307[%313] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %315 = llvm.load %314 : !llvm.ptr<f32>
  %316 = llvm.mlir.constant(16 : index) : i64
  %317 = llvm.mul %14, %316  : i64
  %318 = llvm.mlir.constant(4 : index) : i64
  %319 = llvm.mul %289, %318  : i64
  %320 = llvm.add %317, %319  : i64
  %321 = llvm.add %320, %18  : i64
  %322 = llvm.getelementptr %275[%321] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %315, %322 : !llvm.ptr<f32>
  %323 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %324 = llvm.mlir.constant(16 : index) : i64
  %325 = llvm.mul %14, %324  : i64
  %326 = llvm.mlir.constant(4 : index) : i64
  %327 = llvm.mul %289, %326  : i64
  %328 = llvm.add %325, %327  : i64
  %329 = llvm.add %328, %3  : i64
  %330 = llvm.getelementptr %323[%329] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %331 = llvm.load %330 : !llvm.ptr<f32>
  %332 = llvm.mlir.constant(16 : index) : i64
  %333 = llvm.mul %14, %332  : i64
  %334 = llvm.mlir.constant(4 : index) : i64
  %335 = llvm.mul %289, %334  : i64
  %336 = llvm.add %333, %335  : i64
  %337 = llvm.add %336, %3  : i64
  %338 = llvm.getelementptr %275[%337] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %331, %338 : !llvm.ptr<f32>
  %339 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %340 = llvm.mlir.constant(16 : index) : i64
  %341 = llvm.mul %14, %340  : i64
  %342 = llvm.mlir.constant(4 : index) : i64
  %343 = llvm.mul %289, %342  : i64
  %344 = llvm.add %341, %343  : i64
  %345 = llvm.add %344, %5  : i64
  %346 = llvm.getelementptr %339[%345] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %347 = llvm.load %346 : !llvm.ptr<f32>
  %348 = llvm.mlir.constant(16 : index) : i64
  %349 = llvm.mul %14, %348  : i64
  %350 = llvm.mlir.constant(4 : index) : i64
  %351 = llvm.mul %289, %350  : i64
  %352 = llvm.add %349, %351  : i64
  %353 = llvm.add %352, %5  : i64
  %354 = llvm.getelementptr %275[%353] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %347, %354 : !llvm.ptr<f32>
  %355 = llvm.add %288, %18  : i64
  %356 = builtin.unrealized_conversion_cast %355 : i64 to index
  cf.br ^bb7(%356 : index)
^bb9(%357: index):  // 2 preds: ^bb7, ^bb12
  %358 = builtin.unrealized_conversion_cast %357 : index to i64
  %359 = builtin.unrealized_conversion_cast %357 : index to i64
  %360 = llvm.icmp "slt" %358, %16 : i64
  cf.cond_br %360, ^bb10(%15 : index), ^bb13(%15 : index)
^bb10(%361: index):  // 2 preds: ^bb9, ^bb11
  %362 = builtin.unrealized_conversion_cast %361 : index to i64
  %363 = builtin.unrealized_conversion_cast %361 : index to i64
  %364 = llvm.icmp "slt" %362, %16 : i64
  cf.cond_br %364, ^bb11, ^bb12
^bb11:  // pred: ^bb10
  %365 = llvm.mlir.constant(32 : index) : i64
  %366 = llvm.mul %14, %365  : i64
  %367 = llvm.mlir.constant(8 : index) : i64
  %368 = llvm.mul %359, %367  : i64
  %369 = llvm.add %366, %368  : i64
  %370 = llvm.add %369, %14  : i64
  %371 = llvm.getelementptr %29[%370] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %372 = llvm.load %371 : !llvm.ptr<f32>
  %373 = llvm.mlir.constant(32 : index) : i64
  %374 = llvm.mul %14, %373  : i64
  %375 = llvm.mlir.constant(4 : index) : i64
  %376 = llvm.mul %14, %375  : i64
  %377 = llvm.add %374, %376  : i64
  %378 = llvm.add %377, %363  : i64
  %379 = llvm.getelementptr %184[%378] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %380 = llvm.load %379 : !llvm.ptr<f32>
  %381 = llvm.mlir.constant(16 : index) : i64
  %382 = llvm.mul %14, %381  : i64
  %383 = llvm.mlir.constant(4 : index) : i64
  %384 = llvm.mul %359, %383  : i64
  %385 = llvm.add %382, %384  : i64
  %386 = llvm.add %385, %363  : i64
  %387 = llvm.getelementptr %275[%386] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %388 = llvm.load %387 : !llvm.ptr<f32>
  %389 = llvm.fmul %372, %380  : f32
  %390 = llvm.fadd %388, %389  : f32
  %391 = llvm.mlir.constant(32 : index) : i64
  %392 = llvm.mul %14, %391  : i64
  %393 = llvm.mlir.constant(8 : index) : i64
  %394 = llvm.mul %359, %393  : i64
  %395 = llvm.add %392, %394  : i64
  %396 = llvm.add %395, %18  : i64
  %397 = llvm.getelementptr %29[%396] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %398 = llvm.load %397 : !llvm.ptr<f32>
  %399 = llvm.mlir.constant(32 : index) : i64
  %400 = llvm.mul %14, %399  : i64
  %401 = llvm.mlir.constant(4 : index) : i64
  %402 = llvm.mul %18, %401  : i64
  %403 = llvm.add %400, %402  : i64
  %404 = llvm.add %403, %363  : i64
  %405 = llvm.getelementptr %184[%404] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %406 = llvm.load %405 : !llvm.ptr<f32>
  %407 = llvm.fmul %398, %406  : f32
  %408 = llvm.fadd %390, %407  : f32
  %409 = llvm.mlir.constant(32 : index) : i64
  %410 = llvm.mul %14, %409  : i64
  %411 = llvm.mlir.constant(8 : index) : i64
  %412 = llvm.mul %359, %411  : i64
  %413 = llvm.add %410, %412  : i64
  %414 = llvm.add %413, %3  : i64
  %415 = llvm.getelementptr %29[%414] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %416 = llvm.load %415 : !llvm.ptr<f32>
  %417 = llvm.mlir.constant(32 : index) : i64
  %418 = llvm.mul %14, %417  : i64
  %419 = llvm.mlir.constant(4 : index) : i64
  %420 = llvm.mul %3, %419  : i64
  %421 = llvm.add %418, %420  : i64
  %422 = llvm.add %421, %363  : i64
  %423 = llvm.getelementptr %184[%422] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %424 = llvm.load %423 : !llvm.ptr<f32>
  %425 = llvm.fmul %416, %424  : f32
  %426 = llvm.fadd %408, %425  : f32
  %427 = llvm.mlir.constant(32 : index) : i64
  %428 = llvm.mul %14, %427  : i64
  %429 = llvm.mlir.constant(8 : index) : i64
  %430 = llvm.mul %359, %429  : i64
  %431 = llvm.add %428, %430  : i64
  %432 = llvm.add %431, %5  : i64
  %433 = llvm.getelementptr %29[%432] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %434 = llvm.load %433 : !llvm.ptr<f32>
  %435 = llvm.mlir.constant(32 : index) : i64
  %436 = llvm.mul %14, %435  : i64
  %437 = llvm.mlir.constant(4 : index) : i64
  %438 = llvm.mul %5, %437  : i64
  %439 = llvm.add %436, %438  : i64
  %440 = llvm.add %439, %363  : i64
  %441 = llvm.getelementptr %184[%440] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %442 = llvm.load %441 : !llvm.ptr<f32>
  %443 = llvm.fmul %434, %442  : f32
  %444 = llvm.fadd %426, %443  : f32
  %445 = llvm.mlir.constant(32 : index) : i64
  %446 = llvm.mul %14, %445  : i64
  %447 = llvm.mlir.constant(8 : index) : i64
  %448 = llvm.mul %359, %447  : i64
  %449 = llvm.add %446, %448  : i64
  %450 = llvm.add %449, %16  : i64
  %451 = llvm.getelementptr %29[%450] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %452 = llvm.load %451 : !llvm.ptr<f32>
  %453 = llvm.mlir.constant(32 : index) : i64
  %454 = llvm.mul %14, %453  : i64
  %455 = llvm.mlir.constant(4 : index) : i64
  %456 = llvm.mul %16, %455  : i64
  %457 = llvm.add %454, %456  : i64
  %458 = llvm.add %457, %363  : i64
  %459 = llvm.getelementptr %184[%458] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %460 = llvm.load %459 : !llvm.ptr<f32>
  %461 = llvm.fmul %452, %460  : f32
  %462 = llvm.fadd %444, %461  : f32
  %463 = llvm.mlir.constant(32 : index) : i64
  %464 = llvm.mul %14, %463  : i64
  %465 = llvm.mlir.constant(8 : index) : i64
  %466 = llvm.mul %359, %465  : i64
  %467 = llvm.add %464, %466  : i64
  %468 = llvm.add %467, %7  : i64
  %469 = llvm.getelementptr %29[%468] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %470 = llvm.load %469 : !llvm.ptr<f32>
  %471 = llvm.mlir.constant(32 : index) : i64
  %472 = llvm.mul %14, %471  : i64
  %473 = llvm.mlir.constant(4 : index) : i64
  %474 = llvm.mul %7, %473  : i64
  %475 = llvm.add %472, %474  : i64
  %476 = llvm.add %475, %363  : i64
  %477 = llvm.getelementptr %184[%476] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %478 = llvm.load %477 : !llvm.ptr<f32>
  %479 = llvm.fmul %470, %478  : f32
  %480 = llvm.fadd %462, %479  : f32
  %481 = llvm.mlir.constant(32 : index) : i64
  %482 = llvm.mul %14, %481  : i64
  %483 = llvm.mlir.constant(8 : index) : i64
  %484 = llvm.mul %359, %483  : i64
  %485 = llvm.add %482, %484  : i64
  %486 = llvm.add %485, %9  : i64
  %487 = llvm.getelementptr %29[%486] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %488 = llvm.load %487 : !llvm.ptr<f32>
  %489 = llvm.mlir.constant(32 : index) : i64
  %490 = llvm.mul %14, %489  : i64
  %491 = llvm.mlir.constant(4 : index) : i64
  %492 = llvm.mul %9, %491  : i64
  %493 = llvm.add %490, %492  : i64
  %494 = llvm.add %493, %363  : i64
  %495 = llvm.getelementptr %184[%494] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %496 = llvm.load %495 : !llvm.ptr<f32>
  %497 = llvm.fmul %488, %496  : f32
  %498 = llvm.fadd %480, %497  : f32
  %499 = llvm.mlir.constant(32 : index) : i64
  %500 = llvm.mul %14, %499  : i64
  %501 = llvm.mlir.constant(8 : index) : i64
  %502 = llvm.mul %359, %501  : i64
  %503 = llvm.add %500, %502  : i64
  %504 = llvm.add %503, %11  : i64
  %505 = llvm.getelementptr %29[%504] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %506 = llvm.load %505 : !llvm.ptr<f32>
  %507 = llvm.mlir.constant(32 : index) : i64
  %508 = llvm.mul %14, %507  : i64
  %509 = llvm.mlir.constant(4 : index) : i64
  %510 = llvm.mul %11, %509  : i64
  %511 = llvm.add %508, %510  : i64
  %512 = llvm.add %511, %363  : i64
  %513 = llvm.getelementptr %184[%512] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %514 = llvm.load %513 : !llvm.ptr<f32>
  %515 = llvm.fmul %506, %514  : f32
  %516 = llvm.fadd %498, %515  : f32
  %517 = llvm.mlir.constant(16 : index) : i64
  %518 = llvm.mul %14, %517  : i64
  %519 = llvm.mlir.constant(4 : index) : i64
  %520 = llvm.mul %359, %519  : i64
  %521 = llvm.add %518, %520  : i64
  %522 = llvm.add %521, %363  : i64
  %523 = llvm.getelementptr %275[%522] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %516, %523 : !llvm.ptr<f32>
  %524 = llvm.add %362, %18  : i64
  %525 = builtin.unrealized_conversion_cast %524 : i64 to index
  cf.br ^bb10(%525 : index)
^bb12:  // pred: ^bb10
  %526 = llvm.add %358, %18  : i64
  %527 = builtin.unrealized_conversion_cast %526 : i64 to index
  cf.br ^bb9(%527 : index)
^bb13(%528: index):  // 2 preds: ^bb9, ^bb14
  %529 = builtin.unrealized_conversion_cast %528 : index to i64
  %530 = builtin.unrealized_conversion_cast %528 : index to i64
  %531 = llvm.icmp "slt" %529, %16 : i64
  cf.cond_br %531, ^bb14, ^bb15
^bb14:  // pred: ^bb13
  %532 = llvm.mlir.constant(16 : index) : i64
  %533 = llvm.mul %14, %532  : i64
  %534 = llvm.mlir.constant(4 : index) : i64
  %535 = llvm.mul %530, %534  : i64
  %536 = llvm.add %533, %535  : i64
  %537 = llvm.add %536, %14  : i64
  %538 = llvm.getelementptr %275[%537] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %539 = llvm.load %538 : !llvm.ptr<f32>
  %540 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %541 = llvm.mlir.constant(16 : index) : i64
  %542 = llvm.mul %14, %541  : i64
  %543 = llvm.mlir.constant(4 : index) : i64
  %544 = llvm.mul %530, %543  : i64
  %545 = llvm.add %542, %544  : i64
  %546 = llvm.add %545, %14  : i64
  %547 = llvm.getelementptr %540[%546] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %539, %547 : !llvm.ptr<f32>
  %548 = llvm.mlir.constant(16 : index) : i64
  %549 = llvm.mul %14, %548  : i64
  %550 = llvm.mlir.constant(4 : index) : i64
  %551 = llvm.mul %530, %550  : i64
  %552 = llvm.add %549, %551  : i64
  %553 = llvm.add %552, %18  : i64
  %554 = llvm.getelementptr %275[%553] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %555 = llvm.load %554 : !llvm.ptr<f32>
  %556 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %557 = llvm.mlir.constant(16 : index) : i64
  %558 = llvm.mul %14, %557  : i64
  %559 = llvm.mlir.constant(4 : index) : i64
  %560 = llvm.mul %530, %559  : i64
  %561 = llvm.add %558, %560  : i64
  %562 = llvm.add %561, %18  : i64
  %563 = llvm.getelementptr %556[%562] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %555, %563 : !llvm.ptr<f32>
  %564 = llvm.mlir.constant(16 : index) : i64
  %565 = llvm.mul %14, %564  : i64
  %566 = llvm.mlir.constant(4 : index) : i64
  %567 = llvm.mul %530, %566  : i64
  %568 = llvm.add %565, %567  : i64
  %569 = llvm.add %568, %3  : i64
  %570 = llvm.getelementptr %275[%569] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %571 = llvm.load %570 : !llvm.ptr<f32>
  %572 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %573 = llvm.mlir.constant(16 : index) : i64
  %574 = llvm.mul %14, %573  : i64
  %575 = llvm.mlir.constant(4 : index) : i64
  %576 = llvm.mul %530, %575  : i64
  %577 = llvm.add %574, %576  : i64
  %578 = llvm.add %577, %3  : i64
  %579 = llvm.getelementptr %572[%578] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %571, %579 : !llvm.ptr<f32>
  %580 = llvm.mlir.constant(16 : index) : i64
  %581 = llvm.mul %14, %580  : i64
  %582 = llvm.mlir.constant(4 : index) : i64
  %583 = llvm.mul %530, %582  : i64
  %584 = llvm.add %581, %583  : i64
  %585 = llvm.add %584, %5  : i64
  %586 = llvm.getelementptr %275[%585] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  %587 = llvm.load %586 : !llvm.ptr<f32>
  %588 = llvm.extractvalue %0[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
  %589 = llvm.mlir.constant(16 : index) : i64
  %590 = llvm.mul %14, %589  : i64
  %591 = llvm.mlir.constant(4 : index) : i64
  %592 = llvm.mul %530, %591  : i64
  %593 = llvm.add %590, %592  : i64
  %594 = llvm.add %593, %5  : i64
  %595 = llvm.getelementptr %588[%594] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
  llvm.store %587, %595 : !llvm.ptr<f32>
  %596 = llvm.add %529, %18  : i64
  %597 = builtin.unrealized_conversion_cast %596 : i64 to index
  cf.br ^bb13(%597 : index)
^bb15:  // pred: ^bb13
  return
}

// -----// IR Dump After ConvertStandardToLLVM //----- //
module attributes {llvm.data_layout = "", soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  llvm.func @main_kernel(%arg0: !llvm.ptr<f32> {llvm.noalias}, %arg1: !llvm.ptr<f32> {llvm.noalias}, %arg2: !llvm.ptr<f32> {llvm.noalias}) {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %2 = llvm.insertvalue %arg0, %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %3 = llvm.mlir.constant(0 : index) : i64
    %4 = llvm.insertvalue %3, %2[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %5 = llvm.mlir.constant(1 : index) : i64
    %6 = llvm.insertvalue %5, %4[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %7 = llvm.mlir.constant(32 : index) : i64
    %8 = llvm.insertvalue %7, %6[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %9 = llvm.mlir.constant(4 : index) : i64
    %10 = llvm.insertvalue %9, %8[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %11 = llvm.mlir.constant(8 : index) : i64
    %12 = llvm.insertvalue %11, %10[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %13 = llvm.mlir.constant(8 : index) : i64
    %14 = llvm.insertvalue %13, %12[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %15 = llvm.mlir.constant(1 : index) : i64
    %16 = llvm.insertvalue %15, %14[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %17 = builtin.unrealized_conversion_cast %16 : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)> to memref<1x4x8xf32>
    %18 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %19 = llvm.insertvalue %arg1, %18[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %20 = llvm.insertvalue %arg1, %19[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %21 = llvm.mlir.constant(0 : index) : i64
    %22 = llvm.insertvalue %21, %20[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %23 = llvm.mlir.constant(1 : index) : i64
    %24 = llvm.insertvalue %23, %22[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %25 = llvm.mlir.constant(32 : index) : i64
    %26 = llvm.insertvalue %25, %24[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %27 = llvm.mlir.constant(8 : index) : i64
    %28 = llvm.insertvalue %27, %26[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %29 = llvm.mlir.constant(4 : index) : i64
    %30 = llvm.insertvalue %29, %28[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %31 = llvm.mlir.constant(4 : index) : i64
    %32 = llvm.insertvalue %31, %30[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %33 = llvm.mlir.constant(1 : index) : i64
    %34 = llvm.insertvalue %33, %32[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %35 = builtin.unrealized_conversion_cast %34 : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)> to memref<1x8x4xf32>
    %36 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %37 = llvm.insertvalue %arg2, %36[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %38 = llvm.insertvalue %arg2, %37[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %39 = llvm.mlir.constant(0 : index) : i64
    %40 = llvm.insertvalue %39, %38[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %41 = llvm.mlir.constant(1 : index) : i64
    %42 = llvm.insertvalue %41, %40[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %43 = llvm.mlir.constant(16 : index) : i64
    %44 = llvm.insertvalue %43, %42[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %45 = llvm.mlir.constant(4 : index) : i64
    %46 = llvm.insertvalue %45, %44[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %47 = llvm.mlir.constant(4 : index) : i64
    %48 = llvm.insertvalue %47, %46[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %49 = llvm.mlir.constant(4 : index) : i64
    %50 = llvm.insertvalue %49, %48[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %51 = llvm.mlir.constant(1 : index) : i64
    %52 = llvm.insertvalue %51, %50[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %53 = builtin.unrealized_conversion_cast %52 : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)> to memref<1x4x4xf32>
    %54 = builtin.unrealized_conversion_cast %53 : memref<1x4x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %55 = builtin.unrealized_conversion_cast %35 : memref<1x8x4xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %56 = builtin.unrealized_conversion_cast %17 : memref<1x4x8xf32> to !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %57 = llvm.mlir.constant(2 : index) : i64
    %58 = builtin.unrealized_conversion_cast %57 : i64 to index
    %59 = llvm.mlir.constant(3 : index) : i64
    %60 = builtin.unrealized_conversion_cast %59 : i64 to index
    %61 = llvm.mlir.constant(5 : index) : i64
    %62 = builtin.unrealized_conversion_cast %61 : i64 to index
    %63 = llvm.mlir.constant(6 : index) : i64
    %64 = builtin.unrealized_conversion_cast %63 : i64 to index
    %65 = llvm.mlir.constant(7 : index) : i64
    %66 = builtin.unrealized_conversion_cast %65 : i64 to index
    %67 = llvm.mlir.constant(8 : index) : i64
    %68 = llvm.mlir.constant(0 : index) : i64
    %69 = builtin.unrealized_conversion_cast %68 : i64 to index
    %70 = llvm.mlir.constant(4 : index) : i64
    %71 = builtin.unrealized_conversion_cast %70 : i64 to index
    %72 = llvm.mlir.constant(1 : index) : i64
    %73 = builtin.unrealized_conversion_cast %72 : i64 to index
    %74 = llvm.mlir.constant(1 : index) : i64
    %75 = llvm.mlir.constant(4 : index) : i64
    %76 = llvm.mlir.constant(8 : index) : i64
    %77 = llvm.mlir.constant(1 : index) : i64
    %78 = llvm.mlir.constant(32 : index) : i64
    %79 = llvm.mlir.constant(32 : index) : i64
    %80 = llvm.mlir.null : !llvm.ptr<f32>
    %81 = llvm.getelementptr %80[%79] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %82 = llvm.ptrtoint %81 : !llvm.ptr<f32> to i64
    %83 = llvm.alloca %82 x f32 : (i64) -> !llvm.ptr<f32>
    %84 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %85 = llvm.insertvalue %83, %84[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %86 = llvm.insertvalue %83, %85[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %87 = llvm.mlir.constant(0 : index) : i64
    %88 = llvm.insertvalue %87, %86[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %89 = llvm.insertvalue %74, %88[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %90 = llvm.insertvalue %75, %89[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %91 = llvm.insertvalue %76, %90[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %92 = llvm.insertvalue %78, %91[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %93 = llvm.insertvalue %76, %92[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %94 = llvm.insertvalue %77, %93[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    llvm.br ^bb1(%68 : i64)
  ^bb1(%95: i64):  // 2 preds: ^bb0, ^bb2
    %96 = builtin.unrealized_conversion_cast %95 : i64 to index
    %97 = builtin.unrealized_conversion_cast %96 : index to i64
    %98 = builtin.unrealized_conversion_cast %96 : index to i64
    %99 = llvm.icmp "slt" %97, %70 : i64
    llvm.cond_br %99, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %100 = llvm.extractvalue %56[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %101 = llvm.mlir.constant(32 : index) : i64
    %102 = llvm.mul %68, %101  : i64
    %103 = llvm.mlir.constant(8 : index) : i64
    %104 = llvm.mul %98, %103  : i64
    %105 = llvm.add %102, %104  : i64
    %106 = llvm.add %105, %68  : i64
    %107 = llvm.getelementptr %100[%106] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %108 = llvm.load %107 : !llvm.ptr<f32>
    %109 = llvm.mlir.constant(32 : index) : i64
    %110 = llvm.mul %68, %109  : i64
    %111 = llvm.mlir.constant(8 : index) : i64
    %112 = llvm.mul %98, %111  : i64
    %113 = llvm.add %110, %112  : i64
    %114 = llvm.add %113, %68  : i64
    %115 = llvm.getelementptr %83[%114] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %108, %115 : !llvm.ptr<f32>
    %116 = llvm.extractvalue %56[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %117 = llvm.mlir.constant(32 : index) : i64
    %118 = llvm.mul %68, %117  : i64
    %119 = llvm.mlir.constant(8 : index) : i64
    %120 = llvm.mul %98, %119  : i64
    %121 = llvm.add %118, %120  : i64
    %122 = llvm.add %121, %72  : i64
    %123 = llvm.getelementptr %116[%122] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %124 = llvm.load %123 : !llvm.ptr<f32>
    %125 = llvm.mlir.constant(32 : index) : i64
    %126 = llvm.mul %68, %125  : i64
    %127 = llvm.mlir.constant(8 : index) : i64
    %128 = llvm.mul %98, %127  : i64
    %129 = llvm.add %126, %128  : i64
    %130 = llvm.add %129, %72  : i64
    %131 = llvm.getelementptr %83[%130] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %124, %131 : !llvm.ptr<f32>
    %132 = llvm.extractvalue %56[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %133 = llvm.mlir.constant(32 : index) : i64
    %134 = llvm.mul %68, %133  : i64
    %135 = llvm.mlir.constant(8 : index) : i64
    %136 = llvm.mul %98, %135  : i64
    %137 = llvm.add %134, %136  : i64
    %138 = llvm.add %137, %57  : i64
    %139 = llvm.getelementptr %132[%138] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %140 = llvm.load %139 : !llvm.ptr<f32>
    %141 = llvm.mlir.constant(32 : index) : i64
    %142 = llvm.mul %68, %141  : i64
    %143 = llvm.mlir.constant(8 : index) : i64
    %144 = llvm.mul %98, %143  : i64
    %145 = llvm.add %142, %144  : i64
    %146 = llvm.add %145, %57  : i64
    %147 = llvm.getelementptr %83[%146] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %140, %147 : !llvm.ptr<f32>
    %148 = llvm.extractvalue %56[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %149 = llvm.mlir.constant(32 : index) : i64
    %150 = llvm.mul %68, %149  : i64
    %151 = llvm.mlir.constant(8 : index) : i64
    %152 = llvm.mul %98, %151  : i64
    %153 = llvm.add %150, %152  : i64
    %154 = llvm.add %153, %59  : i64
    %155 = llvm.getelementptr %148[%154] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %156 = llvm.load %155 : !llvm.ptr<f32>
    %157 = llvm.mlir.constant(32 : index) : i64
    %158 = llvm.mul %68, %157  : i64
    %159 = llvm.mlir.constant(8 : index) : i64
    %160 = llvm.mul %98, %159  : i64
    %161 = llvm.add %158, %160  : i64
    %162 = llvm.add %161, %59  : i64
    %163 = llvm.getelementptr %83[%162] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %156, %163 : !llvm.ptr<f32>
    %164 = llvm.extractvalue %56[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %165 = llvm.mlir.constant(32 : index) : i64
    %166 = llvm.mul %68, %165  : i64
    %167 = llvm.mlir.constant(8 : index) : i64
    %168 = llvm.mul %98, %167  : i64
    %169 = llvm.add %166, %168  : i64
    %170 = llvm.add %169, %70  : i64
    %171 = llvm.getelementptr %164[%170] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %172 = llvm.load %171 : !llvm.ptr<f32>
    %173 = llvm.mlir.constant(32 : index) : i64
    %174 = llvm.mul %68, %173  : i64
    %175 = llvm.mlir.constant(8 : index) : i64
    %176 = llvm.mul %98, %175  : i64
    %177 = llvm.add %174, %176  : i64
    %178 = llvm.add %177, %70  : i64
    %179 = llvm.getelementptr %83[%178] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %172, %179 : !llvm.ptr<f32>
    %180 = llvm.extractvalue %56[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %181 = llvm.mlir.constant(32 : index) : i64
    %182 = llvm.mul %68, %181  : i64
    %183 = llvm.mlir.constant(8 : index) : i64
    %184 = llvm.mul %98, %183  : i64
    %185 = llvm.add %182, %184  : i64
    %186 = llvm.add %185, %61  : i64
    %187 = llvm.getelementptr %180[%186] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %188 = llvm.load %187 : !llvm.ptr<f32>
    %189 = llvm.mlir.constant(32 : index) : i64
    %190 = llvm.mul %68, %189  : i64
    %191 = llvm.mlir.constant(8 : index) : i64
    %192 = llvm.mul %98, %191  : i64
    %193 = llvm.add %190, %192  : i64
    %194 = llvm.add %193, %61  : i64
    %195 = llvm.getelementptr %83[%194] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %188, %195 : !llvm.ptr<f32>
    %196 = llvm.extractvalue %56[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %197 = llvm.mlir.constant(32 : index) : i64
    %198 = llvm.mul %68, %197  : i64
    %199 = llvm.mlir.constant(8 : index) : i64
    %200 = llvm.mul %98, %199  : i64
    %201 = llvm.add %198, %200  : i64
    %202 = llvm.add %201, %63  : i64
    %203 = llvm.getelementptr %196[%202] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %204 = llvm.load %203 : !llvm.ptr<f32>
    %205 = llvm.mlir.constant(32 : index) : i64
    %206 = llvm.mul %68, %205  : i64
    %207 = llvm.mlir.constant(8 : index) : i64
    %208 = llvm.mul %98, %207  : i64
    %209 = llvm.add %206, %208  : i64
    %210 = llvm.add %209, %63  : i64
    %211 = llvm.getelementptr %83[%210] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %204, %211 : !llvm.ptr<f32>
    %212 = llvm.extractvalue %56[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %213 = llvm.mlir.constant(32 : index) : i64
    %214 = llvm.mul %68, %213  : i64
    %215 = llvm.mlir.constant(8 : index) : i64
    %216 = llvm.mul %98, %215  : i64
    %217 = llvm.add %214, %216  : i64
    %218 = llvm.add %217, %65  : i64
    %219 = llvm.getelementptr %212[%218] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %220 = llvm.load %219 : !llvm.ptr<f32>
    %221 = llvm.mlir.constant(32 : index) : i64
    %222 = llvm.mul %68, %221  : i64
    %223 = llvm.mlir.constant(8 : index) : i64
    %224 = llvm.mul %98, %223  : i64
    %225 = llvm.add %222, %224  : i64
    %226 = llvm.add %225, %65  : i64
    %227 = llvm.getelementptr %83[%226] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %220, %227 : !llvm.ptr<f32>
    %228 = llvm.add %97, %72  : i64
    %229 = builtin.unrealized_conversion_cast %228 : i64 to index
    llvm.br ^bb1(%228 : i64)
  ^bb3:  // pred: ^bb1
    %230 = llvm.mlir.constant(1 : index) : i64
    %231 = llvm.mlir.constant(8 : index) : i64
    %232 = llvm.mlir.constant(4 : index) : i64
    %233 = llvm.mlir.constant(1 : index) : i64
    %234 = llvm.mlir.constant(32 : index) : i64
    %235 = llvm.mlir.constant(32 : index) : i64
    %236 = llvm.mlir.null : !llvm.ptr<f32>
    %237 = llvm.getelementptr %236[%235] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %238 = llvm.ptrtoint %237 : !llvm.ptr<f32> to i64
    %239 = llvm.alloca %238 x f32 : (i64) -> !llvm.ptr<f32>
    %240 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %241 = llvm.insertvalue %239, %240[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %242 = llvm.insertvalue %239, %241[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %243 = llvm.mlir.constant(0 : index) : i64
    %244 = llvm.insertvalue %243, %242[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %245 = llvm.insertvalue %230, %244[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %246 = llvm.insertvalue %231, %245[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %247 = llvm.insertvalue %232, %246[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %248 = llvm.insertvalue %234, %247[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %249 = llvm.insertvalue %232, %248[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %250 = llvm.insertvalue %233, %249[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    llvm.br ^bb4(%68 : i64)
  ^bb4(%251: i64):  // 2 preds: ^bb3, ^bb5
    %252 = builtin.unrealized_conversion_cast %251 : i64 to index
    %253 = builtin.unrealized_conversion_cast %252 : index to i64
    %254 = builtin.unrealized_conversion_cast %252 : index to i64
    %255 = llvm.icmp "slt" %253, %67 : i64
    llvm.cond_br %255, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %256 = llvm.extractvalue %55[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %257 = llvm.mlir.constant(32 : index) : i64
    %258 = llvm.mul %68, %257  : i64
    %259 = llvm.mlir.constant(4 : index) : i64
    %260 = llvm.mul %254, %259  : i64
    %261 = llvm.add %258, %260  : i64
    %262 = llvm.add %261, %68  : i64
    %263 = llvm.getelementptr %256[%262] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %264 = llvm.load %263 : !llvm.ptr<f32>
    %265 = llvm.mlir.constant(32 : index) : i64
    %266 = llvm.mul %68, %265  : i64
    %267 = llvm.mlir.constant(4 : index) : i64
    %268 = llvm.mul %254, %267  : i64
    %269 = llvm.add %266, %268  : i64
    %270 = llvm.add %269, %68  : i64
    %271 = llvm.getelementptr %239[%270] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %264, %271 : !llvm.ptr<f32>
    %272 = llvm.extractvalue %55[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %273 = llvm.mlir.constant(32 : index) : i64
    %274 = llvm.mul %68, %273  : i64
    %275 = llvm.mlir.constant(4 : index) : i64
    %276 = llvm.mul %254, %275  : i64
    %277 = llvm.add %274, %276  : i64
    %278 = llvm.add %277, %72  : i64
    %279 = llvm.getelementptr %272[%278] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %280 = llvm.load %279 : !llvm.ptr<f32>
    %281 = llvm.mlir.constant(32 : index) : i64
    %282 = llvm.mul %68, %281  : i64
    %283 = llvm.mlir.constant(4 : index) : i64
    %284 = llvm.mul %254, %283  : i64
    %285 = llvm.add %282, %284  : i64
    %286 = llvm.add %285, %72  : i64
    %287 = llvm.getelementptr %239[%286] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %280, %287 : !llvm.ptr<f32>
    %288 = llvm.extractvalue %55[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %289 = llvm.mlir.constant(32 : index) : i64
    %290 = llvm.mul %68, %289  : i64
    %291 = llvm.mlir.constant(4 : index) : i64
    %292 = llvm.mul %254, %291  : i64
    %293 = llvm.add %290, %292  : i64
    %294 = llvm.add %293, %57  : i64
    %295 = llvm.getelementptr %288[%294] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %296 = llvm.load %295 : !llvm.ptr<f32>
    %297 = llvm.mlir.constant(32 : index) : i64
    %298 = llvm.mul %68, %297  : i64
    %299 = llvm.mlir.constant(4 : index) : i64
    %300 = llvm.mul %254, %299  : i64
    %301 = llvm.add %298, %300  : i64
    %302 = llvm.add %301, %57  : i64
    %303 = llvm.getelementptr %239[%302] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %296, %303 : !llvm.ptr<f32>
    %304 = llvm.extractvalue %55[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %305 = llvm.mlir.constant(32 : index) : i64
    %306 = llvm.mul %68, %305  : i64
    %307 = llvm.mlir.constant(4 : index) : i64
    %308 = llvm.mul %254, %307  : i64
    %309 = llvm.add %306, %308  : i64
    %310 = llvm.add %309, %59  : i64
    %311 = llvm.getelementptr %304[%310] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %312 = llvm.load %311 : !llvm.ptr<f32>
    %313 = llvm.mlir.constant(32 : index) : i64
    %314 = llvm.mul %68, %313  : i64
    %315 = llvm.mlir.constant(4 : index) : i64
    %316 = llvm.mul %254, %315  : i64
    %317 = llvm.add %314, %316  : i64
    %318 = llvm.add %317, %59  : i64
    %319 = llvm.getelementptr %239[%318] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %312, %319 : !llvm.ptr<f32>
    %320 = llvm.add %253, %72  : i64
    %321 = builtin.unrealized_conversion_cast %320 : i64 to index
    llvm.br ^bb4(%320 : i64)
  ^bb6:  // pred: ^bb4
    %322 = llvm.mlir.constant(1 : index) : i64
    %323 = llvm.mlir.constant(4 : index) : i64
    %324 = llvm.mlir.constant(4 : index) : i64
    %325 = llvm.mlir.constant(1 : index) : i64
    %326 = llvm.mlir.constant(16 : index) : i64
    %327 = llvm.mlir.constant(16 : index) : i64
    %328 = llvm.mlir.null : !llvm.ptr<f32>
    %329 = llvm.getelementptr %328[%327] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %330 = llvm.ptrtoint %329 : !llvm.ptr<f32> to i64
    %331 = llvm.alloca %330 x f32 : (i64) -> !llvm.ptr<f32>
    %332 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %333 = llvm.insertvalue %331, %332[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %334 = llvm.insertvalue %331, %333[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %335 = llvm.mlir.constant(0 : index) : i64
    %336 = llvm.insertvalue %335, %334[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %337 = llvm.insertvalue %322, %336[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %338 = llvm.insertvalue %323, %337[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %339 = llvm.insertvalue %324, %338[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %340 = llvm.insertvalue %326, %339[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %341 = llvm.insertvalue %324, %340[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %342 = llvm.insertvalue %325, %341[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    llvm.br ^bb7(%68 : i64)
  ^bb7(%343: i64):  // 2 preds: ^bb6, ^bb8
    %344 = builtin.unrealized_conversion_cast %343 : i64 to index
    %345 = builtin.unrealized_conversion_cast %344 : index to i64
    %346 = builtin.unrealized_conversion_cast %344 : index to i64
    %347 = llvm.icmp "slt" %345, %70 : i64
    llvm.cond_br %347, ^bb8, ^bb9(%68 : i64)
  ^bb8:  // pred: ^bb7
    %348 = llvm.extractvalue %54[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %349 = llvm.mlir.constant(16 : index) : i64
    %350 = llvm.mul %68, %349  : i64
    %351 = llvm.mlir.constant(4 : index) : i64
    %352 = llvm.mul %346, %351  : i64
    %353 = llvm.add %350, %352  : i64
    %354 = llvm.add %353, %68  : i64
    %355 = llvm.getelementptr %348[%354] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %356 = llvm.load %355 : !llvm.ptr<f32>
    %357 = llvm.mlir.constant(16 : index) : i64
    %358 = llvm.mul %68, %357  : i64
    %359 = llvm.mlir.constant(4 : index) : i64
    %360 = llvm.mul %346, %359  : i64
    %361 = llvm.add %358, %360  : i64
    %362 = llvm.add %361, %68  : i64
    %363 = llvm.getelementptr %331[%362] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %356, %363 : !llvm.ptr<f32>
    %364 = llvm.extractvalue %54[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %365 = llvm.mlir.constant(16 : index) : i64
    %366 = llvm.mul %68, %365  : i64
    %367 = llvm.mlir.constant(4 : index) : i64
    %368 = llvm.mul %346, %367  : i64
    %369 = llvm.add %366, %368  : i64
    %370 = llvm.add %369, %72  : i64
    %371 = llvm.getelementptr %364[%370] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %372 = llvm.load %371 : !llvm.ptr<f32>
    %373 = llvm.mlir.constant(16 : index) : i64
    %374 = llvm.mul %68, %373  : i64
    %375 = llvm.mlir.constant(4 : index) : i64
    %376 = llvm.mul %346, %375  : i64
    %377 = llvm.add %374, %376  : i64
    %378 = llvm.add %377, %72  : i64
    %379 = llvm.getelementptr %331[%378] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %372, %379 : !llvm.ptr<f32>
    %380 = llvm.extractvalue %54[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %381 = llvm.mlir.constant(16 : index) : i64
    %382 = llvm.mul %68, %381  : i64
    %383 = llvm.mlir.constant(4 : index) : i64
    %384 = llvm.mul %346, %383  : i64
    %385 = llvm.add %382, %384  : i64
    %386 = llvm.add %385, %57  : i64
    %387 = llvm.getelementptr %380[%386] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %388 = llvm.load %387 : !llvm.ptr<f32>
    %389 = llvm.mlir.constant(16 : index) : i64
    %390 = llvm.mul %68, %389  : i64
    %391 = llvm.mlir.constant(4 : index) : i64
    %392 = llvm.mul %346, %391  : i64
    %393 = llvm.add %390, %392  : i64
    %394 = llvm.add %393, %57  : i64
    %395 = llvm.getelementptr %331[%394] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %388, %395 : !llvm.ptr<f32>
    %396 = llvm.extractvalue %54[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %397 = llvm.mlir.constant(16 : index) : i64
    %398 = llvm.mul %68, %397  : i64
    %399 = llvm.mlir.constant(4 : index) : i64
    %400 = llvm.mul %346, %399  : i64
    %401 = llvm.add %398, %400  : i64
    %402 = llvm.add %401, %59  : i64
    %403 = llvm.getelementptr %396[%402] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %404 = llvm.load %403 : !llvm.ptr<f32>
    %405 = llvm.mlir.constant(16 : index) : i64
    %406 = llvm.mul %68, %405  : i64
    %407 = llvm.mlir.constant(4 : index) : i64
    %408 = llvm.mul %346, %407  : i64
    %409 = llvm.add %406, %408  : i64
    %410 = llvm.add %409, %59  : i64
    %411 = llvm.getelementptr %331[%410] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %404, %411 : !llvm.ptr<f32>
    %412 = llvm.add %345, %72  : i64
    %413 = builtin.unrealized_conversion_cast %412 : i64 to index
    llvm.br ^bb7(%412 : i64)
  ^bb9(%414: i64):  // 2 preds: ^bb7, ^bb12
    %415 = builtin.unrealized_conversion_cast %414 : i64 to index
    %416 = builtin.unrealized_conversion_cast %415 : index to i64
    %417 = builtin.unrealized_conversion_cast %415 : index to i64
    %418 = llvm.icmp "slt" %416, %70 : i64
    llvm.cond_br %418, ^bb10(%68 : i64), ^bb13(%68 : i64)
  ^bb10(%419: i64):  // 2 preds: ^bb9, ^bb11
    %420 = builtin.unrealized_conversion_cast %419 : i64 to index
    %421 = builtin.unrealized_conversion_cast %420 : index to i64
    %422 = builtin.unrealized_conversion_cast %420 : index to i64
    %423 = llvm.icmp "slt" %421, %70 : i64
    llvm.cond_br %423, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %424 = llvm.mlir.constant(32 : index) : i64
    %425 = llvm.mul %68, %424  : i64
    %426 = llvm.mlir.constant(8 : index) : i64
    %427 = llvm.mul %417, %426  : i64
    %428 = llvm.add %425, %427  : i64
    %429 = llvm.add %428, %68  : i64
    %430 = llvm.getelementptr %83[%429] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %431 = llvm.load %430 : !llvm.ptr<f32>
    %432 = llvm.mlir.constant(32 : index) : i64
    %433 = llvm.mul %68, %432  : i64
    %434 = llvm.mlir.constant(4 : index) : i64
    %435 = llvm.mul %68, %434  : i64
    %436 = llvm.add %433, %435  : i64
    %437 = llvm.add %436, %422  : i64
    %438 = llvm.getelementptr %239[%437] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %439 = llvm.load %438 : !llvm.ptr<f32>
    %440 = llvm.mlir.constant(16 : index) : i64
    %441 = llvm.mul %68, %440  : i64
    %442 = llvm.mlir.constant(4 : index) : i64
    %443 = llvm.mul %417, %442  : i64
    %444 = llvm.add %441, %443  : i64
    %445 = llvm.add %444, %422  : i64
    %446 = llvm.getelementptr %331[%445] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %447 = llvm.load %446 : !llvm.ptr<f32>
    %448 = llvm.fmul %431, %439  : f32
    %449 = llvm.fadd %447, %448  : f32
    %450 = llvm.mlir.constant(32 : index) : i64
    %451 = llvm.mul %68, %450  : i64
    %452 = llvm.mlir.constant(8 : index) : i64
    %453 = llvm.mul %417, %452  : i64
    %454 = llvm.add %451, %453  : i64
    %455 = llvm.add %454, %72  : i64
    %456 = llvm.getelementptr %83[%455] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %457 = llvm.load %456 : !llvm.ptr<f32>
    %458 = llvm.mlir.constant(32 : index) : i64
    %459 = llvm.mul %68, %458  : i64
    %460 = llvm.mlir.constant(4 : index) : i64
    %461 = llvm.mul %72, %460  : i64
    %462 = llvm.add %459, %461  : i64
    %463 = llvm.add %462, %422  : i64
    %464 = llvm.getelementptr %239[%463] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %465 = llvm.load %464 : !llvm.ptr<f32>
    %466 = llvm.fmul %457, %465  : f32
    %467 = llvm.fadd %449, %466  : f32
    %468 = llvm.mlir.constant(32 : index) : i64
    %469 = llvm.mul %68, %468  : i64
    %470 = llvm.mlir.constant(8 : index) : i64
    %471 = llvm.mul %417, %470  : i64
    %472 = llvm.add %469, %471  : i64
    %473 = llvm.add %472, %57  : i64
    %474 = llvm.getelementptr %83[%473] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %475 = llvm.load %474 : !llvm.ptr<f32>
    %476 = llvm.mlir.constant(32 : index) : i64
    %477 = llvm.mul %68, %476  : i64
    %478 = llvm.mlir.constant(4 : index) : i64
    %479 = llvm.mul %57, %478  : i64
    %480 = llvm.add %477, %479  : i64
    %481 = llvm.add %480, %422  : i64
    %482 = llvm.getelementptr %239[%481] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %483 = llvm.load %482 : !llvm.ptr<f32>
    %484 = llvm.fmul %475, %483  : f32
    %485 = llvm.fadd %467, %484  : f32
    %486 = llvm.mlir.constant(32 : index) : i64
    %487 = llvm.mul %68, %486  : i64
    %488 = llvm.mlir.constant(8 : index) : i64
    %489 = llvm.mul %417, %488  : i64
    %490 = llvm.add %487, %489  : i64
    %491 = llvm.add %490, %59  : i64
    %492 = llvm.getelementptr %83[%491] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %493 = llvm.load %492 : !llvm.ptr<f32>
    %494 = llvm.mlir.constant(32 : index) : i64
    %495 = llvm.mul %68, %494  : i64
    %496 = llvm.mlir.constant(4 : index) : i64
    %497 = llvm.mul %59, %496  : i64
    %498 = llvm.add %495, %497  : i64
    %499 = llvm.add %498, %422  : i64
    %500 = llvm.getelementptr %239[%499] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %501 = llvm.load %500 : !llvm.ptr<f32>
    %502 = llvm.fmul %493, %501  : f32
    %503 = llvm.fadd %485, %502  : f32
    %504 = llvm.mlir.constant(32 : index) : i64
    %505 = llvm.mul %68, %504  : i64
    %506 = llvm.mlir.constant(8 : index) : i64
    %507 = llvm.mul %417, %506  : i64
    %508 = llvm.add %505, %507  : i64
    %509 = llvm.add %508, %70  : i64
    %510 = llvm.getelementptr %83[%509] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %511 = llvm.load %510 : !llvm.ptr<f32>
    %512 = llvm.mlir.constant(32 : index) : i64
    %513 = llvm.mul %68, %512  : i64
    %514 = llvm.mlir.constant(4 : index) : i64
    %515 = llvm.mul %70, %514  : i64
    %516 = llvm.add %513, %515  : i64
    %517 = llvm.add %516, %422  : i64
    %518 = llvm.getelementptr %239[%517] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %519 = llvm.load %518 : !llvm.ptr<f32>
    %520 = llvm.fmul %511, %519  : f32
    %521 = llvm.fadd %503, %520  : f32
    %522 = llvm.mlir.constant(32 : index) : i64
    %523 = llvm.mul %68, %522  : i64
    %524 = llvm.mlir.constant(8 : index) : i64
    %525 = llvm.mul %417, %524  : i64
    %526 = llvm.add %523, %525  : i64
    %527 = llvm.add %526, %61  : i64
    %528 = llvm.getelementptr %83[%527] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %529 = llvm.load %528 : !llvm.ptr<f32>
    %530 = llvm.mlir.constant(32 : index) : i64
    %531 = llvm.mul %68, %530  : i64
    %532 = llvm.mlir.constant(4 : index) : i64
    %533 = llvm.mul %61, %532  : i64
    %534 = llvm.add %531, %533  : i64
    %535 = llvm.add %534, %422  : i64
    %536 = llvm.getelementptr %239[%535] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %537 = llvm.load %536 : !llvm.ptr<f32>
    %538 = llvm.fmul %529, %537  : f32
    %539 = llvm.fadd %521, %538  : f32
    %540 = llvm.mlir.constant(32 : index) : i64
    %541 = llvm.mul %68, %540  : i64
    %542 = llvm.mlir.constant(8 : index) : i64
    %543 = llvm.mul %417, %542  : i64
    %544 = llvm.add %541, %543  : i64
    %545 = llvm.add %544, %63  : i64
    %546 = llvm.getelementptr %83[%545] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %547 = llvm.load %546 : !llvm.ptr<f32>
    %548 = llvm.mlir.constant(32 : index) : i64
    %549 = llvm.mul %68, %548  : i64
    %550 = llvm.mlir.constant(4 : index) : i64
    %551 = llvm.mul %63, %550  : i64
    %552 = llvm.add %549, %551  : i64
    %553 = llvm.add %552, %422  : i64
    %554 = llvm.getelementptr %239[%553] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %555 = llvm.load %554 : !llvm.ptr<f32>
    %556 = llvm.fmul %547, %555  : f32
    %557 = llvm.fadd %539, %556  : f32
    %558 = llvm.mlir.constant(32 : index) : i64
    %559 = llvm.mul %68, %558  : i64
    %560 = llvm.mlir.constant(8 : index) : i64
    %561 = llvm.mul %417, %560  : i64
    %562 = llvm.add %559, %561  : i64
    %563 = llvm.add %562, %65  : i64
    %564 = llvm.getelementptr %83[%563] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %565 = llvm.load %564 : !llvm.ptr<f32>
    %566 = llvm.mlir.constant(32 : index) : i64
    %567 = llvm.mul %68, %566  : i64
    %568 = llvm.mlir.constant(4 : index) : i64
    %569 = llvm.mul %65, %568  : i64
    %570 = llvm.add %567, %569  : i64
    %571 = llvm.add %570, %422  : i64
    %572 = llvm.getelementptr %239[%571] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %573 = llvm.load %572 : !llvm.ptr<f32>
    %574 = llvm.fmul %565, %573  : f32
    %575 = llvm.fadd %557, %574  : f32
    %576 = llvm.mlir.constant(16 : index) : i64
    %577 = llvm.mul %68, %576  : i64
    %578 = llvm.mlir.constant(4 : index) : i64
    %579 = llvm.mul %417, %578  : i64
    %580 = llvm.add %577, %579  : i64
    %581 = llvm.add %580, %422  : i64
    %582 = llvm.getelementptr %331[%581] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %575, %582 : !llvm.ptr<f32>
    %583 = llvm.add %421, %72  : i64
    %584 = builtin.unrealized_conversion_cast %583 : i64 to index
    llvm.br ^bb10(%583 : i64)
  ^bb12:  // pred: ^bb10
    %585 = llvm.add %416, %72  : i64
    %586 = builtin.unrealized_conversion_cast %585 : i64 to index
    llvm.br ^bb9(%585 : i64)
  ^bb13(%587: i64):  // 2 preds: ^bb9, ^bb14
    %588 = builtin.unrealized_conversion_cast %587 : i64 to index
    %589 = builtin.unrealized_conversion_cast %588 : index to i64
    %590 = builtin.unrealized_conversion_cast %588 : index to i64
    %591 = llvm.icmp "slt" %589, %70 : i64
    llvm.cond_br %591, ^bb14, ^bb15
  ^bb14:  // pred: ^bb13
    %592 = llvm.mlir.constant(16 : index) : i64
    %593 = llvm.mul %68, %592  : i64
    %594 = llvm.mlir.constant(4 : index) : i64
    %595 = llvm.mul %590, %594  : i64
    %596 = llvm.add %593, %595  : i64
    %597 = llvm.add %596, %68  : i64
    %598 = llvm.getelementptr %331[%597] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %599 = llvm.load %598 : !llvm.ptr<f32>
    %600 = llvm.extractvalue %54[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %601 = llvm.mlir.constant(16 : index) : i64
    %602 = llvm.mul %68, %601  : i64
    %603 = llvm.mlir.constant(4 : index) : i64
    %604 = llvm.mul %590, %603  : i64
    %605 = llvm.add %602, %604  : i64
    %606 = llvm.add %605, %68  : i64
    %607 = llvm.getelementptr %600[%606] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %599, %607 : !llvm.ptr<f32>
    %608 = llvm.mlir.constant(16 : index) : i64
    %609 = llvm.mul %68, %608  : i64
    %610 = llvm.mlir.constant(4 : index) : i64
    %611 = llvm.mul %590, %610  : i64
    %612 = llvm.add %609, %611  : i64
    %613 = llvm.add %612, %72  : i64
    %614 = llvm.getelementptr %331[%613] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %615 = llvm.load %614 : !llvm.ptr<f32>
    %616 = llvm.extractvalue %54[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %617 = llvm.mlir.constant(16 : index) : i64
    %618 = llvm.mul %68, %617  : i64
    %619 = llvm.mlir.constant(4 : index) : i64
    %620 = llvm.mul %590, %619  : i64
    %621 = llvm.add %618, %620  : i64
    %622 = llvm.add %621, %72  : i64
    %623 = llvm.getelementptr %616[%622] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %615, %623 : !llvm.ptr<f32>
    %624 = llvm.mlir.constant(16 : index) : i64
    %625 = llvm.mul %68, %624  : i64
    %626 = llvm.mlir.constant(4 : index) : i64
    %627 = llvm.mul %590, %626  : i64
    %628 = llvm.add %625, %627  : i64
    %629 = llvm.add %628, %57  : i64
    %630 = llvm.getelementptr %331[%629] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %631 = llvm.load %630 : !llvm.ptr<f32>
    %632 = llvm.extractvalue %54[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %633 = llvm.mlir.constant(16 : index) : i64
    %634 = llvm.mul %68, %633  : i64
    %635 = llvm.mlir.constant(4 : index) : i64
    %636 = llvm.mul %590, %635  : i64
    %637 = llvm.add %634, %636  : i64
    %638 = llvm.add %637, %57  : i64
    %639 = llvm.getelementptr %632[%638] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %631, %639 : !llvm.ptr<f32>
    %640 = llvm.mlir.constant(16 : index) : i64
    %641 = llvm.mul %68, %640  : i64
    %642 = llvm.mlir.constant(4 : index) : i64
    %643 = llvm.mul %590, %642  : i64
    %644 = llvm.add %641, %643  : i64
    %645 = llvm.add %644, %59  : i64
    %646 = llvm.getelementptr %331[%645] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %647 = llvm.load %646 : !llvm.ptr<f32>
    %648 = llvm.extractvalue %54[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %649 = llvm.mlir.constant(16 : index) : i64
    %650 = llvm.mul %68, %649  : i64
    %651 = llvm.mlir.constant(4 : index) : i64
    %652 = llvm.mul %590, %651  : i64
    %653 = llvm.add %650, %652  : i64
    %654 = llvm.add %653, %59  : i64
    %655 = llvm.getelementptr %648[%654] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %647, %655 : !llvm.ptr<f32>
    %656 = llvm.add %589, %72  : i64
    %657 = builtin.unrealized_conversion_cast %656 : i64 to index
    llvm.br ^bb13(%656 : i64)
  ^bb15:  // pred: ^bb13
    llvm.return
  }
}


// -----// IR Dump After ReconcileUnrealizedCasts //----- //
module attributes {llvm.data_layout = "", soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  llvm.func @main_kernel(%arg0: !llvm.ptr<f32> {llvm.noalias}, %arg1: !llvm.ptr<f32> {llvm.noalias}, %arg2: !llvm.ptr<f32> {llvm.noalias}) {
    %0 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %1 = llvm.insertvalue %arg0, %0[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %2 = llvm.insertvalue %arg0, %1[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %3 = llvm.mlir.constant(0 : index) : i64
    %4 = llvm.insertvalue %3, %2[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %5 = llvm.mlir.constant(1 : index) : i64
    %6 = llvm.insertvalue %5, %4[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %7 = llvm.mlir.constant(32 : index) : i64
    %8 = llvm.insertvalue %7, %6[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %9 = llvm.mlir.constant(4 : index) : i64
    %10 = llvm.insertvalue %9, %8[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %11 = llvm.mlir.constant(8 : index) : i64
    %12 = llvm.insertvalue %11, %10[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %13 = llvm.mlir.constant(8 : index) : i64
    %14 = llvm.insertvalue %13, %12[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %15 = llvm.mlir.constant(1 : index) : i64
    %16 = llvm.insertvalue %15, %14[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %17 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %18 = llvm.insertvalue %arg1, %17[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %19 = llvm.insertvalue %arg1, %18[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %20 = llvm.mlir.constant(0 : index) : i64
    %21 = llvm.insertvalue %20, %19[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %22 = llvm.mlir.constant(1 : index) : i64
    %23 = llvm.insertvalue %22, %21[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %24 = llvm.mlir.constant(32 : index) : i64
    %25 = llvm.insertvalue %24, %23[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %26 = llvm.mlir.constant(8 : index) : i64
    %27 = llvm.insertvalue %26, %25[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %28 = llvm.mlir.constant(4 : index) : i64
    %29 = llvm.insertvalue %28, %27[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %30 = llvm.mlir.constant(4 : index) : i64
    %31 = llvm.insertvalue %30, %29[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %32 = llvm.mlir.constant(1 : index) : i64
    %33 = llvm.insertvalue %32, %31[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %34 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %35 = llvm.insertvalue %arg2, %34[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %36 = llvm.insertvalue %arg2, %35[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %37 = llvm.mlir.constant(0 : index) : i64
    %38 = llvm.insertvalue %37, %36[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %39 = llvm.mlir.constant(1 : index) : i64
    %40 = llvm.insertvalue %39, %38[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %41 = llvm.mlir.constant(16 : index) : i64
    %42 = llvm.insertvalue %41, %40[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %43 = llvm.mlir.constant(4 : index) : i64
    %44 = llvm.insertvalue %43, %42[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %45 = llvm.mlir.constant(4 : index) : i64
    %46 = llvm.insertvalue %45, %44[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %47 = llvm.mlir.constant(4 : index) : i64
    %48 = llvm.insertvalue %47, %46[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %49 = llvm.mlir.constant(1 : index) : i64
    %50 = llvm.insertvalue %49, %48[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %51 = llvm.mlir.constant(2 : index) : i64
    %52 = llvm.mlir.constant(3 : index) : i64
    %53 = llvm.mlir.constant(5 : index) : i64
    %54 = llvm.mlir.constant(6 : index) : i64
    %55 = llvm.mlir.constant(7 : index) : i64
    %56 = llvm.mlir.constant(8 : index) : i64
    %57 = llvm.mlir.constant(0 : index) : i64
    %58 = llvm.mlir.constant(4 : index) : i64
    %59 = llvm.mlir.constant(1 : index) : i64
    %60 = llvm.mlir.constant(1 : index) : i64
    %61 = llvm.mlir.constant(4 : index) : i64
    %62 = llvm.mlir.constant(8 : index) : i64
    %63 = llvm.mlir.constant(1 : index) : i64
    %64 = llvm.mlir.constant(32 : index) : i64
    %65 = llvm.mlir.constant(32 : index) : i64
    %66 = llvm.mlir.null : !llvm.ptr<f32>
    %67 = llvm.getelementptr %66[%65] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %68 = llvm.ptrtoint %67 : !llvm.ptr<f32> to i64
    %69 = llvm.alloca %68 x f32 : (i64) -> !llvm.ptr<f32>
    %70 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %71 = llvm.insertvalue %69, %70[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %72 = llvm.insertvalue %69, %71[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %73 = llvm.mlir.constant(0 : index) : i64
    %74 = llvm.insertvalue %73, %72[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %75 = llvm.insertvalue %60, %74[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %76 = llvm.insertvalue %61, %75[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %77 = llvm.insertvalue %62, %76[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %78 = llvm.insertvalue %64, %77[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %79 = llvm.insertvalue %62, %78[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %80 = llvm.insertvalue %63, %79[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    llvm.br ^bb1(%57 : i64)
  ^bb1(%81: i64):  // 2 preds: ^bb0, ^bb2
    %82 = llvm.icmp "slt" %81, %58 : i64
    llvm.cond_br %82, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %83 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %84 = llvm.mlir.constant(32 : index) : i64
    %85 = llvm.mul %57, %84  : i64
    %86 = llvm.mlir.constant(8 : index) : i64
    %87 = llvm.mul %81, %86  : i64
    %88 = llvm.add %85, %87  : i64
    %89 = llvm.add %88, %57  : i64
    %90 = llvm.getelementptr %83[%89] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %91 = llvm.load %90 : !llvm.ptr<f32>
    %92 = llvm.mlir.constant(32 : index) : i64
    %93 = llvm.mul %57, %92  : i64
    %94 = llvm.mlir.constant(8 : index) : i64
    %95 = llvm.mul %81, %94  : i64
    %96 = llvm.add %93, %95  : i64
    %97 = llvm.add %96, %57  : i64
    %98 = llvm.getelementptr %69[%97] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %91, %98 : !llvm.ptr<f32>
    %99 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %100 = llvm.mlir.constant(32 : index) : i64
    %101 = llvm.mul %57, %100  : i64
    %102 = llvm.mlir.constant(8 : index) : i64
    %103 = llvm.mul %81, %102  : i64
    %104 = llvm.add %101, %103  : i64
    %105 = llvm.add %104, %59  : i64
    %106 = llvm.getelementptr %99[%105] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %107 = llvm.load %106 : !llvm.ptr<f32>
    %108 = llvm.mlir.constant(32 : index) : i64
    %109 = llvm.mul %57, %108  : i64
    %110 = llvm.mlir.constant(8 : index) : i64
    %111 = llvm.mul %81, %110  : i64
    %112 = llvm.add %109, %111  : i64
    %113 = llvm.add %112, %59  : i64
    %114 = llvm.getelementptr %69[%113] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %107, %114 : !llvm.ptr<f32>
    %115 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %116 = llvm.mlir.constant(32 : index) : i64
    %117 = llvm.mul %57, %116  : i64
    %118 = llvm.mlir.constant(8 : index) : i64
    %119 = llvm.mul %81, %118  : i64
    %120 = llvm.add %117, %119  : i64
    %121 = llvm.add %120, %51  : i64
    %122 = llvm.getelementptr %115[%121] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %123 = llvm.load %122 : !llvm.ptr<f32>
    %124 = llvm.mlir.constant(32 : index) : i64
    %125 = llvm.mul %57, %124  : i64
    %126 = llvm.mlir.constant(8 : index) : i64
    %127 = llvm.mul %81, %126  : i64
    %128 = llvm.add %125, %127  : i64
    %129 = llvm.add %128, %51  : i64
    %130 = llvm.getelementptr %69[%129] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %123, %130 : !llvm.ptr<f32>
    %131 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %132 = llvm.mlir.constant(32 : index) : i64
    %133 = llvm.mul %57, %132  : i64
    %134 = llvm.mlir.constant(8 : index) : i64
    %135 = llvm.mul %81, %134  : i64
    %136 = llvm.add %133, %135  : i64
    %137 = llvm.add %136, %52  : i64
    %138 = llvm.getelementptr %131[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %139 = llvm.load %138 : !llvm.ptr<f32>
    %140 = llvm.mlir.constant(32 : index) : i64
    %141 = llvm.mul %57, %140  : i64
    %142 = llvm.mlir.constant(8 : index) : i64
    %143 = llvm.mul %81, %142  : i64
    %144 = llvm.add %141, %143  : i64
    %145 = llvm.add %144, %52  : i64
    %146 = llvm.getelementptr %69[%145] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %139, %146 : !llvm.ptr<f32>
    %147 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %148 = llvm.mlir.constant(32 : index) : i64
    %149 = llvm.mul %57, %148  : i64
    %150 = llvm.mlir.constant(8 : index) : i64
    %151 = llvm.mul %81, %150  : i64
    %152 = llvm.add %149, %151  : i64
    %153 = llvm.add %152, %58  : i64
    %154 = llvm.getelementptr %147[%153] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %155 = llvm.load %154 : !llvm.ptr<f32>
    %156 = llvm.mlir.constant(32 : index) : i64
    %157 = llvm.mul %57, %156  : i64
    %158 = llvm.mlir.constant(8 : index) : i64
    %159 = llvm.mul %81, %158  : i64
    %160 = llvm.add %157, %159  : i64
    %161 = llvm.add %160, %58  : i64
    %162 = llvm.getelementptr %69[%161] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %155, %162 : !llvm.ptr<f32>
    %163 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %164 = llvm.mlir.constant(32 : index) : i64
    %165 = llvm.mul %57, %164  : i64
    %166 = llvm.mlir.constant(8 : index) : i64
    %167 = llvm.mul %81, %166  : i64
    %168 = llvm.add %165, %167  : i64
    %169 = llvm.add %168, %53  : i64
    %170 = llvm.getelementptr %163[%169] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %171 = llvm.load %170 : !llvm.ptr<f32>
    %172 = llvm.mlir.constant(32 : index) : i64
    %173 = llvm.mul %57, %172  : i64
    %174 = llvm.mlir.constant(8 : index) : i64
    %175 = llvm.mul %81, %174  : i64
    %176 = llvm.add %173, %175  : i64
    %177 = llvm.add %176, %53  : i64
    %178 = llvm.getelementptr %69[%177] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %171, %178 : !llvm.ptr<f32>
    %179 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %180 = llvm.mlir.constant(32 : index) : i64
    %181 = llvm.mul %57, %180  : i64
    %182 = llvm.mlir.constant(8 : index) : i64
    %183 = llvm.mul %81, %182  : i64
    %184 = llvm.add %181, %183  : i64
    %185 = llvm.add %184, %54  : i64
    %186 = llvm.getelementptr %179[%185] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %187 = llvm.load %186 : !llvm.ptr<f32>
    %188 = llvm.mlir.constant(32 : index) : i64
    %189 = llvm.mul %57, %188  : i64
    %190 = llvm.mlir.constant(8 : index) : i64
    %191 = llvm.mul %81, %190  : i64
    %192 = llvm.add %189, %191  : i64
    %193 = llvm.add %192, %54  : i64
    %194 = llvm.getelementptr %69[%193] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %187, %194 : !llvm.ptr<f32>
    %195 = llvm.extractvalue %16[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %196 = llvm.mlir.constant(32 : index) : i64
    %197 = llvm.mul %57, %196  : i64
    %198 = llvm.mlir.constant(8 : index) : i64
    %199 = llvm.mul %81, %198  : i64
    %200 = llvm.add %197, %199  : i64
    %201 = llvm.add %200, %55  : i64
    %202 = llvm.getelementptr %195[%201] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %203 = llvm.load %202 : !llvm.ptr<f32>
    %204 = llvm.mlir.constant(32 : index) : i64
    %205 = llvm.mul %57, %204  : i64
    %206 = llvm.mlir.constant(8 : index) : i64
    %207 = llvm.mul %81, %206  : i64
    %208 = llvm.add %205, %207  : i64
    %209 = llvm.add %208, %55  : i64
    %210 = llvm.getelementptr %69[%209] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %203, %210 : !llvm.ptr<f32>
    %211 = llvm.add %81, %59  : i64
    llvm.br ^bb1(%211 : i64)
  ^bb3:  // pred: ^bb1
    %212 = llvm.mlir.constant(1 : index) : i64
    %213 = llvm.mlir.constant(8 : index) : i64
    %214 = llvm.mlir.constant(4 : index) : i64
    %215 = llvm.mlir.constant(1 : index) : i64
    %216 = llvm.mlir.constant(32 : index) : i64
    %217 = llvm.mlir.constant(32 : index) : i64
    %218 = llvm.mlir.null : !llvm.ptr<f32>
    %219 = llvm.getelementptr %218[%217] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %220 = llvm.ptrtoint %219 : !llvm.ptr<f32> to i64
    %221 = llvm.alloca %220 x f32 : (i64) -> !llvm.ptr<f32>
    %222 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %223 = llvm.insertvalue %221, %222[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %224 = llvm.insertvalue %221, %223[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %225 = llvm.mlir.constant(0 : index) : i64
    %226 = llvm.insertvalue %225, %224[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %227 = llvm.insertvalue %212, %226[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %228 = llvm.insertvalue %213, %227[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %229 = llvm.insertvalue %214, %228[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %230 = llvm.insertvalue %216, %229[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %231 = llvm.insertvalue %214, %230[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %232 = llvm.insertvalue %215, %231[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    llvm.br ^bb4(%57 : i64)
  ^bb4(%233: i64):  // 2 preds: ^bb3, ^bb5
    %234 = llvm.icmp "slt" %233, %56 : i64
    llvm.cond_br %234, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %235 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %236 = llvm.mlir.constant(32 : index) : i64
    %237 = llvm.mul %57, %236  : i64
    %238 = llvm.mlir.constant(4 : index) : i64
    %239 = llvm.mul %233, %238  : i64
    %240 = llvm.add %237, %239  : i64
    %241 = llvm.add %240, %57  : i64
    %242 = llvm.getelementptr %235[%241] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %243 = llvm.load %242 : !llvm.ptr<f32>
    %244 = llvm.mlir.constant(32 : index) : i64
    %245 = llvm.mul %57, %244  : i64
    %246 = llvm.mlir.constant(4 : index) : i64
    %247 = llvm.mul %233, %246  : i64
    %248 = llvm.add %245, %247  : i64
    %249 = llvm.add %248, %57  : i64
    %250 = llvm.getelementptr %221[%249] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %243, %250 : !llvm.ptr<f32>
    %251 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %252 = llvm.mlir.constant(32 : index) : i64
    %253 = llvm.mul %57, %252  : i64
    %254 = llvm.mlir.constant(4 : index) : i64
    %255 = llvm.mul %233, %254  : i64
    %256 = llvm.add %253, %255  : i64
    %257 = llvm.add %256, %59  : i64
    %258 = llvm.getelementptr %251[%257] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %259 = llvm.load %258 : !llvm.ptr<f32>
    %260 = llvm.mlir.constant(32 : index) : i64
    %261 = llvm.mul %57, %260  : i64
    %262 = llvm.mlir.constant(4 : index) : i64
    %263 = llvm.mul %233, %262  : i64
    %264 = llvm.add %261, %263  : i64
    %265 = llvm.add %264, %59  : i64
    %266 = llvm.getelementptr %221[%265] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %259, %266 : !llvm.ptr<f32>
    %267 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %268 = llvm.mlir.constant(32 : index) : i64
    %269 = llvm.mul %57, %268  : i64
    %270 = llvm.mlir.constant(4 : index) : i64
    %271 = llvm.mul %233, %270  : i64
    %272 = llvm.add %269, %271  : i64
    %273 = llvm.add %272, %51  : i64
    %274 = llvm.getelementptr %267[%273] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %275 = llvm.load %274 : !llvm.ptr<f32>
    %276 = llvm.mlir.constant(32 : index) : i64
    %277 = llvm.mul %57, %276  : i64
    %278 = llvm.mlir.constant(4 : index) : i64
    %279 = llvm.mul %233, %278  : i64
    %280 = llvm.add %277, %279  : i64
    %281 = llvm.add %280, %51  : i64
    %282 = llvm.getelementptr %221[%281] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %275, %282 : !llvm.ptr<f32>
    %283 = llvm.extractvalue %33[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %284 = llvm.mlir.constant(32 : index) : i64
    %285 = llvm.mul %57, %284  : i64
    %286 = llvm.mlir.constant(4 : index) : i64
    %287 = llvm.mul %233, %286  : i64
    %288 = llvm.add %285, %287  : i64
    %289 = llvm.add %288, %52  : i64
    %290 = llvm.getelementptr %283[%289] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %291 = llvm.load %290 : !llvm.ptr<f32>
    %292 = llvm.mlir.constant(32 : index) : i64
    %293 = llvm.mul %57, %292  : i64
    %294 = llvm.mlir.constant(4 : index) : i64
    %295 = llvm.mul %233, %294  : i64
    %296 = llvm.add %293, %295  : i64
    %297 = llvm.add %296, %52  : i64
    %298 = llvm.getelementptr %221[%297] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %291, %298 : !llvm.ptr<f32>
    %299 = llvm.add %233, %59  : i64
    llvm.br ^bb4(%299 : i64)
  ^bb6:  // pred: ^bb4
    %300 = llvm.mlir.constant(1 : index) : i64
    %301 = llvm.mlir.constant(4 : index) : i64
    %302 = llvm.mlir.constant(4 : index) : i64
    %303 = llvm.mlir.constant(1 : index) : i64
    %304 = llvm.mlir.constant(16 : index) : i64
    %305 = llvm.mlir.constant(16 : index) : i64
    %306 = llvm.mlir.null : !llvm.ptr<f32>
    %307 = llvm.getelementptr %306[%305] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %308 = llvm.ptrtoint %307 : !llvm.ptr<f32> to i64
    %309 = llvm.alloca %308 x f32 : (i64) -> !llvm.ptr<f32>
    %310 = llvm.mlir.undef : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %311 = llvm.insertvalue %309, %310[0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %312 = llvm.insertvalue %309, %311[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %313 = llvm.mlir.constant(0 : index) : i64
    %314 = llvm.insertvalue %313, %312[2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %315 = llvm.insertvalue %300, %314[3, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %316 = llvm.insertvalue %301, %315[3, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %317 = llvm.insertvalue %302, %316[3, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %318 = llvm.insertvalue %304, %317[4, 0] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %319 = llvm.insertvalue %302, %318[4, 1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %320 = llvm.insertvalue %303, %319[4, 2] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    llvm.br ^bb7(%57 : i64)
  ^bb7(%321: i64):  // 2 preds: ^bb6, ^bb8
    %322 = llvm.icmp "slt" %321, %58 : i64
    llvm.cond_br %322, ^bb8, ^bb9(%57 : i64)
  ^bb8:  // pred: ^bb7
    %323 = llvm.extractvalue %50[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %324 = llvm.mlir.constant(16 : index) : i64
    %325 = llvm.mul %57, %324  : i64
    %326 = llvm.mlir.constant(4 : index) : i64
    %327 = llvm.mul %321, %326  : i64
    %328 = llvm.add %325, %327  : i64
    %329 = llvm.add %328, %57  : i64
    %330 = llvm.getelementptr %323[%329] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %331 = llvm.load %330 : !llvm.ptr<f32>
    %332 = llvm.mlir.constant(16 : index) : i64
    %333 = llvm.mul %57, %332  : i64
    %334 = llvm.mlir.constant(4 : index) : i64
    %335 = llvm.mul %321, %334  : i64
    %336 = llvm.add %333, %335  : i64
    %337 = llvm.add %336, %57  : i64
    %338 = llvm.getelementptr %309[%337] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %331, %338 : !llvm.ptr<f32>
    %339 = llvm.extractvalue %50[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %340 = llvm.mlir.constant(16 : index) : i64
    %341 = llvm.mul %57, %340  : i64
    %342 = llvm.mlir.constant(4 : index) : i64
    %343 = llvm.mul %321, %342  : i64
    %344 = llvm.add %341, %343  : i64
    %345 = llvm.add %344, %59  : i64
    %346 = llvm.getelementptr %339[%345] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %347 = llvm.load %346 : !llvm.ptr<f32>
    %348 = llvm.mlir.constant(16 : index) : i64
    %349 = llvm.mul %57, %348  : i64
    %350 = llvm.mlir.constant(4 : index) : i64
    %351 = llvm.mul %321, %350  : i64
    %352 = llvm.add %349, %351  : i64
    %353 = llvm.add %352, %59  : i64
    %354 = llvm.getelementptr %309[%353] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %347, %354 : !llvm.ptr<f32>
    %355 = llvm.extractvalue %50[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %356 = llvm.mlir.constant(16 : index) : i64
    %357 = llvm.mul %57, %356  : i64
    %358 = llvm.mlir.constant(4 : index) : i64
    %359 = llvm.mul %321, %358  : i64
    %360 = llvm.add %357, %359  : i64
    %361 = llvm.add %360, %51  : i64
    %362 = llvm.getelementptr %355[%361] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %363 = llvm.load %362 : !llvm.ptr<f32>
    %364 = llvm.mlir.constant(16 : index) : i64
    %365 = llvm.mul %57, %364  : i64
    %366 = llvm.mlir.constant(4 : index) : i64
    %367 = llvm.mul %321, %366  : i64
    %368 = llvm.add %365, %367  : i64
    %369 = llvm.add %368, %51  : i64
    %370 = llvm.getelementptr %309[%369] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %363, %370 : !llvm.ptr<f32>
    %371 = llvm.extractvalue %50[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %372 = llvm.mlir.constant(16 : index) : i64
    %373 = llvm.mul %57, %372  : i64
    %374 = llvm.mlir.constant(4 : index) : i64
    %375 = llvm.mul %321, %374  : i64
    %376 = llvm.add %373, %375  : i64
    %377 = llvm.add %376, %52  : i64
    %378 = llvm.getelementptr %371[%377] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %379 = llvm.load %378 : !llvm.ptr<f32>
    %380 = llvm.mlir.constant(16 : index) : i64
    %381 = llvm.mul %57, %380  : i64
    %382 = llvm.mlir.constant(4 : index) : i64
    %383 = llvm.mul %321, %382  : i64
    %384 = llvm.add %381, %383  : i64
    %385 = llvm.add %384, %52  : i64
    %386 = llvm.getelementptr %309[%385] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %379, %386 : !llvm.ptr<f32>
    %387 = llvm.add %321, %59  : i64
    llvm.br ^bb7(%387 : i64)
  ^bb9(%388: i64):  // 2 preds: ^bb7, ^bb12
    %389 = llvm.icmp "slt" %388, %58 : i64
    llvm.cond_br %389, ^bb10(%57 : i64), ^bb13(%57 : i64)
  ^bb10(%390: i64):  // 2 preds: ^bb9, ^bb11
    %391 = llvm.icmp "slt" %390, %58 : i64
    llvm.cond_br %391, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %392 = llvm.mlir.constant(32 : index) : i64
    %393 = llvm.mul %57, %392  : i64
    %394 = llvm.mlir.constant(8 : index) : i64
    %395 = llvm.mul %388, %394  : i64
    %396 = llvm.add %393, %395  : i64
    %397 = llvm.add %396, %57  : i64
    %398 = llvm.getelementptr %69[%397] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %399 = llvm.load %398 : !llvm.ptr<f32>
    %400 = llvm.mlir.constant(32 : index) : i64
    %401 = llvm.mul %57, %400  : i64
    %402 = llvm.mlir.constant(4 : index) : i64
    %403 = llvm.mul %57, %402  : i64
    %404 = llvm.add %401, %403  : i64
    %405 = llvm.add %404, %390  : i64
    %406 = llvm.getelementptr %221[%405] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %407 = llvm.load %406 : !llvm.ptr<f32>
    %408 = llvm.mlir.constant(16 : index) : i64
    %409 = llvm.mul %57, %408  : i64
    %410 = llvm.mlir.constant(4 : index) : i64
    %411 = llvm.mul %388, %410  : i64
    %412 = llvm.add %409, %411  : i64
    %413 = llvm.add %412, %390  : i64
    %414 = llvm.getelementptr %309[%413] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %415 = llvm.load %414 : !llvm.ptr<f32>
    %416 = llvm.fmul %399, %407  : f32
    %417 = llvm.fadd %415, %416  : f32
    %418 = llvm.mlir.constant(32 : index) : i64
    %419 = llvm.mul %57, %418  : i64
    %420 = llvm.mlir.constant(8 : index) : i64
    %421 = llvm.mul %388, %420  : i64
    %422 = llvm.add %419, %421  : i64
    %423 = llvm.add %422, %59  : i64
    %424 = llvm.getelementptr %69[%423] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %425 = llvm.load %424 : !llvm.ptr<f32>
    %426 = llvm.mlir.constant(32 : index) : i64
    %427 = llvm.mul %57, %426  : i64
    %428 = llvm.mlir.constant(4 : index) : i64
    %429 = llvm.mul %59, %428  : i64
    %430 = llvm.add %427, %429  : i64
    %431 = llvm.add %430, %390  : i64
    %432 = llvm.getelementptr %221[%431] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %433 = llvm.load %432 : !llvm.ptr<f32>
    %434 = llvm.fmul %425, %433  : f32
    %435 = llvm.fadd %417, %434  : f32
    %436 = llvm.mlir.constant(32 : index) : i64
    %437 = llvm.mul %57, %436  : i64
    %438 = llvm.mlir.constant(8 : index) : i64
    %439 = llvm.mul %388, %438  : i64
    %440 = llvm.add %437, %439  : i64
    %441 = llvm.add %440, %51  : i64
    %442 = llvm.getelementptr %69[%441] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %443 = llvm.load %442 : !llvm.ptr<f32>
    %444 = llvm.mlir.constant(32 : index) : i64
    %445 = llvm.mul %57, %444  : i64
    %446 = llvm.mlir.constant(4 : index) : i64
    %447 = llvm.mul %51, %446  : i64
    %448 = llvm.add %445, %447  : i64
    %449 = llvm.add %448, %390  : i64
    %450 = llvm.getelementptr %221[%449] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %451 = llvm.load %450 : !llvm.ptr<f32>
    %452 = llvm.fmul %443, %451  : f32
    %453 = llvm.fadd %435, %452  : f32
    %454 = llvm.mlir.constant(32 : index) : i64
    %455 = llvm.mul %57, %454  : i64
    %456 = llvm.mlir.constant(8 : index) : i64
    %457 = llvm.mul %388, %456  : i64
    %458 = llvm.add %455, %457  : i64
    %459 = llvm.add %458, %52  : i64
    %460 = llvm.getelementptr %69[%459] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %461 = llvm.load %460 : !llvm.ptr<f32>
    %462 = llvm.mlir.constant(32 : index) : i64
    %463 = llvm.mul %57, %462  : i64
    %464 = llvm.mlir.constant(4 : index) : i64
    %465 = llvm.mul %52, %464  : i64
    %466 = llvm.add %463, %465  : i64
    %467 = llvm.add %466, %390  : i64
    %468 = llvm.getelementptr %221[%467] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %469 = llvm.load %468 : !llvm.ptr<f32>
    %470 = llvm.fmul %461, %469  : f32
    %471 = llvm.fadd %453, %470  : f32
    %472 = llvm.mlir.constant(32 : index) : i64
    %473 = llvm.mul %57, %472  : i64
    %474 = llvm.mlir.constant(8 : index) : i64
    %475 = llvm.mul %388, %474  : i64
    %476 = llvm.add %473, %475  : i64
    %477 = llvm.add %476, %58  : i64
    %478 = llvm.getelementptr %69[%477] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %479 = llvm.load %478 : !llvm.ptr<f32>
    %480 = llvm.mlir.constant(32 : index) : i64
    %481 = llvm.mul %57, %480  : i64
    %482 = llvm.mlir.constant(4 : index) : i64
    %483 = llvm.mul %58, %482  : i64
    %484 = llvm.add %481, %483  : i64
    %485 = llvm.add %484, %390  : i64
    %486 = llvm.getelementptr %221[%485] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %487 = llvm.load %486 : !llvm.ptr<f32>
    %488 = llvm.fmul %479, %487  : f32
    %489 = llvm.fadd %471, %488  : f32
    %490 = llvm.mlir.constant(32 : index) : i64
    %491 = llvm.mul %57, %490  : i64
    %492 = llvm.mlir.constant(8 : index) : i64
    %493 = llvm.mul %388, %492  : i64
    %494 = llvm.add %491, %493  : i64
    %495 = llvm.add %494, %53  : i64
    %496 = llvm.getelementptr %69[%495] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %497 = llvm.load %496 : !llvm.ptr<f32>
    %498 = llvm.mlir.constant(32 : index) : i64
    %499 = llvm.mul %57, %498  : i64
    %500 = llvm.mlir.constant(4 : index) : i64
    %501 = llvm.mul %53, %500  : i64
    %502 = llvm.add %499, %501  : i64
    %503 = llvm.add %502, %390  : i64
    %504 = llvm.getelementptr %221[%503] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %505 = llvm.load %504 : !llvm.ptr<f32>
    %506 = llvm.fmul %497, %505  : f32
    %507 = llvm.fadd %489, %506  : f32
    %508 = llvm.mlir.constant(32 : index) : i64
    %509 = llvm.mul %57, %508  : i64
    %510 = llvm.mlir.constant(8 : index) : i64
    %511 = llvm.mul %388, %510  : i64
    %512 = llvm.add %509, %511  : i64
    %513 = llvm.add %512, %54  : i64
    %514 = llvm.getelementptr %69[%513] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %515 = llvm.load %514 : !llvm.ptr<f32>
    %516 = llvm.mlir.constant(32 : index) : i64
    %517 = llvm.mul %57, %516  : i64
    %518 = llvm.mlir.constant(4 : index) : i64
    %519 = llvm.mul %54, %518  : i64
    %520 = llvm.add %517, %519  : i64
    %521 = llvm.add %520, %390  : i64
    %522 = llvm.getelementptr %221[%521] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %523 = llvm.load %522 : !llvm.ptr<f32>
    %524 = llvm.fmul %515, %523  : f32
    %525 = llvm.fadd %507, %524  : f32
    %526 = llvm.mlir.constant(32 : index) : i64
    %527 = llvm.mul %57, %526  : i64
    %528 = llvm.mlir.constant(8 : index) : i64
    %529 = llvm.mul %388, %528  : i64
    %530 = llvm.add %527, %529  : i64
    %531 = llvm.add %530, %55  : i64
    %532 = llvm.getelementptr %69[%531] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %533 = llvm.load %532 : !llvm.ptr<f32>
    %534 = llvm.mlir.constant(32 : index) : i64
    %535 = llvm.mul %57, %534  : i64
    %536 = llvm.mlir.constant(4 : index) : i64
    %537 = llvm.mul %55, %536  : i64
    %538 = llvm.add %535, %537  : i64
    %539 = llvm.add %538, %390  : i64
    %540 = llvm.getelementptr %221[%539] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %541 = llvm.load %540 : !llvm.ptr<f32>
    %542 = llvm.fmul %533, %541  : f32
    %543 = llvm.fadd %525, %542  : f32
    %544 = llvm.mlir.constant(16 : index) : i64
    %545 = llvm.mul %57, %544  : i64
    %546 = llvm.mlir.constant(4 : index) : i64
    %547 = llvm.mul %388, %546  : i64
    %548 = llvm.add %545, %547  : i64
    %549 = llvm.add %548, %390  : i64
    %550 = llvm.getelementptr %309[%549] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %543, %550 : !llvm.ptr<f32>
    %551 = llvm.add %390, %59  : i64
    llvm.br ^bb10(%551 : i64)
  ^bb12:  // pred: ^bb10
    %552 = llvm.add %388, %59  : i64
    llvm.br ^bb9(%552 : i64)
  ^bb13(%553: i64):  // 2 preds: ^bb9, ^bb14
    %554 = llvm.icmp "slt" %553, %58 : i64
    llvm.cond_br %554, ^bb14, ^bb15
  ^bb14:  // pred: ^bb13
    %555 = llvm.mlir.constant(16 : index) : i64
    %556 = llvm.mul %57, %555  : i64
    %557 = llvm.mlir.constant(4 : index) : i64
    %558 = llvm.mul %553, %557  : i64
    %559 = llvm.add %556, %558  : i64
    %560 = llvm.add %559, %57  : i64
    %561 = llvm.getelementptr %309[%560] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %562 = llvm.load %561 : !llvm.ptr<f32>
    %563 = llvm.extractvalue %50[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %564 = llvm.mlir.constant(16 : index) : i64
    %565 = llvm.mul %57, %564  : i64
    %566 = llvm.mlir.constant(4 : index) : i64
    %567 = llvm.mul %553, %566  : i64
    %568 = llvm.add %565, %567  : i64
    %569 = llvm.add %568, %57  : i64
    %570 = llvm.getelementptr %563[%569] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %562, %570 : !llvm.ptr<f32>
    %571 = llvm.mlir.constant(16 : index) : i64
    %572 = llvm.mul %57, %571  : i64
    %573 = llvm.mlir.constant(4 : index) : i64
    %574 = llvm.mul %553, %573  : i64
    %575 = llvm.add %572, %574  : i64
    %576 = llvm.add %575, %59  : i64
    %577 = llvm.getelementptr %309[%576] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %578 = llvm.load %577 : !llvm.ptr<f32>
    %579 = llvm.extractvalue %50[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %580 = llvm.mlir.constant(16 : index) : i64
    %581 = llvm.mul %57, %580  : i64
    %582 = llvm.mlir.constant(4 : index) : i64
    %583 = llvm.mul %553, %582  : i64
    %584 = llvm.add %581, %583  : i64
    %585 = llvm.add %584, %59  : i64
    %586 = llvm.getelementptr %579[%585] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %578, %586 : !llvm.ptr<f32>
    %587 = llvm.mlir.constant(16 : index) : i64
    %588 = llvm.mul %57, %587  : i64
    %589 = llvm.mlir.constant(4 : index) : i64
    %590 = llvm.mul %553, %589  : i64
    %591 = llvm.add %588, %590  : i64
    %592 = llvm.add %591, %51  : i64
    %593 = llvm.getelementptr %309[%592] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %594 = llvm.load %593 : !llvm.ptr<f32>
    %595 = llvm.extractvalue %50[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %596 = llvm.mlir.constant(16 : index) : i64
    %597 = llvm.mul %57, %596  : i64
    %598 = llvm.mlir.constant(4 : index) : i64
    %599 = llvm.mul %553, %598  : i64
    %600 = llvm.add %597, %599  : i64
    %601 = llvm.add %600, %51  : i64
    %602 = llvm.getelementptr %595[%601] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %594, %602 : !llvm.ptr<f32>
    %603 = llvm.mlir.constant(16 : index) : i64
    %604 = llvm.mul %57, %603  : i64
    %605 = llvm.mlir.constant(4 : index) : i64
    %606 = llvm.mul %553, %605  : i64
    %607 = llvm.add %604, %606  : i64
    %608 = llvm.add %607, %52  : i64
    %609 = llvm.getelementptr %309[%608] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %610 = llvm.load %609 : !llvm.ptr<f32>
    %611 = llvm.extractvalue %50[1] : !llvm.struct<(ptr<f32>, ptr<f32>, i64, array<3 x i64>, array<3 x i64>)>
    %612 = llvm.mlir.constant(16 : index) : i64
    %613 = llvm.mul %57, %612  : i64
    %614 = llvm.mlir.constant(4 : index) : i64
    %615 = llvm.mul %553, %614  : i64
    %616 = llvm.add %613, %615  : i64
    %617 = llvm.add %616, %52  : i64
    %618 = llvm.getelementptr %611[%617] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %610, %618 : !llvm.ptr<f32>
    %619 = llvm.add %553, %59  : i64
    llvm.br ^bb13(%619 : i64)
  ^bb15:  // pred: ^bb13
    llvm.return
  }
}


// -----// IR Dump After Canonicalizer //----- //
module attributes {llvm.data_layout = "", soda.bambu.container_module, soda.container_module, tf.versions = {bad_consumers = [], min_consumer = 0 : i32, producer = 561 : i32}} {
  llvm.func @main_kernel(%arg0: !llvm.ptr<f32> {llvm.noalias}, %arg1: !llvm.ptr<f32> {llvm.noalias}, %arg2: !llvm.ptr<f32> {llvm.noalias}) {
    %0 = llvm.mlir.constant(2 : index) : i64
    %1 = llvm.mlir.constant(3 : index) : i64
    %2 = llvm.mlir.constant(5 : index) : i64
    %3 = llvm.mlir.constant(6 : index) : i64
    %4 = llvm.mlir.constant(7 : index) : i64
    %5 = llvm.mlir.constant(8 : index) : i64
    %6 = llvm.mlir.constant(0 : index) : i64
    %7 = llvm.mlir.constant(4 : index) : i64
    %8 = llvm.mlir.constant(1 : index) : i64
    %9 = llvm.mlir.constant(32 : index) : i64
    %10 = llvm.mlir.null : !llvm.ptr<f32>
    %11 = llvm.getelementptr %10[%9] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %12 = llvm.ptrtoint %11 : !llvm.ptr<f32> to i64
    %13 = llvm.alloca %12 x f32 : (i64) -> !llvm.ptr<f32>
    llvm.br ^bb1(%6 : i64)
  ^bb1(%14: i64):  // 2 preds: ^bb0, ^bb2
    %15 = llvm.icmp "slt" %14, %7 : i64
    llvm.cond_br %15, ^bb2, ^bb3
  ^bb2:  // pred: ^bb1
    %16 = llvm.mlir.constant(32 : index) : i64
    %17 = llvm.mul %6, %16  : i64
    %18 = llvm.mlir.constant(8 : index) : i64
    %19 = llvm.mul %14, %18  : i64
    %20 = llvm.add %17, %19  : i64
    %21 = llvm.add %20, %6  : i64
    %22 = llvm.getelementptr %arg0[%21] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %23 = llvm.load %22 : !llvm.ptr<f32>
    %24 = llvm.mlir.constant(32 : index) : i64
    %25 = llvm.mul %6, %24  : i64
    %26 = llvm.mlir.constant(8 : index) : i64
    %27 = llvm.mul %14, %26  : i64
    %28 = llvm.add %25, %27  : i64
    %29 = llvm.add %28, %6  : i64
    %30 = llvm.getelementptr %13[%29] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %23, %30 : !llvm.ptr<f32>
    %31 = llvm.mlir.constant(32 : index) : i64
    %32 = llvm.mul %6, %31  : i64
    %33 = llvm.mlir.constant(8 : index) : i64
    %34 = llvm.mul %14, %33  : i64
    %35 = llvm.add %32, %34  : i64
    %36 = llvm.add %35, %8  : i64
    %37 = llvm.getelementptr %arg0[%36] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %38 = llvm.load %37 : !llvm.ptr<f32>
    %39 = llvm.mlir.constant(32 : index) : i64
    %40 = llvm.mul %6, %39  : i64
    %41 = llvm.mlir.constant(8 : index) : i64
    %42 = llvm.mul %14, %41  : i64
    %43 = llvm.add %40, %42  : i64
    %44 = llvm.add %43, %8  : i64
    %45 = llvm.getelementptr %13[%44] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %38, %45 : !llvm.ptr<f32>
    %46 = llvm.mlir.constant(32 : index) : i64
    %47 = llvm.mul %6, %46  : i64
    %48 = llvm.mlir.constant(8 : index) : i64
    %49 = llvm.mul %14, %48  : i64
    %50 = llvm.add %47, %49  : i64
    %51 = llvm.add %50, %0  : i64
    %52 = llvm.getelementptr %arg0[%51] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %53 = llvm.load %52 : !llvm.ptr<f32>
    %54 = llvm.mlir.constant(32 : index) : i64
    %55 = llvm.mul %6, %54  : i64
    %56 = llvm.mlir.constant(8 : index) : i64
    %57 = llvm.mul %14, %56  : i64
    %58 = llvm.add %55, %57  : i64
    %59 = llvm.add %58, %0  : i64
    %60 = llvm.getelementptr %13[%59] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %53, %60 : !llvm.ptr<f32>
    %61 = llvm.mlir.constant(32 : index) : i64
    %62 = llvm.mul %6, %61  : i64
    %63 = llvm.mlir.constant(8 : index) : i64
    %64 = llvm.mul %14, %63  : i64
    %65 = llvm.add %62, %64  : i64
    %66 = llvm.add %65, %1  : i64
    %67 = llvm.getelementptr %arg0[%66] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %68 = llvm.load %67 : !llvm.ptr<f32>
    %69 = llvm.mlir.constant(32 : index) : i64
    %70 = llvm.mul %6, %69  : i64
    %71 = llvm.mlir.constant(8 : index) : i64
    %72 = llvm.mul %14, %71  : i64
    %73 = llvm.add %70, %72  : i64
    %74 = llvm.add %73, %1  : i64
    %75 = llvm.getelementptr %13[%74] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %68, %75 : !llvm.ptr<f32>
    %76 = llvm.mlir.constant(32 : index) : i64
    %77 = llvm.mul %6, %76  : i64
    %78 = llvm.mlir.constant(8 : index) : i64
    %79 = llvm.mul %14, %78  : i64
    %80 = llvm.add %77, %79  : i64
    %81 = llvm.add %80, %7  : i64
    %82 = llvm.getelementptr %arg0[%81] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %83 = llvm.load %82 : !llvm.ptr<f32>
    %84 = llvm.mlir.constant(32 : index) : i64
    %85 = llvm.mul %6, %84  : i64
    %86 = llvm.mlir.constant(8 : index) : i64
    %87 = llvm.mul %14, %86  : i64
    %88 = llvm.add %85, %87  : i64
    %89 = llvm.add %88, %7  : i64
    %90 = llvm.getelementptr %13[%89] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %83, %90 : !llvm.ptr<f32>
    %91 = llvm.mlir.constant(32 : index) : i64
    %92 = llvm.mul %6, %91  : i64
    %93 = llvm.mlir.constant(8 : index) : i64
    %94 = llvm.mul %14, %93  : i64
    %95 = llvm.add %92, %94  : i64
    %96 = llvm.add %95, %2  : i64
    %97 = llvm.getelementptr %arg0[%96] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %98 = llvm.load %97 : !llvm.ptr<f32>
    %99 = llvm.mlir.constant(32 : index) : i64
    %100 = llvm.mul %6, %99  : i64
    %101 = llvm.mlir.constant(8 : index) : i64
    %102 = llvm.mul %14, %101  : i64
    %103 = llvm.add %100, %102  : i64
    %104 = llvm.add %103, %2  : i64
    %105 = llvm.getelementptr %13[%104] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %98, %105 : !llvm.ptr<f32>
    %106 = llvm.mlir.constant(32 : index) : i64
    %107 = llvm.mul %6, %106  : i64
    %108 = llvm.mlir.constant(8 : index) : i64
    %109 = llvm.mul %14, %108  : i64
    %110 = llvm.add %107, %109  : i64
    %111 = llvm.add %110, %3  : i64
    %112 = llvm.getelementptr %arg0[%111] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %113 = llvm.load %112 : !llvm.ptr<f32>
    %114 = llvm.mlir.constant(32 : index) : i64
    %115 = llvm.mul %6, %114  : i64
    %116 = llvm.mlir.constant(8 : index) : i64
    %117 = llvm.mul %14, %116  : i64
    %118 = llvm.add %115, %117  : i64
    %119 = llvm.add %118, %3  : i64
    %120 = llvm.getelementptr %13[%119] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %113, %120 : !llvm.ptr<f32>
    %121 = llvm.mlir.constant(32 : index) : i64
    %122 = llvm.mul %6, %121  : i64
    %123 = llvm.mlir.constant(8 : index) : i64
    %124 = llvm.mul %14, %123  : i64
    %125 = llvm.add %122, %124  : i64
    %126 = llvm.add %125, %4  : i64
    %127 = llvm.getelementptr %arg0[%126] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %128 = llvm.load %127 : !llvm.ptr<f32>
    %129 = llvm.mlir.constant(32 : index) : i64
    %130 = llvm.mul %6, %129  : i64
    %131 = llvm.mlir.constant(8 : index) : i64
    %132 = llvm.mul %14, %131  : i64
    %133 = llvm.add %130, %132  : i64
    %134 = llvm.add %133, %4  : i64
    %135 = llvm.getelementptr %13[%134] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %128, %135 : !llvm.ptr<f32>
    %136 = llvm.add %14, %8  : i64
    llvm.br ^bb1(%136 : i64)
  ^bb3:  // pred: ^bb1
    %137 = llvm.mlir.constant(32 : index) : i64
    %138 = llvm.mlir.null : !llvm.ptr<f32>
    %139 = llvm.getelementptr %138[%137] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %140 = llvm.ptrtoint %139 : !llvm.ptr<f32> to i64
    %141 = llvm.alloca %140 x f32 : (i64) -> !llvm.ptr<f32>
    llvm.br ^bb4(%6 : i64)
  ^bb4(%142: i64):  // 2 preds: ^bb3, ^bb5
    %143 = llvm.icmp "slt" %142, %5 : i64
    llvm.cond_br %143, ^bb5, ^bb6
  ^bb5:  // pred: ^bb4
    %144 = llvm.mlir.constant(32 : index) : i64
    %145 = llvm.mul %6, %144  : i64
    %146 = llvm.mlir.constant(4 : index) : i64
    %147 = llvm.mul %142, %146  : i64
    %148 = llvm.add %145, %147  : i64
    %149 = llvm.add %148, %6  : i64
    %150 = llvm.getelementptr %arg1[%149] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %151 = llvm.load %150 : !llvm.ptr<f32>
    %152 = llvm.mlir.constant(32 : index) : i64
    %153 = llvm.mul %6, %152  : i64
    %154 = llvm.mlir.constant(4 : index) : i64
    %155 = llvm.mul %142, %154  : i64
    %156 = llvm.add %153, %155  : i64
    %157 = llvm.add %156, %6  : i64
    %158 = llvm.getelementptr %141[%157] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %151, %158 : !llvm.ptr<f32>
    %159 = llvm.mlir.constant(32 : index) : i64
    %160 = llvm.mul %6, %159  : i64
    %161 = llvm.mlir.constant(4 : index) : i64
    %162 = llvm.mul %142, %161  : i64
    %163 = llvm.add %160, %162  : i64
    %164 = llvm.add %163, %8  : i64
    %165 = llvm.getelementptr %arg1[%164] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %166 = llvm.load %165 : !llvm.ptr<f32>
    %167 = llvm.mlir.constant(32 : index) : i64
    %168 = llvm.mul %6, %167  : i64
    %169 = llvm.mlir.constant(4 : index) : i64
    %170 = llvm.mul %142, %169  : i64
    %171 = llvm.add %168, %170  : i64
    %172 = llvm.add %171, %8  : i64
    %173 = llvm.getelementptr %141[%172] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %166, %173 : !llvm.ptr<f32>
    %174 = llvm.mlir.constant(32 : index) : i64
    %175 = llvm.mul %6, %174  : i64
    %176 = llvm.mlir.constant(4 : index) : i64
    %177 = llvm.mul %142, %176  : i64
    %178 = llvm.add %175, %177  : i64
    %179 = llvm.add %178, %0  : i64
    %180 = llvm.getelementptr %arg1[%179] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %181 = llvm.load %180 : !llvm.ptr<f32>
    %182 = llvm.mlir.constant(32 : index) : i64
    %183 = llvm.mul %6, %182  : i64
    %184 = llvm.mlir.constant(4 : index) : i64
    %185 = llvm.mul %142, %184  : i64
    %186 = llvm.add %183, %185  : i64
    %187 = llvm.add %186, %0  : i64
    %188 = llvm.getelementptr %141[%187] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %181, %188 : !llvm.ptr<f32>
    %189 = llvm.mlir.constant(32 : index) : i64
    %190 = llvm.mul %6, %189  : i64
    %191 = llvm.mlir.constant(4 : index) : i64
    %192 = llvm.mul %142, %191  : i64
    %193 = llvm.add %190, %192  : i64
    %194 = llvm.add %193, %1  : i64
    %195 = llvm.getelementptr %arg1[%194] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %196 = llvm.load %195 : !llvm.ptr<f32>
    %197 = llvm.mlir.constant(32 : index) : i64
    %198 = llvm.mul %6, %197  : i64
    %199 = llvm.mlir.constant(4 : index) : i64
    %200 = llvm.mul %142, %199  : i64
    %201 = llvm.add %198, %200  : i64
    %202 = llvm.add %201, %1  : i64
    %203 = llvm.getelementptr %141[%202] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %196, %203 : !llvm.ptr<f32>
    %204 = llvm.add %142, %8  : i64
    llvm.br ^bb4(%204 : i64)
  ^bb6:  // pred: ^bb4
    %205 = llvm.mlir.constant(16 : index) : i64
    %206 = llvm.mlir.null : !llvm.ptr<f32>
    %207 = llvm.getelementptr %206[%205] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %208 = llvm.ptrtoint %207 : !llvm.ptr<f32> to i64
    %209 = llvm.alloca %208 x f32 : (i64) -> !llvm.ptr<f32>
    llvm.br ^bb7(%6 : i64)
  ^bb7(%210: i64):  // 2 preds: ^bb6, ^bb8
    %211 = llvm.icmp "slt" %210, %7 : i64
    llvm.cond_br %211, ^bb8, ^bb9(%6 : i64)
  ^bb8:  // pred: ^bb7
    %212 = llvm.mlir.constant(16 : index) : i64
    %213 = llvm.mul %6, %212  : i64
    %214 = llvm.mlir.constant(4 : index) : i64
    %215 = llvm.mul %210, %214  : i64
    %216 = llvm.add %213, %215  : i64
    %217 = llvm.add %216, %6  : i64
    %218 = llvm.getelementptr %arg2[%217] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %219 = llvm.load %218 : !llvm.ptr<f32>
    %220 = llvm.mlir.constant(16 : index) : i64
    %221 = llvm.mul %6, %220  : i64
    %222 = llvm.mlir.constant(4 : index) : i64
    %223 = llvm.mul %210, %222  : i64
    %224 = llvm.add %221, %223  : i64
    %225 = llvm.add %224, %6  : i64
    %226 = llvm.getelementptr %209[%225] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %219, %226 : !llvm.ptr<f32>
    %227 = llvm.mlir.constant(16 : index) : i64
    %228 = llvm.mul %6, %227  : i64
    %229 = llvm.mlir.constant(4 : index) : i64
    %230 = llvm.mul %210, %229  : i64
    %231 = llvm.add %228, %230  : i64
    %232 = llvm.add %231, %8  : i64
    %233 = llvm.getelementptr %arg2[%232] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %234 = llvm.load %233 : !llvm.ptr<f32>
    %235 = llvm.mlir.constant(16 : index) : i64
    %236 = llvm.mul %6, %235  : i64
    %237 = llvm.mlir.constant(4 : index) : i64
    %238 = llvm.mul %210, %237  : i64
    %239 = llvm.add %236, %238  : i64
    %240 = llvm.add %239, %8  : i64
    %241 = llvm.getelementptr %209[%240] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %234, %241 : !llvm.ptr<f32>
    %242 = llvm.mlir.constant(16 : index) : i64
    %243 = llvm.mul %6, %242  : i64
    %244 = llvm.mlir.constant(4 : index) : i64
    %245 = llvm.mul %210, %244  : i64
    %246 = llvm.add %243, %245  : i64
    %247 = llvm.add %246, %0  : i64
    %248 = llvm.getelementptr %arg2[%247] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %249 = llvm.load %248 : !llvm.ptr<f32>
    %250 = llvm.mlir.constant(16 : index) : i64
    %251 = llvm.mul %6, %250  : i64
    %252 = llvm.mlir.constant(4 : index) : i64
    %253 = llvm.mul %210, %252  : i64
    %254 = llvm.add %251, %253  : i64
    %255 = llvm.add %254, %0  : i64
    %256 = llvm.getelementptr %209[%255] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %249, %256 : !llvm.ptr<f32>
    %257 = llvm.mlir.constant(16 : index) : i64
    %258 = llvm.mul %6, %257  : i64
    %259 = llvm.mlir.constant(4 : index) : i64
    %260 = llvm.mul %210, %259  : i64
    %261 = llvm.add %258, %260  : i64
    %262 = llvm.add %261, %1  : i64
    %263 = llvm.getelementptr %arg2[%262] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %264 = llvm.load %263 : !llvm.ptr<f32>
    %265 = llvm.mlir.constant(16 : index) : i64
    %266 = llvm.mul %6, %265  : i64
    %267 = llvm.mlir.constant(4 : index) : i64
    %268 = llvm.mul %210, %267  : i64
    %269 = llvm.add %266, %268  : i64
    %270 = llvm.add %269, %1  : i64
    %271 = llvm.getelementptr %209[%270] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %264, %271 : !llvm.ptr<f32>
    %272 = llvm.add %210, %8  : i64
    llvm.br ^bb7(%272 : i64)
  ^bb9(%273: i64):  // 2 preds: ^bb7, ^bb12
    %274 = llvm.icmp "slt" %273, %7 : i64
    llvm.cond_br %274, ^bb10(%6 : i64), ^bb13(%6 : i64)
  ^bb10(%275: i64):  // 2 preds: ^bb9, ^bb11
    %276 = llvm.icmp "slt" %275, %7 : i64
    llvm.cond_br %276, ^bb11, ^bb12
  ^bb11:  // pred: ^bb10
    %277 = llvm.mlir.constant(32 : index) : i64
    %278 = llvm.mul %6, %277  : i64
    %279 = llvm.mlir.constant(8 : index) : i64
    %280 = llvm.mul %273, %279  : i64
    %281 = llvm.add %278, %280  : i64
    %282 = llvm.add %281, %6  : i64
    %283 = llvm.getelementptr %13[%282] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %284 = llvm.load %283 : !llvm.ptr<f32>
    %285 = llvm.mlir.constant(32 : index) : i64
    %286 = llvm.mul %6, %285  : i64
    %287 = llvm.mlir.constant(4 : index) : i64
    %288 = llvm.mul %6, %287  : i64
    %289 = llvm.add %286, %288  : i64
    %290 = llvm.add %289, %275  : i64
    %291 = llvm.getelementptr %141[%290] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %292 = llvm.load %291 : !llvm.ptr<f32>
    %293 = llvm.mlir.constant(16 : index) : i64
    %294 = llvm.mul %6, %293  : i64
    %295 = llvm.mlir.constant(4 : index) : i64
    %296 = llvm.mul %273, %295  : i64
    %297 = llvm.add %294, %296  : i64
    %298 = llvm.add %297, %275  : i64
    %299 = llvm.getelementptr %209[%298] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %300 = llvm.load %299 : !llvm.ptr<f32>
    %301 = llvm.fmul %284, %292  : f32
    %302 = llvm.fadd %300, %301  : f32
    %303 = llvm.mlir.constant(32 : index) : i64
    %304 = llvm.mul %6, %303  : i64
    %305 = llvm.mlir.constant(8 : index) : i64
    %306 = llvm.mul %273, %305  : i64
    %307 = llvm.add %304, %306  : i64
    %308 = llvm.add %307, %8  : i64
    %309 = llvm.getelementptr %13[%308] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %310 = llvm.load %309 : !llvm.ptr<f32>
    %311 = llvm.mlir.constant(32 : index) : i64
    %312 = llvm.mul %6, %311  : i64
    %313 = llvm.mlir.constant(4 : index) : i64
    %314 = llvm.mul %8, %313  : i64
    %315 = llvm.add %312, %314  : i64
    %316 = llvm.add %315, %275  : i64
    %317 = llvm.getelementptr %141[%316] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %318 = llvm.load %317 : !llvm.ptr<f32>
    %319 = llvm.fmul %310, %318  : f32
    %320 = llvm.fadd %302, %319  : f32
    %321 = llvm.mlir.constant(32 : index) : i64
    %322 = llvm.mul %6, %321  : i64
    %323 = llvm.mlir.constant(8 : index) : i64
    %324 = llvm.mul %273, %323  : i64
    %325 = llvm.add %322, %324  : i64
    %326 = llvm.add %325, %0  : i64
    %327 = llvm.getelementptr %13[%326] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %328 = llvm.load %327 : !llvm.ptr<f32>
    %329 = llvm.mlir.constant(32 : index) : i64
    %330 = llvm.mul %6, %329  : i64
    %331 = llvm.mlir.constant(4 : index) : i64
    %332 = llvm.mul %0, %331  : i64
    %333 = llvm.add %330, %332  : i64
    %334 = llvm.add %333, %275  : i64
    %335 = llvm.getelementptr %141[%334] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %336 = llvm.load %335 : !llvm.ptr<f32>
    %337 = llvm.fmul %328, %336  : f32
    %338 = llvm.fadd %320, %337  : f32
    %339 = llvm.mlir.constant(32 : index) : i64
    %340 = llvm.mul %6, %339  : i64
    %341 = llvm.mlir.constant(8 : index) : i64
    %342 = llvm.mul %273, %341  : i64
    %343 = llvm.add %340, %342  : i64
    %344 = llvm.add %343, %1  : i64
    %345 = llvm.getelementptr %13[%344] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %346 = llvm.load %345 : !llvm.ptr<f32>
    %347 = llvm.mlir.constant(32 : index) : i64
    %348 = llvm.mul %6, %347  : i64
    %349 = llvm.mlir.constant(4 : index) : i64
    %350 = llvm.mul %1, %349  : i64
    %351 = llvm.add %348, %350  : i64
    %352 = llvm.add %351, %275  : i64
    %353 = llvm.getelementptr %141[%352] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %354 = llvm.load %353 : !llvm.ptr<f32>
    %355 = llvm.fmul %346, %354  : f32
    %356 = llvm.fadd %338, %355  : f32
    %357 = llvm.mlir.constant(32 : index) : i64
    %358 = llvm.mul %6, %357  : i64
    %359 = llvm.mlir.constant(8 : index) : i64
    %360 = llvm.mul %273, %359  : i64
    %361 = llvm.add %358, %360  : i64
    %362 = llvm.add %361, %7  : i64
    %363 = llvm.getelementptr %13[%362] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %364 = llvm.load %363 : !llvm.ptr<f32>
    %365 = llvm.mlir.constant(32 : index) : i64
    %366 = llvm.mul %6, %365  : i64
    %367 = llvm.mlir.constant(4 : index) : i64
    %368 = llvm.mul %7, %367  : i64
    %369 = llvm.add %366, %368  : i64
    %370 = llvm.add %369, %275  : i64
    %371 = llvm.getelementptr %141[%370] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %372 = llvm.load %371 : !llvm.ptr<f32>
    %373 = llvm.fmul %364, %372  : f32
    %374 = llvm.fadd %356, %373  : f32
    %375 = llvm.mlir.constant(32 : index) : i64
    %376 = llvm.mul %6, %375  : i64
    %377 = llvm.mlir.constant(8 : index) : i64
    %378 = llvm.mul %273, %377  : i64
    %379 = llvm.add %376, %378  : i64
    %380 = llvm.add %379, %2  : i64
    %381 = llvm.getelementptr %13[%380] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %382 = llvm.load %381 : !llvm.ptr<f32>
    %383 = llvm.mlir.constant(32 : index) : i64
    %384 = llvm.mul %6, %383  : i64
    %385 = llvm.mlir.constant(4 : index) : i64
    %386 = llvm.mul %2, %385  : i64
    %387 = llvm.add %384, %386  : i64
    %388 = llvm.add %387, %275  : i64
    %389 = llvm.getelementptr %141[%388] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %390 = llvm.load %389 : !llvm.ptr<f32>
    %391 = llvm.fmul %382, %390  : f32
    %392 = llvm.fadd %374, %391  : f32
    %393 = llvm.mlir.constant(32 : index) : i64
    %394 = llvm.mul %6, %393  : i64
    %395 = llvm.mlir.constant(8 : index) : i64
    %396 = llvm.mul %273, %395  : i64
    %397 = llvm.add %394, %396  : i64
    %398 = llvm.add %397, %3  : i64
    %399 = llvm.getelementptr %13[%398] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %400 = llvm.load %399 : !llvm.ptr<f32>
    %401 = llvm.mlir.constant(32 : index) : i64
    %402 = llvm.mul %6, %401  : i64
    %403 = llvm.mlir.constant(4 : index) : i64
    %404 = llvm.mul %3, %403  : i64
    %405 = llvm.add %402, %404  : i64
    %406 = llvm.add %405, %275  : i64
    %407 = llvm.getelementptr %141[%406] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %408 = llvm.load %407 : !llvm.ptr<f32>
    %409 = llvm.fmul %400, %408  : f32
    %410 = llvm.fadd %392, %409  : f32
    %411 = llvm.mlir.constant(32 : index) : i64
    %412 = llvm.mul %6, %411  : i64
    %413 = llvm.mlir.constant(8 : index) : i64
    %414 = llvm.mul %273, %413  : i64
    %415 = llvm.add %412, %414  : i64
    %416 = llvm.add %415, %4  : i64
    %417 = llvm.getelementptr %13[%416] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %418 = llvm.load %417 : !llvm.ptr<f32>
    %419 = llvm.mlir.constant(32 : index) : i64
    %420 = llvm.mul %6, %419  : i64
    %421 = llvm.mlir.constant(4 : index) : i64
    %422 = llvm.mul %4, %421  : i64
    %423 = llvm.add %420, %422  : i64
    %424 = llvm.add %423, %275  : i64
    %425 = llvm.getelementptr %141[%424] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %426 = llvm.load %425 : !llvm.ptr<f32>
    %427 = llvm.fmul %418, %426  : f32
    %428 = llvm.fadd %410, %427  : f32
    %429 = llvm.mlir.constant(16 : index) : i64
    %430 = llvm.mul %6, %429  : i64
    %431 = llvm.mlir.constant(4 : index) : i64
    %432 = llvm.mul %273, %431  : i64
    %433 = llvm.add %430, %432  : i64
    %434 = llvm.add %433, %275  : i64
    %435 = llvm.getelementptr %209[%434] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %428, %435 : !llvm.ptr<f32>
    %436 = llvm.add %275, %8  : i64
    llvm.br ^bb10(%436 : i64)
  ^bb12:  // pred: ^bb10
    %437 = llvm.add %273, %8  : i64
    llvm.br ^bb9(%437 : i64)
  ^bb13(%438: i64):  // 2 preds: ^bb9, ^bb14
    %439 = llvm.icmp "slt" %438, %7 : i64
    llvm.cond_br %439, ^bb14, ^bb15
  ^bb14:  // pred: ^bb13
    %440 = llvm.mlir.constant(16 : index) : i64
    %441 = llvm.mul %6, %440  : i64
    %442 = llvm.mlir.constant(4 : index) : i64
    %443 = llvm.mul %438, %442  : i64
    %444 = llvm.add %441, %443  : i64
    %445 = llvm.add %444, %6  : i64
    %446 = llvm.getelementptr %209[%445] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %447 = llvm.load %446 : !llvm.ptr<f32>
    %448 = llvm.mlir.constant(16 : index) : i64
    %449 = llvm.mul %6, %448  : i64
    %450 = llvm.mlir.constant(4 : index) : i64
    %451 = llvm.mul %438, %450  : i64
    %452 = llvm.add %449, %451  : i64
    %453 = llvm.add %452, %6  : i64
    %454 = llvm.getelementptr %arg2[%453] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %447, %454 : !llvm.ptr<f32>
    %455 = llvm.mlir.constant(16 : index) : i64
    %456 = llvm.mul %6, %455  : i64
    %457 = llvm.mlir.constant(4 : index) : i64
    %458 = llvm.mul %438, %457  : i64
    %459 = llvm.add %456, %458  : i64
    %460 = llvm.add %459, %8  : i64
    %461 = llvm.getelementptr %209[%460] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %462 = llvm.load %461 : !llvm.ptr<f32>
    %463 = llvm.mlir.constant(16 : index) : i64
    %464 = llvm.mul %6, %463  : i64
    %465 = llvm.mlir.constant(4 : index) : i64
    %466 = llvm.mul %438, %465  : i64
    %467 = llvm.add %464, %466  : i64
    %468 = llvm.add %467, %8  : i64
    %469 = llvm.getelementptr %arg2[%468] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %462, %469 : !llvm.ptr<f32>
    %470 = llvm.mlir.constant(16 : index) : i64
    %471 = llvm.mul %6, %470  : i64
    %472 = llvm.mlir.constant(4 : index) : i64
    %473 = llvm.mul %438, %472  : i64
    %474 = llvm.add %471, %473  : i64
    %475 = llvm.add %474, %0  : i64
    %476 = llvm.getelementptr %209[%475] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %477 = llvm.load %476 : !llvm.ptr<f32>
    %478 = llvm.mlir.constant(16 : index) : i64
    %479 = llvm.mul %6, %478  : i64
    %480 = llvm.mlir.constant(4 : index) : i64
    %481 = llvm.mul %438, %480  : i64
    %482 = llvm.add %479, %481  : i64
    %483 = llvm.add %482, %0  : i64
    %484 = llvm.getelementptr %arg2[%483] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %477, %484 : !llvm.ptr<f32>
    %485 = llvm.mlir.constant(16 : index) : i64
    %486 = llvm.mul %6, %485  : i64
    %487 = llvm.mlir.constant(4 : index) : i64
    %488 = llvm.mul %438, %487  : i64
    %489 = llvm.add %486, %488  : i64
    %490 = llvm.add %489, %1  : i64
    %491 = llvm.getelementptr %209[%490] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    %492 = llvm.load %491 : !llvm.ptr<f32>
    %493 = llvm.mlir.constant(16 : index) : i64
    %494 = llvm.mul %6, %493  : i64
    %495 = llvm.mlir.constant(4 : index) : i64
    %496 = llvm.mul %438, %495  : i64
    %497 = llvm.add %494, %496  : i64
    %498 = llvm.add %497, %1  : i64
    %499 = llvm.getelementptr %arg2[%498] : (!llvm.ptr<f32>, i64) -> !llvm.ptr<f32>
    llvm.store %492, %499 : !llvm.ptr<f32>
    %500 = llvm.add %438, %8  : i64
    llvm.br ^bb13(%500 : i64)
  ^bb15:  // pred: ^bb13
    llvm.return
  }
}


